<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />

  <title>Class: Object</title>

  <link rel="stylesheet" href="./rdoc.css" type="text/css" media="screen" />

  <script src="./js/jquery.js" type="text/javascript"
    charset="utf-8"></script>
  <script src="./js/thickbox-compressed.js" type="text/javascript"
    charset="utf-8"></script>
  <script src="./js/quicksearch.js" type="text/javascript"
    charset="utf-8"></script>
  <script src="./js/darkfish.js" type="text/javascript"
    charset="utf-8"></script>

</head>
<body class="class">

  <div id="metadata">
    <div id="home-metadata">
      <div id="home-section" class="section">
        <h3 class="section-header">
          <a href="./index.html">Home</a>
          <a href="./index.html#classes">Classes</a>
          <a href="./index.html#methods">Methods</a>
        </h3>
      </div>
    </div>

    <div id="file-metadata">
      <div id="file-list-section" class="section">
        <h3 class="section-header">In Files</h3>
        <div class="section-body">
          <ul>
          
            <li><a href="./djinn_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="djinn.rb">djinn.rb</a></li>
          
            <li><a href="./djinnServer_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="djinnServer.rb">djinnServer.rb</a></li>
          
            <li><a href="./lib/app_controller_client_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/app_controller_client.rb">lib/app_controller_client.rb</a></li>
          
            <li><a href="./lib/cron_helper_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/cron_helper.rb">lib/cron_helper.rb</a></li>
          
            <li><a href="./lib/djinn_job_data_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/djinn_job_data.rb">lib/djinn_job_data.rb</a></li>
          
            <li><a href="./__/Neptune/ssa_helper_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="../Neptune/ssa_helper.rb">../Neptune/ssa_helper.rb</a></li>
          
            <li><a href="./__/Neptune/mpi_helper_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="../Neptune/mpi_helper.rb">../Neptune/mpi_helper.rb</a></li>
          
            <li><a href="./__/Neptune/appscale_helper_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="../Neptune/appscale_helper.rb">../Neptune/appscale_helper.rb</a></li>
          
            <li><a href="./__/Neptune/babel_helper_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="../Neptune/babel_helper.rb">../Neptune/babel_helper.rb</a></li>
          
            <li><a href="./__/Neptune/r_helper_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="../Neptune/r_helper.rb">../Neptune/r_helper.rb</a></li>
          
            <li><a href="./__/Neptune/cewssa_helper_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="../Neptune/cewssa_helper.rb">../Neptune/cewssa_helper.rb</a></li>
          
            <li><a href="./__/Neptune/go_helper_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="../Neptune/go_helper.rb">../Neptune/go_helper.rb</a></li>
          
            <li><a href="./__/Neptune/neptune_job_data_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="../Neptune/neptune_job_data.rb">../Neptune/neptune_job_data.rb</a></li>
          
            <li><a href="./__/Neptune/dfsp_helper_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="../Neptune/dfsp_helper.rb">../Neptune/dfsp_helper.rb</a></li>
          
            <li><a href="./__/Neptune/erlang_helper_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="../Neptune/erlang_helper.rb">../Neptune/erlang_helper.rb</a></li>
          
            <li><a href="./__/Neptune/mapreduce_helper_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="../Neptune/mapreduce_helper.rb">../Neptune/mapreduce_helper.rb</a></li>
          
            <li><a href="./__/Neptune/neptune_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="../Neptune/neptune.rb">../Neptune/neptune.rb</a></li>
          
            <li><a href="./__/Neptune/cicero_helper_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="../Neptune/cicero_helper.rb">../Neptune/cicero_helper.rb</a></li>
          
          </ul>
        </div>
      </div>

      
    </div>

    <div id="class-metadata">

      <!-- Parent Class -->
      
      <div id="parent-class-section" class="section">
        <h3 class="section-header">Parent</h3>
        
        <p class="link"></p>
        
      </div>
      

      <!-- Namespace Contents -->
      

      <!-- Method Quickref -->
      
      <div id="method-list-section" class="section">
        <h3 class="section-header">Methods</h3>
        <ul class="link-list">
          
          <li><a href="#method-i-add_nodes">#add_nodes</a></li>
          
          <li><a href="#method-i-add_roles_and_wait">#add_roles_and_wait</a></li>
          
          <li><a href="#method-i-average">#average</a></li>
          
          <li><a href="#method-i-can_run_job">#can_run_job</a></li>
          
          <li><a href="#method-i-copyFromShadow">#copyFromShadow</a></li>
          
          <li><a href="#method-i-execute_multiple_tasks">#execute_multiple_tasks</a></li>
          
          <li><a href="#method-i-get_engines_for_creds">#get_engines_for_creds</a></li>
          
          <li><a href="#method-i-get_execution_plan">#get_execution_plan</a></li>
          
          <li><a href="#method-i-get_inputs_from_job_data">#get_inputs_from_job_data</a></li>
          
          <li><a href="#method-i-get_job_name">#get_job_name</a></li>
          
          <li><a href="#method-i-get_language">#get_language</a></li>
          
          <li><a href="#method-i-get_length_of_all_queues">#get_length_of_all_queues</a></li>
          
          <li><a href="#method-i-get_lock_file_path">#get_lock_file_path</a></li>
          
          <li><a href="#method-i-get_n_items_of_work">#get_n_items_of_work</a></li>
          
          <li><a href="#method-i-get_node_roles">#get_node_roles</a></li>
          
          <li><a href="#method-i-get_queues_from_shadow">#get_queues_from_shadow</a></li>
          
          <li><a href="#method-i-get_queues_in_use">#get_queues_in_use</a></li>
          
          <li><a href="#method-i-is_storage_location-3F">#is_storage_location?</a></li>
          
          <li><a href="#method-i-lock_file_exists-3F">#lock_file_exists?</a></li>
          
          <li><a href="#method-i-neptune_acquire_nodes">#neptune_acquire_nodes</a></li>
          
          <li><a href="#method-i-neptune_acquire_nodes_for_cloud">#neptune_acquire_nodes_for_cloud</a></li>
          
          <li><a href="#method-i-neptune_appscale_run_job">#neptune_appscale_run_job</a></li>
          
          <li><a href="#method-i-neptune_babel_run_job">#neptune_babel_run_job</a></li>
          
          <li><a href="#method-i-neptune_cewssa_get_output">#neptune_cewssa_get_output</a></li>
          
          <li><a href="#method-i-neptune_cewssa_run_job">#neptune_cewssa_run_job</a></li>
          
          <li><a href="#method-i-neptune_cicero_run_job">#neptune_cicero_run_job</a></li>
          
          <li><a href="#method-i-neptune_compile_code">#neptune_compile_code</a></li>
          
          <li><a href="#method-i-neptune_dfsp_get_output">#neptune_dfsp_get_output</a></li>
          
          <li><a href="#method-i-neptune_dfsp_run_job">#neptune_dfsp_run_job</a></li>
          
          <li><a href="#method-i-neptune_does_file_exist">#neptune_does_file_exist</a></li>
          
          <li><a href="#method-i-neptune_erlang_run_job">#neptune_erlang_run_job</a></li>
          
          <li><a href="#method-i-neptune_find_open_nodes">#neptune_find_open_nodes</a></li>
          
          <li><a href="#method-i-neptune_get_acl">#neptune_get_acl</a></li>
          
          <li><a href="#method-i-neptune_get_output">#neptune_get_output</a></li>
          
          <li><a href="#method-i-neptune_get_ssa_num_simulations">#neptune_get_ssa_num_simulations</a></li>
          
          <li><a href="#method-i-neptune_get_ssa_seed_vals">#neptune_get_ssa_seed_vals</a></li>
          
          <li><a href="#method-i-neptune_get_supported_babel_engines">#neptune_get_supported_babel_engines</a></li>
          
          <li><a href="#method-i-neptune_go_run_job">#neptune_go_run_job</a></li>
          
          <li><a href="#method-i-neptune_is_job_running">#neptune_is_job_running</a></li>
          
          <li><a href="#method-i-neptune_mapreduce_get_output">#neptune_mapreduce_get_output</a></li>
          
          <li><a href="#method-i-neptune_mapreduce_run_job">#neptune_mapreduce_run_job</a></li>
          
          <li><a href="#method-i-neptune_mpi_get_output">#neptune_mpi_get_output</a></li>
          
          <li><a href="#method-i-neptune_mpi_run_job">#neptune_mpi_run_job</a></li>
          
          <li><a href="#method-i-neptune_put_input">#neptune_put_input</a></li>
          
          <li><a href="#method-i-neptune_r_run_job">#neptune_r_run_job</a></li>
          
          <li><a href="#method-i-neptune_release_nodes">#neptune_release_nodes</a></li>
          
          <li><a href="#method-i-neptune_set_acl">#neptune_set_acl</a></li>
          
          <li><a href="#method-i-neptune_ssa_get_output">#neptune_ssa_get_output</a></li>
          
          <li><a href="#method-i-neptune_ssa_run_job">#neptune_ssa_run_job</a></li>
          
          <li><a href="#method-i-neptune_start_job">#neptune_start_job</a></li>
          
          <li><a href="#method-i-optimal_nodes">#optimal_nodes</a></li>
          
          <li><a href="#method-i-parse_resource_info">#parse_resource_info</a></li>
          
          <li><a href="#method-i-remove_lock_file">#remove_lock_file</a></li>
          
          <li><a href="#method-i-remove_roles">#remove_roles</a></li>
          
          <li><a href="#method-i-run_job_on_master">#run_job_on_master</a></li>
          
          <li><a href="#method-i-run_on_db_master">#run_on_db_master</a></li>
          
          <li><a href="#method-i-run_task">#run_task</a></li>
          
          <li><a href="#method-i-run_via_cicero">#run_via_cicero</a></li>
          
          <li><a href="#method-i-run_via_engine">#run_via_engine</a></li>
          
          <li><a href="#method-i-run_via_executor">#run_via_executor</a></li>
          
          <li><a href="#method-i-spawn_babel_slaves">#spawn_babel_slaves</a></li>
          
          <li><a href="#method-i-spawn_nodes_for_neptune-3F">#spawn_nodes_for_neptune?</a></li>
          
          <li><a href="#method-i-standard_deviation">#standard_deviation</a></li>
          
          <li><a href="#method-i-start_appengine_on_all_nodes">#start_appengine_on_all_nodes</a></li>
          
          <li><a href="#method-i-start_babel_master">#start_babel_master</a></li>
          
          <li><a href="#method-i-start_babel_slave">#start_babel_slave</a></li>
          
          <li><a href="#method-i-start_cewssa_master">#start_cewssa_master</a></li>
          
          <li><a href="#method-i-start_cewssa_slave">#start_cewssa_slave</a></li>
          
          <li><a href="#method-i-start_cicero_master">#start_cicero_master</a></li>
          
          <li><a href="#method-i-start_cicero_slave">#start_cicero_slave</a></li>
          
          <li><a href="#method-i-start_dfsp_master">#start_dfsp_master</a></li>
          
          <li><a href="#method-i-start_dfsp_slave">#start_dfsp_slave</a></li>
          
          <li><a href="#method-i-start_erlang_master">#start_erlang_master</a></li>
          
          <li><a href="#method-i-start_erlang_slave">#start_erlang_slave</a></li>
          
          <li><a href="#method-i-start_go_master">#start_go_master</a></li>
          
          <li><a href="#method-i-start_go_slave">#start_go_slave</a></li>
          
          <li><a href="#method-i-start_job">#start_job</a></li>
          
          <li><a href="#method-i-start_mapreduce_master">#start_mapreduce_master</a></li>
          
          <li><a href="#method-i-start_mapreduce_slave">#start_mapreduce_slave</a></li>
          
          <li><a href="#method-i-start_mpd">#start_mpd</a></li>
          
          <li><a href="#method-i-start_mpi_master">#start_mpi_master</a></li>
          
          <li><a href="#method-i-start_mpi_slave">#start_mpi_slave</a></li>
          
          <li><a href="#method-i-start_nfs">#start_nfs</a></li>
          
          <li><a href="#method-i-start_r_master">#start_r_master</a></li>
          
          <li><a href="#method-i-start_r_slave">#start_r_slave</a></li>
          
          <li><a href="#method-i-start_ssa_master">#start_ssa_master</a></li>
          
          <li><a href="#method-i-start_ssa_slave">#start_ssa_slave</a></li>
          
          <li><a href="#method-i-stop_appengine_on_all_nodes">#stop_appengine_on_all_nodes</a></li>
          
          <li><a href="#method-i-stop_babel_master">#stop_babel_master</a></li>
          
          <li><a href="#method-i-stop_babel_slave">#stop_babel_slave</a></li>
          
          <li><a href="#method-i-stop_cewssa_master">#stop_cewssa_master</a></li>
          
          <li><a href="#method-i-stop_cewssa_slave">#stop_cewssa_slave</a></li>
          
          <li><a href="#method-i-stop_cicero_master">#stop_cicero_master</a></li>
          
          <li><a href="#method-i-stop_cicero_slave">#stop_cicero_slave</a></li>
          
          <li><a href="#method-i-stop_dfsp_master">#stop_dfsp_master</a></li>
          
          <li><a href="#method-i-stop_dfsp_slave">#stop_dfsp_slave</a></li>
          
          <li><a href="#method-i-stop_erlang_master">#stop_erlang_master</a></li>
          
          <li><a href="#method-i-stop_erlang_slave">#stop_erlang_slave</a></li>
          
          <li><a href="#method-i-stop_go_master">#stop_go_master</a></li>
          
          <li><a href="#method-i-stop_go_slave">#stop_go_slave</a></li>
          
          <li><a href="#method-i-stop_job">#stop_job</a></li>
          
          <li><a href="#method-i-stop_mapreduce_master">#stop_mapreduce_master</a></li>
          
          <li><a href="#method-i-stop_mapreduce_slave">#stop_mapreduce_slave</a></li>
          
          <li><a href="#method-i-stop_mpd">#stop_mpd</a></li>
          
          <li><a href="#method-i-stop_mpi_master">#stop_mpi_master</a></li>
          
          <li><a href="#method-i-stop_mpi_slave">#stop_mpi_slave</a></li>
          
          <li><a href="#method-i-stop_nfs">#stop_nfs</a></li>
          
          <li><a href="#method-i-stop_r_master">#stop_r_master</a></li>
          
          <li><a href="#method-i-stop_r_slave">#stop_r_slave</a></li>
          
          <li><a href="#method-i-stop_ssa_master">#stop_ssa_master</a></li>
          
          <li><a href="#method-i-stop_ssa_slave">#stop_ssa_slave</a></li>
          
          <li><a href="#method-i-touch_lock_file">#touch_lock_file</a></li>
          
          <li><a href="#method-i-unmount_nfs_store">#unmount_nfs_store</a></li>
          
          <li><a href="#method-i-validate_environment">#validate_environment</a></li>
          
          <li><a href="#method-i-variance">#variance</a></li>
          
          <li><a href="#method-i-wait_for_allotted_time">#wait_for_allotted_time</a></li>
          
          <li><a href="#method-i-wait_for_hdfs_file">#wait_for_hdfs_file</a></li>
          
        </ul>
      </div>
      

      <!-- Included Modules -->
      
      <div id="includes-section" class="section">
        <h3 class="section-header">Included Modules</h3>
        <ul class="link-list">
        
        
          <li><span class="include">REXML</span></li>
        
        
        </ul>
      </div>
      
    </div>

    <div id="project-metadata">
      
      

      <div id="classindex-section" class="section project-section">
        <h3 class="section-header">Class/Module Index
          <span class="search-toggle"><img src="./images/find.png"
            height="16" width="16" alt="[+]"
            title="show/hide quicksearch" /></span></h3>
        <form action="#" method="get" accept-charset="utf-8" class="initially-hidden">
        <fieldset>
          <legend>Quicksearch</legend>
          <input type="text" name="quicksearch" value=""
            class="quicksearch-field" />
        </fieldset>
        </form>

        <ul class="link-list">
        
          <li><a href="./AppControllerClient.html">AppControllerClient</a></li>
        
          <li><a href="./BadConfigurationException.html">BadConfigurationException</a></li>
        
          <li><a href="./BlobServer.html">BlobServer</a></li>
        
          <li><a href="./Collectd.html">Collectd</a></li>
        
          <li><a href="./CronHelper.html">CronHelper</a></li>
        
          <li><a href="./Datastore.html">Datastore</a></li>
        
          <li><a href="./DatastoreFactory.html">DatastoreFactory</a></li>
        
          <li><a href="./DatastoreRepo.html">DatastoreRepo</a></li>
        
          <li><a href="./DatastoreRepoOnAppEngine.html">DatastoreRepoOnAppEngine</a></li>
        
          <li><a href="./DatastoreRepoOnAppScale.html">DatastoreRepoOnAppScale</a></li>
        
          <li><a href="./DatastoreS3.html">DatastoreS3</a></li>
        
          <li><a href="./Djinn.html">Djinn</a></li>
        
          <li><a href="./DjinnJobData.html">DjinnJobData</a></li>
        
          <li><a href="./DjinnServer.html">DjinnServer</a></li>
        
          <li><a href="./Ejabberd.html">Ejabberd</a></li>
        
          <li><a href="./EngineFactory.html">EngineFactory</a></li>
        
          <li><a href="./FailedZooKeeperOperationException.html">FailedZooKeeperOperationException</a></li>
        
          <li><a href="./GodInterface.html">GodInterface</a></li>
        
          <li><a href="./GoogleAppEnginePullQueue.html">GoogleAppEnginePullQueue</a></li>
        
          <li><a href="./GoogleAppEnginePushQueue.html">GoogleAppEnginePushQueue</a></li>
        
          <li><a href="./HAProxy.html">HAProxy</a></li>
        
          <li><a href="./HelperFunctions.html">HelperFunctions</a></li>
        
          <li><a href="./JSONClient.html">JSONClient</a></li>
        
          <li><a href="./LoadBalancer.html">LoadBalancer</a></li>
        
          <li><a href="./Monitoring.html">Monitoring</a></li>
        
          <li><a href="./NeptuneJobData.html">NeptuneJobData</a></li>
        
          <li><a href="./Nginx.html">Nginx</a></li>
        
          <li><a href="./Object.html">Object</a></li>
        
          <li><a href="./PbServer.html">PbServer</a></li>
        
          <li><a href="./QueueFactory.html">QueueFactory</a></li>
        
          <li><a href="./RabbitMQ.html">RabbitMQ</a></li>
        
          <li><a href="./Repo.html">Repo</a></li>
        
          <li><a href="./TaskEngine.html">TaskEngine</a></li>
        
          <li><a href="./TaskEngineAppScale.html">TaskEngineAppScale</a></li>
        
          <li><a href="./TaskEngineGoogleAppEngine.html">TaskEngineGoogleAppEngine</a></li>
        
          <li><a href="./TaskQueue.html">TaskQueue</a></li>
        
          <li><a href="./TaskQueueAzureQueue.html">TaskQueueAzureQueue</a></li>
        
          <li><a href="./TaskQueueGoogleAppEngine.html">TaskQueueGoogleAppEngine</a></li>
        
          <li><a href="./TaskQueueRabbitMQ.html">TaskQueueRabbitMQ</a></li>
        
          <li><a href="./TaskQueueSQS.html">TaskQueueSQS</a></li>
        
          <li><a href="./UserAppClient.html">UserAppClient</a></li>
        
          <li><a href="./ZKInterface.html">ZKInterface</a></li>
        
        </ul>
        <div id="no-class-search-results" style="display: none;">No matching classes.</div>
      </div>

      
    </div>
  </div>

  <div id="documentation">
    <h1 class="class">Object</h1>

    <div id="description">
      
    </div>

    <!-- Constants -->
    
    <div id="constants-list" class="section">
      <h3 class="section-header">Constants</h3>
      <dl>
      
        <dt><a name="APPSCALE_HOME">APPSCALE_HOME</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="WANT_OUTPUT">WANT_OUTPUT</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="NO_OUTPUT">NO_OUTPUT</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="RESTRICTED_APPS">RESTRICTED_APPS</a></dt>
        
        <dd class="description"><p>A list of App Engine apps that the AppController will start and control
outside of the normal start_appengine method.</p></dd>
        
      
        <dt><a name="BAD_SECRET_MSG">BAD_SECRET_MSG</a></dt>
        
        <dd class="description"><p>The string that should be returned to the caller if they call a publicly
exposed SOAP method but provide an incorrect secret.</p></dd>
        
      
        <dt><a name="ZK_LOCATIONS_FILE">ZK_LOCATIONS_FILE</a></dt>
        
        <dd class="description"><p>The location on the local file system where we store information about
where ZooKeeper clients are located, used to backup and restore 
AppController information.</p></dd>
        
      
        <dt><a name="SINGLE_NODE_COMPUTE_JOBS">SINGLE_NODE_COMPUTE_JOBS</a></dt>
        
        <dd class="description"><p>A list of the Neptune jobs that AppScale will not automatically spawn up
nodes for. Babel (our distributed task execution system) is in this list
because it does not use the standard AppScale mechanism to acquire nodes,
and acquires nodes via specialized scaling techniques.</p></dd>
        
      
        <dt><a name="MULTI_NODE_COMPUTE_JOBS">MULTI_NODE_COMPUTE_JOBS</a></dt>
        
        <dd class="description"><p>A list of the Neptune jobs that AppScale will automatically spawn up more
nodes for.</p></dd>
        
      
        <dt><a name="NONCOMPUTE_JOBS">NONCOMPUTE_JOBS</a></dt>
        
        <dd class="description"><p>A list of Neptune jobs that are not considered to be computation jobs, and
relate to storage or pre-computation in some way.</p></dd>
        
      
        <dt><a name="NEPTUNE_JOBS">NEPTUNE_JOBS</a></dt>
        
        <dd class="description"><p>A list of all the Neptune jobs that we support in AppScale.</p></dd>
        
      
        <dt><a name="IP_REGEX">IP_REGEX</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="FQDN_REGEX">FQDN_REGEX</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="IP_OR_FQDN">IP_OR_FQDN</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="NO_TIMEOUT">NO_TIMEOUT</a></dt>
        
        <dd class="description"><p>Sometimes SOAP calls take a long time if large amounts of data are being
sent over the network: for this first version we don’t want these calls
to endlessly timeout and retry, so as a hack, just don’t let them
timeout. The next version should replace this and properly timeout and not
use long calls unless necessary.</p></dd>
        
      
        <dt><a name="RETRY_ON_FAIL">RETRY_ON_FAIL</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="ABORT_ON_FAIL">ABORT_ON_FAIL</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="ONE_HOUR">ONE_HOUR</a></dt>
        
        <dd class="description"><p>EC2 meters on a per-hour basis, so keep a constant for later use that
corresponds to a single hour.</p></dd>
        
      
        <dt><a name="HEARTBEAT_THRESHOLD">HEARTBEAT_THRESHOLD</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="MULTICORE">MULTICORE</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="SSA_HOME">SSA_HOME</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="IS_FILE">IS_FILE</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="NOT_A_FILE">NOT_A_FILE</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="MPD_HOSTS">MPD_HOSTS</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="MPI_OUTPUT">MPI_OUTPUT</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="TASK_QUEUE_NAME">TASK_QUEUE_NAME</a></dt>
        
        <dd class="description"><p>The name of the queue to use when storing or receiving tasks. Since some
providers use it as part of a FQDN, don’t put underscores or other
non-FQDN characters in it.</p></dd>
        
      
        <dt><a name="INTERNAL_ENGINES">INTERNAL_ENGINES</a></dt>
        
        <dd class="description"><p>When executing over AppScale resources only, we can utilize <a
href="RabbitMQ.html">RabbitMQ</a> as a queue and use Executor, our task
engine, or we can make the app into an App Engine app and exeucte it via
the App Engine Task Queue API.</p></dd>
        
      
        <dt><a name="AMAZON_CREDENTIALS">AMAZON_CREDENTIALS</a></dt>
        
        <dd class="description"><p>When executing over AppScale with Amazon credentials, we can utilize 
Amazon SQS (Simple Queue Service) as a queue and use Executor to execute
tasks.</p></dd>
        
      
        <dt><a name="AMAZON_ENGINES">AMAZON_ENGINES</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="GOOGLE_CREDENTIALS">GOOGLE_CREDENTIALS</a></dt>
        
        <dd class="description"><p>When executing over AppScale with Google credentials, we can utilize Google
App Engine’s push queues as the queue and task engine or Google App
Engine’s pull queues as the queue and Executor to execute tasks. Since
our pull queue support is done via an App Engine app, the same credentials
will work for pull queues as for push queues (minus @function).</p></dd>
        
      
        <dt><a name="GOOGLE_ENGINES">GOOGLE_ENGINES</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="AZURE_CREDENTIALS">AZURE_CREDENTIALS</a></dt>
        
        <dd class="description"><p>When executing over AppScale with Azure credentials, we can utilize the
Windows Azure Queue Service as a queue and use Executor to execute tasks.</p></dd>
        
      
        <dt><a name="AZURE_ENGINES">AZURE_ENGINES</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="STORAGE_PARAM_REGEX">STORAGE_PARAM_REGEX</a></dt>
        
        <dd class="description"><p>Files stored in remote datastores are referenced in a POSIX-like fashion:
/bucket/file refers to a file stored in S3, with the named bucket and file.</p></dd>
        
      
        <dt><a name="RUN_LOCALLY">RUN_LOCALLY</a></dt>
        
        <dd class="description"><p>Constants that are used to indicate which engine runs a task.</p></dd>
        
      
        <dt><a name="RUN_VIA_EXECUTOR">RUN_VIA_EXECUTOR</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="RUN_VIA_REMOTE_ENGINE">RUN_VIA_REMOTE_ENGINE</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="TIME_TO_WAIT_FOR_NEW_TASKS">TIME_TO_WAIT_FOR_NEW_TASKS</a></dt>
        
        <dd class="description"><p>Constants that are used to indicate how long a babel_master node should
sleep for if there are no tasks to schedule, and how long to sleep for if
new babel_slaves have been spawned and need time to fetch tasks off of
queues.</p></dd>
        
      
        <dt><a name="TIME_FOR_NEW_NODES_TO_GET_TASKS">TIME_FOR_NEW_NODES_TO_GET_TASKS</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="INSTANCE_CPU_INFO">INSTANCE_CPU_INFO</a></dt>
        
        <dd class="description"><p>A mapping of Amazon EC2 instance types that maps instance types to the
number of cores they have. TODO(cgb): Should we eventually include memory /
disk info here?</p></dd>
        
      
        <dt><a name="DEBUG">DEBUG</a></dt>
        
        <dd class="description"><p>This debug flag is used to keep the user’s code on the local filesystem,
which can be useful to debug why code did not run successfully.</p></dd>
        
      
        <dt><a name="BIRTH_DEATH">BIRTH_DEATH</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="OUTPUT_HOME">OUTPUT_HOME</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="OUR_CEWSSA_CODE">OUR_CEWSSA_CODE</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="MERGE_SCRIPT">MERGE_SCRIPT</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="COST">COST</a></dt>
        
        <dd class="description"><p>The current costs for EC2 instances in the East Coast region. TODO(cgb):
Find out some way to get this dynamically so we can record costs in more
than one region, or utilize clouds with a different cloud model (e.g.,
community or private clouds).</p></dd>
        
      
        <dt><a name="DFSP_HOME">DFSP_HOME</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="ERLANG_OUTPUT">ERLANG_OUTPUT</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="BAD_TABLE_MSG">BAD_TABLE_MSG</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="DBS_W_HADOOP">DBS_W_HADOOP</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="HADOOP">HADOOP</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="STREAMING">STREAMING</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="ALLOWED_STORAGE_TYPES">ALLOWED_STORAGE_TYPES</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="NO_INPUT_NEEDED">NO_INPUT_NEEDED</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="NO_NODES_NEEDED">NO_NODES_NEEDED</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="JOB_IN_PROGRESS">JOB_IN_PROGRESS</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="BAD_TYPE_MSG">BAD_TYPE_MSG</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="MISSING_PARAM">MISSING_PARAM</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="STARTED_SUCCESSFULLY">STARTED_SUCCESSFULLY</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="NOT_QUITE_AN_HOUR">NOT_QUITE_AN_HOUR</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="INFINITY">INFINITY</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="URL_REGEX">URL_REGEX</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="RETRY_TIME">RETRY_TIME</a></dt>
        
        <dd class="description"></dd>
        
      
      </dl>
    </div>
    

    <!-- Attributes -->
    

    <!-- Methods -->
    
    <div id="public-instance-method-details" class="method-section section">
      <h3 class="section-header">Public Instance Methods</h3>

    
      <div id="add_nodes-method" class="method-detail ">
        <a name="method-i-add_nodes"></a>

        
        <div class="method-heading">
          <span class="method-name">add_nodes</span><span
            class="method-args">(node_info)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="add_nodes-source">
<pre>
<span class="ruby-comment"># File ../Neptune/neptune.rb, line 631</span>
def add_nodes(node_info)
  keyname = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">'keyname'</span>]
  new_nodes = <span class="ruby-constant">Djinn</span>.convert_location_array_to_class(node_info, keyname)

  node_start_time = <span class="ruby-constant">Time</span>.now
  node_end_time = <span class="ruby-constant">Time</span>.now + <span class="ruby-constant">NOT_QUITE_AN_HOUR</span>

  new_nodes.each { |node|
    node.set_time_info(node_start_time, node_end_time)
  }

  <span class="ruby-ivar">@nodes</span>.concat(new_nodes)
  <span class="ruby-ivar">@neptune_nodes</span>.concat(new_nodes)
  initialize_nodes_in_parallel(new_nodes)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="add_roles_and_wait-method" class="method-detail ">
        <a name="method-i-add_roles_and_wait"></a>

        
        <div class="method-heading">
          <span class="method-name">add_roles_and_wait</span><span
            class="method-args">(nodes, roles)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="add_roles_and_wait-source">
<pre>
<span class="ruby-comment"># File ../Neptune/neptune.rb, line 674</span>
def add_roles_and_wait(nodes, roles)
  return if nodes.nil?

  nodes.each { |node|
    node.add_roles(roles)
    acc = <span class="ruby-constant">AppControllerClient</span>.new(node.private_ip, <span class="ruby-constant">HelperFunctions</span>.get_secret)
    acc.add_role(roles)
    acc.wait_for_node_to_be(roles)
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;[just added] node at #{node.private_ip} is now #{node.jobs.join(', ')}&quot;)
  }
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="average-method" class="method-detail ">
        <a name="method-i-average"></a>

        
        <div class="method-heading">
          <span class="method-name">average</span><span
            class="method-args">(population)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="average-source">
<pre>
<span class="ruby-comment"># File ../Neptune/ssa_helper.rb, line 252</span>
def average(population)
  total = 0.0
  n = 0

  population.each { |val|
    total += val
    n += 1
  }

  return total / n
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="can_run_job-method" class="method-detail ">
        <a name="method-i-can_run_job"></a>

        
        <div class="method-heading">
          <span class="method-name">can_run_job</span><span
            class="method-args">(job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="can_run_job-source">
<pre>
<span class="ruby-comment"># File ../Neptune/neptune.rb, line 265</span>
def can_run_job(job_data)
  <span class="ruby-comment"># no input / output for appscale jobs</span>
  return :ok if job_data[<span class="ruby-string">&quot;@type&quot;</span>] == <span class="ruby-string">&quot;appscale&quot;</span>

  storage = job_data[<span class="ruby-string">&quot;@storage&quot;</span>]

  if !<span class="ruby-constant">ALLOWED_STORAGE_TYPES</span>.include?(storage)
    return &quot;error: bad storage type - supported types are #{ALLOWED_STORAGE_TYPES.join(', ')}&quot;
  end

  datastore = <span class="ruby-constant">DatastoreFactory</span>.get_datastore(storage, job_data)

  input_location = job_data[<span class="ruby-string">&quot;@input&quot;</span>]
  if input_location and !<span class="ruby-constant">NO_INPUT_NEEDED</span>.include?(job_data[<span class="ruby-string">'@type'</span>])
    input_exists = datastore.does_file_exist?(input_location)
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;input specified - did #{input_location} exist? #{input_exists}&quot;)
    unless input_exists
      return <span class="ruby-string">&quot;error: input specified but did not exist&quot;</span>
    end
  else
    <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;input not specified - moving on&quot;</span>)
  end

  output_location = job_data[<span class="ruby-string">&quot;@output&quot;</span>]
  output_exists = datastore.does_file_exist?(output_location)
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;output specified - did #{output_location} exist? #{output_exists}&quot;)
  if output_exists
    return <span class="ruby-string">&quot;error: output already exists&quot;</span>
  end

  <span class="ruby-constant">Djinn</span>.log_debug(&quot;job type is [#{job_data[&quot;@type&quot;]}]&quot;)

  if <span class="ruby-constant">NO_NODES_NEEDED</span>.include?(job_data[<span class="ruby-string">&quot;@type&quot;</span>])
    return :ok
  else
    unless job_data[<span class="ruby-string">&quot;@nodes_to_use&quot;</span>]
      return <span class="ruby-string">&quot;error: failed to specify nodes_to_use, a required parameter&quot;</span>
    end
  end

  if !(is_cloud? or is_hybrid_cloud?)
    <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;not in cloud&quot;</span>)
    <span class="ruby-comment"># make sure we have enough open nodes</span>
    <span class="ruby-comment"># a bit race-y, see the TODO on set for more info</span>

    <span class="ruby-comment"># In non-hybrid clouds, if the user specifies that they want to run over</span>
    <span class="ruby-comment"># multiple clouds, then either all clouds must be using remote resources</span>
    <span class="ruby-comment"># (e.g., only URLs are specified), or the first cloud has an integer value</span>
    <span class="ruby-comment"># (which we interpret as our cloud) and the others are remote clouds</span>
    if job_data[<span class="ruby-string">&quot;@nodes_to_use&quot;</span>].class == <span class="ruby-constant">Array</span>
      hash_job_data = <span class="ruby-constant">Hash</span>[*job_data[<span class="ruby-string">&quot;@nodes_to_use&quot;</span>]]
      hash_job_data.each { |cloud, nodes_needed|
        if nodes_needed =~ <span class="ruby-constant">URL_REGEX</span>
          <span class="ruby-constant">Djinn</span>.log_debug(&quot;Saw URL [#{nodes_needed}] for cloud [#{cloud}] - &quot; +
            <span class="ruby-string">&quot;moving on to next cloud&quot;</span>)
          next
        end

        if cloud == <span class="ruby-string">&quot;cloud1&quot;</span> and nodes_needed.class == <span class="ruby-constant">Fixnum</span>
          <span class="ruby-constant">Djinn</span>.log_debug(&quot;Saw [#{nodes_needed}] nodes needed for cloud &quot; +
            &quot;[#{cloud}] - moving on to next cloud&quot;)
          next
        end

        <span class="ruby-constant">Djinn</span>.log_debug(&quot;Saw cloud [#{cloud}] and nodes needed &quot; + 
          &quot;[#{nodes_needed}], which was not acceptable in non-hybrid &quot; + 
          <span class="ruby-string">&quot;cloud deployments&quot;</span>)

        return <span class="ruby-string">&quot;error: cannot specify hybrid deployment in non-hybrid cloud runs&quot;</span>
      }

      if hash_job_data[<span class="ruby-string">&quot;cloud1&quot;</span>].class == <span class="ruby-constant">Fixnum</span>
        num_of_vms_needed = <span class="ruby-constant">Integer</span>(hash_job_data[<span class="ruby-string">&quot;cloud1&quot;</span>])
      else
        return :ok
      end
    elsif job_data[<span class="ruby-string">&quot;@nodes_to_use&quot;</span>].class == <span class="ruby-constant">Fixnum</span>
      num_of_vms_needed = <span class="ruby-constant">Integer</span>(job_data[<span class="ruby-string">&quot;@nodes_to_use&quot;</span>])
    else
      return <span class="ruby-string">&quot;error: nodes_to_use specified was not an Array or Fixnum&quot;</span> +
        &quot; but was a #{job_data['@nodes_to_use'].class}&quot;
    end

    nodes_to_use = []
      <span class="ruby-ivar">@nodes</span>.each { |node|
        if node.is_open?
          nodes_to_use &lt;&lt; node
          break if nodes_to_use.length == num_of_vms_needed
        end
      } 

    if nodes_to_use.length &lt; num_of_vms_needed   
      return &quot;error: not enough free nodes (requested = #{num_of_vms_needed}, available = #{nodes_to_use.length})&quot;
    end
  end

  return :ok
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="copyFromShadow-method" class="method-detail ">
        <a name="method-i-copyFromShadow"></a>

        
        <div class="method-heading">
          <span class="method-name">copyFromShadow</span><span
            class="method-args">(location_on_shadow)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="copyFromShadow-source">
<pre>
<span class="ruby-comment"># File ../Neptune/neptune.rb, line 697</span>
def copyFromShadow(location_on_shadow)
  shadow = get_shadow
  shadow_ip = shadow.private_ip
  shadow_key = shadow.ssh_key

  copy_from_shadow = &quot;scp -r -i #{my_node.ssh_key} #{location_on_shadow} root@#{my_node.public_ip}:#{location_on_shadow}&quot;
  <span class="ruby-constant">HelperFunctions</span>.run_remote_command(shadow_ip, copy_from_shadow, shadow_key, <span class="ruby-constant">NO_OUTPUT</span>)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="execute_multiple_tasks-method" class="method-detail ">
        <a name="method-i-execute_multiple_tasks"></a>

        
        <div class="method-heading">
          <span class="method-name">execute_multiple_tasks</span><span
            class="method-args">(tasks)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>This method spawns a thread for each task given to execute them in
parallel. It then waits for all tasks to complete before returning.</p>
          

          
          <div class="method-source-code"
            id="execute_multiple_tasks-source">
<pre>
<span class="ruby-comment"># File ../Neptune/babel_helper.rb, line 616</span>
def execute_multiple_tasks(tasks)
  threads = []
  tasks.each { |task|
    threads &lt;&lt; <span class="ruby-constant">Thread</span>.new {
      run_task(task)
    }
  }

  threads.each { |t| t.join }
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="get_engines_for_creds-method" class="method-detail ">
        <a name="method-i-get_engines_for_creds"></a>

        
        <div class="method-heading">
          <span class="method-name">get_engines_for_creds</span><span
            class="method-args">(job_data, credentials, engines_to_add)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Checks the credentials that the user has given us (job_data) to see if they
match up to the credentials needed for the given engine. If so, we return
the list of engines that can be safely added.</p>
          

          
          <div class="method-source-code"
            id="get_engines_for_creds-source">
<pre>
<span class="ruby-comment"># File ../Neptune/babel_helper.rb, line 139</span>
def get_engines_for_creds(job_data, credentials, engines_to_add)

  credentials.each { |cred|
    if !job_data.include?(cred)
      <span class="ruby-constant">Djinn</span>.log_debug(&quot;credentials did not have #{cred}, so not &quot; +
        &quot;#{engines_to_add.join(', ')}&quot;)
      return []
    end
  }

  <span class="ruby-constant">Djinn</span>.log_debug(&quot;adding engines #{engines_to_add.join(', ')}&quot;)
  return engines_to_add
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="get_execution_plan-method" class="method-detail ">
        <a name="method-i-get_execution_plan"></a>

        
        <div class="method-heading">
          <span class="method-name">get_execution_plan</span><span
            class="method-args">(nodes, resource_info, num_tasks)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="get_execution_plan-source">
<pre>
<span class="ruby-comment"># File ../Neptune/cicero_helper.rb, line 220</span>
def get_execution_plan(nodes, resource_info, num_tasks)
  <span class="ruby-comment"># based on the resource info given, deduce where to run tasks</span>
  <span class="ruby-comment"># and how many should be run in each cloud</span>

  <span class="ruby-comment"># for now, just divide the work evenly on all the clouds the user has given us</span>

  execution_plan = {}
  num_clouds = resource_info.length
  num_tasks_left = num_tasks

  num_tasks_per_cloud = num_tasks / num_clouds
  resource_info.each { |k, v|
    execution_plan[k] = num_tasks_per_cloud
    num_tasks_left -= num_tasks_per_cloud
  }

  if !num_tasks_left.zero?
    <span class="ruby-comment"># TODO - the user may not have specified cloud1, so refactor later to use</span>
    <span class="ruby-comment"># whatever the first cloud specified was</span>
    execution_plan[<span class="ruby-string">&quot;cloud1&quot;</span>] += num_tasks_left
  end

  <span class="ruby-constant">Djinn</span>.log_debug(&quot;num_tasks_per_cloud = #{execution_plan.inspect}&quot;)
  return execution_plan
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="get_inputs_from_job_data-method" class="method-detail ">
        <a name="method-i-get_inputs_from_job_data"></a>

        
        <div class="method-heading">
          <span class="method-name">get_inputs_from_job_data</span><span
            class="method-args">(job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>The user can specify an arbitrary number of inputs to be used for a TaskQ
job. The inputs must be sequentially numbered, so search through all the
job data starting at input1 until we fail to find a match, and return all
inputs found.</p>
          

          
          <div class="method-source-code"
            id="get_inputs_from_job_data-source">
<pre>
<span class="ruby-comment"># File ../Neptune/cicero_helper.rb, line 199</span>
def get_inputs_from_job_data(job_data)
  inputs = []
  input_number = 1
  loop {
    current_input = &quot;@input#{input_number}&quot;
    current_val = job_data[current_input]
    if current_val.nil?
      <span class="ruby-constant">Djinn</span>.log_debug(&quot;Didn't see [#{current_input}] - no more inputs&quot;)
      break
    end

    <span class="ruby-constant">Djinn</span>.log_debug(&quot;Saw [#{current_input}] -&gt; [#{current_val}], adding&quot; +
      <span class="ruby-string">&quot; to the input list&quot;</span>)
    inputs &lt;&lt; current_val
    input_number += 1
  }

  <span class="ruby-constant">Djinn</span>.log_debug(&quot;all inputs for this job are [#{inputs.join(', ')}]&quot;)
  return inputs
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="get_job_name-method" class="method-detail ">
        <a name="method-i-get_job_name"></a>

        
        <div class="method-heading">
          <span class="method-name">get_job_name</span><span
            class="method-args">(job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="get_job_name-source">
<pre>
<span class="ruby-comment"># File ../Neptune/neptune.rb, line 662</span>
def get_job_name(job_data)
  job_name = job_data[<span class="ruby-string">&quot;@type&quot;</span>]

  [<span class="ruby-string">&quot;@code&quot;</span>, <span class="ruby-string">&quot;@main&quot;</span>, <span class="ruby-string">&quot;@map&quot;</span>, <span class="ruby-string">&quot;@reduce&quot;</span>, <span class="ruby-string">&quot;@simulations&quot;</span>, <span class="ruby-string">&quot;@add_component&quot;</span>].each { |item|
    if job_data[item]
      job_name += <span class="ruby-string">&quot; - &quot;</span> + &quot;#{job_data[item]}&quot;
    end
  }

  return job_name
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="get_language-method" class="method-detail ">
        <a name="method-i-get_language"></a>

        
        <div class="method-heading">
          <span class="method-name">get_language</span><span
            class="method-args">(filename)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="get_language-source">
<pre>
<span class="ruby-comment"># File ../Neptune/mapreduce_helper.rb, line 193</span>
def get_language(filename)
  return <span class="ruby-string">&quot;ruby&quot;</span>
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="get_length_of_all_queues-method" class="method-detail ">
        <a name="method-i-get_length_of_all_queues"></a>

        
        <div class="method-heading">
          <span class="method-name">get_length_of_all_queues</span><span
            class="method-args">(queues)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="get_length_of_all_queues-source">
<pre>
<span class="ruby-comment"># File ../Neptune/babel_helper.rb, line 526</span>
def get_length_of_all_queues(queues)
  <span class="ruby-comment"># something to consider: do leased tasks count in the size?</span>
  length = 0
  queues.each { |q|
    length += q.size
  }
  return length
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="get_lock_file_path-method" class="method-detail ">
        <a name="method-i-get_lock_file_path"></a>

        
        <div class="method-heading">
          <span class="method-name">get_lock_file_path</span><span
            class="method-args">(job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="get_lock_file_path-source">
<pre>
<span class="ruby-comment"># File ../Neptune/neptune.rb, line 507</span>
def get_lock_file_path(job_data)
  &quot;/tmp/#{job_data['@type']}-#{job_data['@job_id']}-started&quot;
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="get_n_items_of_work-method" class="method-detail ">
        <a name="method-i-get_n_items_of_work"></a>

        
        <div class="method-heading">
          <span class="method-name">get_n_items_of_work</span><span
            class="method-args">(n, queues)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="get_n_items_of_work-source">
<pre>
<span class="ruby-comment"># File ../Neptune/babel_helper.rb, line 536</span>
def get_n_items_of_work(n, queues)
  items = []

  queues.each { |q|
    loop {
      <span class="ruby-constant">Djinn</span>.log_debug(&quot;popping an item of work off of queue #{q}&quot;)
      new_item = q.pop
      if new_item.nil?
        <span class="ruby-constant">Djinn</span>.log_debug(&quot;#{q} is empty - moving on to next queue&quot;)
        break  <span class="ruby-comment"># the queue is empty</span>
      end
      <span class="ruby-constant">Djinn</span>.log_debug(&quot;adding [#{new_item}][#{new_item.class}] to items&quot;)
      items &lt;&lt; new_item

      break if items.length &gt;= n
    }

    break if items.length &gt;= n
  }

  <span class="ruby-constant">Djinn</span>.log_debug(&quot;returning [#{items.join(', ')}] items of work&quot;)
  return items
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="get_node_roles-method" class="method-detail ">
        <a name="method-i-get_node_roles"></a>

        
        <div class="method-heading">
          <span class="method-name">get_node_roles</span><span
            class="method-args">(job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="get_node_roles-source">
<pre>
<span class="ruby-comment"># File ../Neptune/neptune.rb, line 394</span>
def get_node_roles(job_data)
  <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;getting node roles&quot;</span>)
  job_type = job_data[<span class="ruby-string">&quot;@type&quot;</span>]

  if job_type == <span class="ruby-string">&quot;appscale&quot;</span>
    component_to_add = job_data[<span class="ruby-string">&quot;@add_component&quot;</span>]
    master_role = component_to_add
    slave_roles = component_to_add
  elsif job_type == <span class="ruby-string">&quot;mapreduce&quot;</span>
    master_role = <span class="ruby-string">&quot;db_slave:mapreduce_master&quot;</span>
    slave_roles = <span class="ruby-string">&quot;db_slave:mapreduce_slave&quot;</span>
  else
    master_role = &quot;#{job_type}_master&quot;
    slave_roles = &quot;#{job_type}_slave&quot;
  end

  <span class="ruby-constant">Djinn</span>.log_debug(&quot;master role is [#{master_role}], slave roles are &quot; +
    &quot;[#{slave_roles}]&quot;)
  return master_role, slave_roles
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="get_queues_from_shadow-method" class="method-detail ">
        <a name="method-i-get_queues_from_shadow"></a>

        
        <div class="method-heading">
          <span class="method-name">get_queues_from_shadow</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="get_queues_from_shadow-source">
<pre>
<span class="ruby-comment"># File ../Neptune/babel_helper.rb, line 499</span>
def get_queues_from_shadow()
  secret = <span class="ruby-constant">HelperFunctions</span>.get_secret()
  acc = <span class="ruby-constant">AppControllerClient</span>.new(get_shadow.public_ip, secret)
  json_queue_and_cred_info = acc.get_queues_in_use()
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;raw json received is '#{json_queue_and_cred_info}'&quot;)
  queue_and_cred_info = <span class="ruby-constant">JSON</span>.load(json_queue_and_cred_info)
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;json formatted data is [#{queue_and_cred_info}]&quot;)

  queues = []
  if queue_and_cred_info.nil?
    <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;queues from shadow are nil&quot;</span>)
    return queues
  end

  queue_and_cred_info.each { |info|
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;this queue's info is #{info.inspect}&quot;)
    engine = info.keys[0]
    credentials = info.values[0]
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;engine is [#{engine}], credentials are [#{credentials.inspect}]&quot;)
    queues &lt;&lt; <span class="ruby-constant">QueueFactory</span>.get_queue(engine, credentials)
  }

  <span class="ruby-constant">Djinn</span>.log_debug(&quot;queues from shadow are [#{queues.join(', ')}]&quot;)
  return queues
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="get_queues_in_use-method" class="method-detail ">
        <a name="method-i-get_queues_in_use"></a>

        
        <div class="method-heading">
          <span class="method-name">get_queues_in_use</span><span
            class="method-args">(secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Tasks can be stored in multiple queues concurrently, so this method
provides workers (babel_slaves) with the way to learn what queues are
currently in use and the credentials needed to access them.</p>
          

          
          <div class="method-source-code"
            id="get_queues_in_use-source">
<pre>
<span class="ruby-comment"># File ../Neptune/babel_helper.rb, line 242</span>
def get_queues_in_use(secret)
  return <span class="ruby-constant">BAD_SECRET_MSG</span> if !valid_secret?(secret)
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;@queues_to_read is #{@queues_to_read.join(', ')}, class #{@queues_to_read.class}&quot;)
  return <span class="ruby-constant">JSON</span>.dump(<span class="ruby-ivar">@queues_to_read</span>)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="is_storage_location-3F-method" class="method-detail ">
        <a name="method-i-is_storage_location-3F"></a>

        
        <div class="method-heading">
          <span class="method-name">is_storage_location?</span><span
            class="method-args">(file)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="is_storage_location-3F-source">
<pre>
<span class="ruby-comment"># File ../Neptune/babel_helper.rb, line 494</span>
def is_storage_location?(file)
  return <span class="ruby-constant">STORAGE_PARAM_REGEX</span>.match(file)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="lock_file_exists-3F-method" class="method-detail ">
        <a name="method-i-lock_file_exists-3F"></a>

        
        <div class="method-heading">
          <span class="method-name">lock_file_exists?</span><span
            class="method-args">(job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="lock_file_exists-3F-source">
<pre>
<span class="ruby-comment"># File ../Neptune/neptune.rb, line 488</span>
def lock_file_exists?(job_data)
  return <span class="ruby-constant">File</span>.exists?(get_lock_file_path(job_data))
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="neptune_acquire_nodes-method" class="method-detail ">
        <a name="method-i-neptune_acquire_nodes"></a>

        
        <div class="method-heading">
          <span class="method-name">neptune_acquire_nodes</span><span
            class="method-args">(job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="neptune_acquire_nodes-source">
<pre>
<span class="ruby-comment"># File ../Neptune/neptune.rb, line 516</span>
def neptune_acquire_nodes(job_data)
  <span class="ruby-comment"># for jobs where no nodes need to be acquired (e.g., concurrent but not</span>
  <span class="ruby-comment"># distributed programs), run them on the shadow node</span>
  if <span class="ruby-constant">NO_NODES_NEEDED</span>.include?(job_data[<span class="ruby-string">&quot;@type&quot;</span>])
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;No nodes needed for job type [#{job_data['@type']}],&quot; +
      <span class="ruby-string">&quot; not acquiring nodes&quot;</span>)
    return [my_node]
  end

  <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;acquiring nodes&quot;</span>)

  <span class="ruby-comment">#num_of_vms_needed = optimal_nodes_hill_climbing(job_data, &quot;performance&quot;)</span>
  nodes_needed = optimal_nodes(job_data)

  <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;acquiring nodes for hybrid cloud neptune job&quot;</span>)

  if nodes_needed.class == <span class="ruby-constant">Array</span>
    nodes_needed = <span class="ruby-constant">Hash</span>[*nodes_needed]
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;request received to spawn hybrid nodes: #{nodes_needed.inspect}&quot;)
  elsif nodes_needed.class == <span class="ruby-constant">Fixnum</span>
    nodes_needed = {<span class="ruby-string">&quot;cloud1&quot;</span> =&gt; nodes_needed}
  else
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;nodes_needed was not the right class - should have been Array or Fixnum but was #{nodes_needed.class}&quot;)
    <span class="ruby-comment"># TODO: find a way to reject the job here</span>
  end

  nodes_to_use = []

  nodes_needed.each { |cloud, nodes_to_acquire|
    <span class="ruby-comment"># nodes_to_acquire can either be an integer or a URL</span>
    <span class="ruby-comment"># if it's an integer, spawn up that many nodes</span>
    <span class="ruby-comment"># if it's a URL, it refers to a remote cloud resource we don't control</span>
    <span class="ruby-comment"># (e.g., Google App Engine), so skip it</span>

    <span class="ruby-comment"># in non-hybrid cloud runs, cloud1 will be the only cloud that specifies</span>
    <span class="ruby-comment"># an integer value</span>
    if nodes_to_acquire =~ <span class="ruby-constant">URL_REGEX</span>
      <span class="ruby-constant">Djinn</span>.log_debug(&quot;nodes to acquire for #{cloud} was a URL &quot; + 
        &quot;[#{nodes_to_acquire}], so not spawning nodes&quot;)
      next
    end

    <span class="ruby-constant">Djinn</span>.log_debug(&quot;acquiring #{nodes_to_acquire} nodes for #{cloud}&quot;)
    nodes_for_cloud = neptune_find_open_nodes(cloud, nodes_to_acquire, job_data)
    nodes_to_use = [nodes_to_use + nodes_for_cloud].flatten
    <span class="ruby-comment"># TODO: should check for failures acquiring nodes</span>
  }

  return nodes_to_use
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="neptune_acquire_nodes_for_cloud-method" class="method-detail ">
        <a name="method-i-neptune_acquire_nodes_for_cloud"></a>

        
        <div class="method-heading">
          <span class="method-name">neptune_acquire_nodes_for_cloud</span><span
            class="method-args">(cloud_num, new_vms_needed, job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="neptune_acquire_nodes_for_cloud-source">
<pre>
<span class="ruby-comment"># File ../Neptune/neptune.rb, line 611</span>
def neptune_acquire_nodes_for_cloud(cloud_num, new_vms_needed, job_data)
  return if new_vms_needed &lt; 1
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;spawning up #{new_vms_needed} vms&quot;)

  job = <span class="ruby-string">&quot;open&quot;</span> <span class="ruby-comment"># *_helper will add the right role later</span>
  machine = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;machine&quot;</span>]
  <span class="ruby-constant">ENV</span>[<span class="ruby-string">'EC2_URL'</span>] = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;ec2_url&quot;</span>]
  instance_type = job_data[<span class="ruby-string">'@instance_type'</span>] or <span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;instance_type&quot;</span>]
  keyname = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;keyname&quot;</span>]
  infrastructure = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;infrastructure&quot;</span>]
  group = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;group&quot;</span>]

  <span class="ruby-constant">HelperFunctions</span>.set_creds_in_env(<span class="ruby-ivar">@creds</span>, cloud_num)
  new_node_info = <span class="ruby-constant">HelperFunctions</span>.spawn_vms(new_vms_needed, job, machine,
    instance_type, keyname, infrastructure, &quot;cloud#{cloud_num}&quot;, group)
  add_nodes(new_node_info)
 
  <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;got all the vms i needed!&quot;</span>)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="neptune_appscale_run_job-method" class="method-detail ">
        <a name="method-i-neptune_appscale_run_job"></a>

        
        <div class="method-heading">
          <span class="method-name">neptune_appscale_run_job</span><span
            class="method-args">(nodes, job_data, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="neptune_appscale_run_job-source">
<pre>
<span class="ruby-comment"># File ../Neptune/appscale_helper.rb, line 10</span>
def neptune_appscale_run_job(nodes, job_data, secret)
  if !valid_secret?(secret)
    return <span class="ruby-constant">BAD_SECRET_MSG</span>
  end

  <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;appscale - run&quot;</span>)

  required_params = %{@time_needed_for @add_component}
  if !has_all_required_params?(job_data, required_params)
    return <span class="ruby-constant">MISSING_PARAM</span>
  end

  <span class="ruby-constant">Thread</span>.new {
    wait_for_allotted_time(job_data)
  }

  return <span class="ruby-constant">STARTED_SUCCESSFULLY</span>
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="neptune_babel_run_job-method" class="method-detail ">
        <a name="method-i-neptune_babel_run_job"></a>

        
        <div class="method-heading">
          <span class="method-name">neptune_babel_run_job</span><span
            class="method-args">(nodes, job_data, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>This method is the spawning service for Babel - that is, it decides where 
tasks should be spawned. For now, we don’t intelligently decide where to
run tasks - we just run tasks where the user tells us to run them. Since
this method is accessible via SOAP, it has a time limit on its execution,
so as soon as we can, we spawn off a new thread to do the real work and
return.</p>
          

          
          <div class="method-source-code"
            id="neptune_babel_run_job-source">
<pre>
<span class="ruby-comment"># File ../Neptune/babel_helper.rb, line 160</span>
def neptune_babel_run_job(nodes, job_data, secret)
  return <span class="ruby-constant">BAD_SECRET_MSG</span> if !valid_secret?(secret)

  <span class="ruby-comment"># Add in a metadata hash so that any method can add in profiling info,</span>
  <span class="ruby-comment"># with an initial piece of data - when we received the task to run.</span>
  if !job_data[<span class="ruby-string">'@metadata_info'</span>]
    job_data[<span class="ruby-string">'@metadata_info'</span>] = {}
  end

  job_data[<span class="ruby-string">'@metadata_info'</span>][<span class="ruby-string">'received_task_at'</span>] = <span class="ruby-constant">Time</span>.now.to_i

  if job_data[<span class="ruby-string">'@run_local'</span>]
    <span class="ruby-constant">Thread</span>.new {
      <span class="ruby-constant">Djinn</span>.log_debug(&quot;running job with data #{job_data.inspect} locally&quot;)
      run_task(job_data)
    }
    return <span class="ruby-constant">RUN_LOCALLY</span>
  end

  engine = job_data[<span class="ruby-string">'@engine'</span>]
  if engine.include?(<span class="ruby-string">&quot;executor&quot;</span>)
    <span class="ruby-constant">Thread</span>.new {
      run_via_executor(engine, job_data)
    }
    return <span class="ruby-constant">RUN_VIA_EXECUTOR</span>
  else
    <span class="ruby-constant">Thread</span>.new {
      run_via_engine(engine, job_data)
    }
    return <span class="ruby-constant">RUN_VIA_REMOTE_ENGINE</span>
  end
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="neptune_cewssa_get_output-method" class="method-detail ">
        <a name="method-i-neptune_cewssa_get_output"></a>

        
        <div class="method-heading">
          <span class="method-name">neptune_cewssa_get_output</span><span
            class="method-args">(job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="neptune_cewssa_get_output-source">
<pre>
<span class="ruby-comment"># File ../Neptune/cewssa_helper.rb, line 95</span>
def neptune_cewssa_get_output(job_data)
  return <span class="ruby-constant">OUTPUT_HOME</span>
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="neptune_cewssa_run_job-method" class="method-detail ">
        <a name="method-i-neptune_cewssa_run_job"></a>

        
        <div class="method-heading">
          <span class="method-name">neptune_cewssa_run_job</span><span
            class="method-args">(nodes, job_data, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="neptune_cewssa_run_job-source">
<pre>
<span class="ruby-comment"># File ../Neptune/cewssa_helper.rb, line 14</span>
def neptune_cewssa_run_job(nodes, job_data, secret)
  <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;cewssa - pre-run&quot;</span>)
  return <span class="ruby-constant">BAD_SECRET_MSG</span> unless valid_secret?(secret)

  <span class="ruby-comment">#message = validate_environment(job_data, secret)</span>
  <span class="ruby-comment">#return message unless message == &quot;no error&quot;</span>

  <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;cewssa - run&quot;</span>)

  <span class="ruby-constant">Thread</span>.new {

    start_time = <span class="ruby-constant">Time</span>.now

    keyname = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">'keyname'</span>]
    nodes = <span class="ruby-constant">Djinn</span>.convert_location_array_to_class(nodes, keyname)
    sims = neptune_get_ssa_num_simulations(nodes, job_data)

    threads = []
    at = 0

    random_numbers = neptune_get_ssa_seed_vals(nodes.length)

    nodes.each_with_index { |node, i|
      threads &lt;&lt; <span class="ruby-constant">Thread</span>.new {
        ip = node.private_ip
        ssh_key = node.ssh_key
        start = at
        fin = at + sims[i]
        at = fin
        remote_del_command = &quot;rm -rf #{OUTPUT_HOME}/*&quot;
        <span class="ruby-constant">Djinn</span>.log_run(&quot;ssh -i #{ssh_key} -o StrictHostkeyChecking=no root@#{ip} '#{remote_del_command}'&quot;)

        iterations = fin - start <span class="ruby-comment"># don't need to add one here</span>
        seed = random_numbers[i]

        output_file = &quot;#{OUTPUT_HOME}/data#{i}.txt&quot;
        remote_run_command = &quot;#{OUR_CEWSSA_CODE} #{BIRTH_DEATH} #{iterations} #{seed} 1.454 0.686 &gt; #{output_file}&quot; 
        <span class="ruby-constant">Djinn</span>.log_run(&quot;ssh -i #{ssh_key} -o StrictHostkeyChecking=no root@#{ip} '#{remote_run_command}'&quot;)
      }
    }

    <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;cewssa - joining threads&quot;</span>)

    threads.each { |t| t.join }

    <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;cewssa - retrieving run data&quot;</span>)

    nodes.each { |node|
      ip = node.private_ip
      ssh_key = node.ssh_key
      remote_cp_command = &quot;scp -i #{ssh_key} -o StrictHostkeyChecking=no root@#{ip}:#{OUTPUT_HOME}/data* #{OUTPUT_HOME}/&quot;
      <span class="ruby-constant">Djinn</span>.log_run(remote_cp_command)
    }

    <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;cewssa - collecting stats&quot;</span>)

    collect_stats = &quot;#{MERGE_SCRIPT} #{OUTPUT_HOME}/data* &gt; #{OUTPUT_HOME}/finalresult.txt&quot;
    <span class="ruby-constant">Djinn</span>.log_run(collect_stats)

    fin_time = <span class="ruby-constant">Time</span>.now
    total = fin_time - start_time
    <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;cewssa - done!&quot;</span>)
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;TIMING: Took #{total} seconds.&quot;)

    shadow = get_shadow
    shadow_ip = shadow.private_ip
    shadow_key = shadow.ssh_key

    final_result = &quot;#{OUTPUT_HOME}/finalresult.txt&quot;
    <span class="ruby-constant">HelperFunctions</span>.scp_file(final_result, final_result, shadow_ip, shadow_key)

    neptune_write_job_output(job_data, final_result)

    remove_lock_file(job_data)
  }

  return <span class="ruby-string">&quot;OK&quot;</span>
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="neptune_cicero_run_job-method" class="method-detail ">
        <a name="method-i-neptune_cicero_run_job"></a>

        
        <div class="method-heading">
          <span class="method-name">neptune_cicero_run_job</span><span
            class="method-args">(nodes, job_data, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="neptune_cicero_run_job-source">
<pre>
<span class="ruby-comment"># File ../Neptune/cicero_helper.rb, line 18</span>
def neptune_cicero_run_job(nodes, job_data, secret)
  if !valid_secret?(secret)
    return <span class="ruby-constant">BAD_SECRET_MSG</span>
  end

  if nodes.class != <span class="ruby-constant">Array</span>
    return <span class="ruby-string">&quot;nodes must be an Array&quot;</span>
  end

  if job_data.class != <span class="ruby-constant">Hash</span>
    return <span class="ruby-string">&quot;job_data must be a Hash&quot;</span>
  end

  <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;cicero - run&quot;</span>)

  <span class="ruby-constant">Thread</span>.new {
    run_via_cicero(nodes, job_data, secret)
  }

  return <span class="ruby-string">&quot;OK&quot;</span>
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="neptune_compile_code-method" class="method-detail ">
        <a name="method-i-neptune_compile_code"></a>

        
        <div class="method-heading">
          <span class="method-name">neptune_compile_code</span><span
            class="method-args">(job_data, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="neptune_compile_code-source">
<pre>
<span class="ruby-comment"># File ../Neptune/neptune.rb, line 232</span>
def neptune_compile_code(job_data, secret)
  message = validate_environment(job_data, secret)
  return message unless message == <span class="ruby-string">&quot;no error&quot;</span>

  <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;compiling code&quot;</span>)

  main_file = job_data[<span class="ruby-string">&quot;@main&quot;</span>]
  input_loc = job_data[<span class="ruby-string">&quot;@code&quot;</span>]
  target = job_data[<span class="ruby-string">&quot;@target&quot;</span>]

  compiled_dir = &quot;/tmp/compiled-#{HelperFunctions.get_random_alphanumeric}&quot;

  <span class="ruby-constant">Thread</span>.new {
    makefile = input_loc + <span class="ruby-string">&quot;/Makefile&quot;</span>
    makefile2 = input_loc + <span class="ruby-string">&quot;/makefile&quot;</span>
    if !(<span class="ruby-constant">File</span>.exists?(makefile) or <span class="ruby-constant">File</span>.exists?(makefile2))
      <span class="ruby-constant">HelperFunctions</span>.generate_makefile(main_file, input_loc)
    end

    compile_cmd = &quot;cd #{input_loc}; make #{target} 2&gt;compile_err 1&gt;compile_out&quot;

    <span class="ruby-constant">Djinn</span>.log_debug(&quot;compiling code by running [#{compile_cmd}]&quot;)

    result = `#{compile_cmd}`
    <span class="ruby-constant">Djinn</span>.log_run(&quot;cp -r #{input_loc} #{compiled_dir}&quot;)

  }

  return compiled_dir  
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="neptune_dfsp_get_output-method" class="method-detail ">
        <a name="method-i-neptune_dfsp_get_output"></a>

        
        <div class="method-heading">
          <span class="method-name">neptune_dfsp_get_output</span><span
            class="method-args">(job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="neptune_dfsp_get_output-source">
<pre>
<span class="ruby-comment"># File ../Neptune/dfsp_helper.rb, line 84</span>
def neptune_dfsp_get_output(job_data)
  return <span class="ruby-constant">DFSP_HOME</span>
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="neptune_dfsp_run_job-method" class="method-detail ">
        <a name="method-i-neptune_dfsp_run_job"></a>

        
        <div class="method-heading">
          <span class="method-name">neptune_dfsp_run_job</span><span
            class="method-args">(nodes, job_data, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="neptune_dfsp_run_job-source">
<pre>
<span class="ruby-comment"># File ../Neptune/dfsp_helper.rb, line 11</span>
def neptune_dfsp_run_job(nodes, job_data, secret)
  return <span class="ruby-constant">BAD_SECRET_MSG</span> unless valid_secret?(secret)
  <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;dfsp - run&quot;</span>)

  <span class="ruby-constant">Thread</span>.new {
    start_time = <span class="ruby-constant">Time</span>.now

    keyname = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">'keyname'</span>]
    nodes = <span class="ruby-constant">Djinn</span>.convert_location_array_to_class(nodes, keyname)
    sims = neptune_get_ssa_num_simulations(nodes, job_data)

    threads = []
    at = 0 
    nodes.each_with_index { |node, i|
      threads &lt;&lt; <span class="ruby-constant">Thread</span>.new {
        ip = node.private_ip
        ssh_key = node.ssh_key
        start = at
        fin = at + sims[i]
        at = fin
        remote_del_command = &quot;rm -rf #{DFSP_HOME}/data*&quot;
        remote_run_command = &quot;cd #{DFSP_HOME}; ./multi_run.pl #{start} #{fin}&quot;
        <span class="ruby-constant">Djinn</span>.log_run(&quot;ssh -i #{ssh_key} -o StrictHostkeyChecking=no root@#{ip} '#{remote_del_command}'&quot;)
        <span class="ruby-constant">Djinn</span>.log_run(&quot;ssh -i #{ssh_key} -o StrictHostkeyChecking=no root@#{ip} '#{remote_run_command}'&quot;)
      }
    }

    <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;dfsp - joining threads&quot;</span>)

    threads.each { |t| t.join }

    <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;dfsp - retrieving run data&quot;</span>)

    nodes.each { |node|
      ip = node.private_ip
      ssh_key = node.ssh_key
      remote_cp_command = &quot;scp -i #{ssh_key} -o StrictHostkeyChecking=no root@#{ip}:#{DFSP_HOME}/data* #{DFSP_HOME}/&quot;
      <span class="ruby-constant">Djinn</span>.log_run(remote_cp_command)
    }  

    <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;dfsp - collecting stats&quot;</span>)

    collect_stats = &quot;cd #{DFSP_HOME}/; ./collect_stats.pl #{at} &gt;out 2&gt;err&quot;
    <span class="ruby-constant">Djinn</span>.log_run(collect_stats)

    fin_time = <span class="ruby-constant">Time</span>.now
    total = fin_time - start_time
    <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;dfsp - done!&quot;</span>)
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;TIMING: Took #{total} seconds.&quot;)

    shadow = get_shadow
    shadow_ip = shadow.private_ip
    shadow_key = shadow.ssh_key

    out = &quot;#{DFSP_HOME}/out&quot;
    <span class="ruby-constant">HelperFunctions</span>.scp_file(out, out, shadow_ip, shadow_key)

    err = &quot;#{DFSP_HOME}/err&quot;
    <span class="ruby-constant">HelperFunctions</span>.scp_file(err, err, shadow_ip, shadow_key)

    data = &quot;#{DFSP_HOME}/data*&quot;
    <span class="ruby-constant">HelperFunctions</span>.scp_file(data, <span class="ruby-constant">DFSP_HOME</span>, shadow_ip, shadow_key)

    neptune_write_job_output(job_data, out)

    remove_lock_file(job_data)
  }

  return <span class="ruby-string">&quot;OK&quot;</span>
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="neptune_does_file_exist-method" class="method-detail ">
        <a name="method-i-neptune_does_file_exist"></a>

        
        <div class="method-heading">
          <span class="method-name">neptune_does_file_exist</span><span
            class="method-args">(file, job_data, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="neptune_does_file_exist-source">
<pre>
<span class="ruby-comment"># File ../Neptune/neptune.rb, line 156</span>
def neptune_does_file_exist(file, job_data, secret)
  datastore = <span class="ruby-constant">DatastoreFactory</span>.get_datastore(job_data[<span class="ruby-string">'@storage'</span>], job_data)
  return datastore.does_file_exist?(file)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="neptune_erlang_run_job-method" class="method-detail ">
        <a name="method-i-neptune_erlang_run_job"></a>

        
        <div class="method-heading">
          <span class="method-name">neptune_erlang_run_job</span><span
            class="method-args">(nodes, job_data, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="neptune_erlang_run_job-source">
<pre>
<span class="ruby-comment"># File ../Neptune/erlang_helper.rb, line 18</span>
def neptune_erlang_run_job(nodes, job_data, secret)
  return <span class="ruby-constant">BAD_SECRET_MSG</span> unless valid_secret?(secret)
  <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;erlang - run&quot;</span>)

  <span class="ruby-constant">Thread</span>.new {
    keyname = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">'keyname'</span>]
    nodes = <span class="ruby-constant">Djinn</span>.convert_location_array_to_class(nodes, keyname)

    <span class="ruby-constant">ENV</span>[<span class="ruby-string">'HOME'</span>] = <span class="ruby-string">&quot;/root&quot;</span>

    code = job_data[<span class="ruby-string">'@code'</span>].split(<span class="ruby-regexp">/\//</span>)[-1]

    unless my_node.is_shadow?
      <span class="ruby-constant">Djinn</span>.log_run(&quot;rm -rfv /tmp/#{code}&quot;)
    end
    sleep(1)

    remote = job_data[<span class="ruby-string">'@code'</span>]
    storage = job_data[<span class="ruby-string">'@storage'</span>]

    datastore = <span class="ruby-constant">DatastoreFactory</span>.get_datastore(storage, job_data)
    datastore.get_output_and_save_to_fs(remote, &quot;/tmp/#{code}&quot;)

    module_name = code.split(<span class="ruby-regexp">/\./</span>)[0]
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;got code #{code}, trying to run module #{module_name}&quot;)
    <span class="ruby-constant">Djinn</span>.log_run(&quot;chmod +x #{code}&quot;)
    <span class="ruby-constant">Djinn</span>.log_run(&quot;cd /tmp; erl -noshell -run #{module_name} main &gt; #{ERLANG_OUTPUT}&quot;)

    datastore.write_remote_file_from_local_file(job_data[<span class="ruby-string">'@output'</span>], <span class="ruby-constant">ERLANG_OUTPUT</span>)
    remove_lock_file(job_data)
    <span class="ruby-constant">Djinn</span>.log_run(&quot;rm -rfv /tmp/#{code}&quot;)
  }

  return <span class="ruby-string">&quot;OK&quot;</span>
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="neptune_find_open_nodes-method" class="method-detail ">
        <a name="method-i-neptune_find_open_nodes"></a>

        
        <div class="method-heading">
          <span class="method-name">neptune_find_open_nodes</span><span
            class="method-args">(cloud, nodes_needed, job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="neptune_find_open_nodes-source">
<pre>
<span class="ruby-comment"># File ../Neptune/neptune.rb, line 567</span>
def neptune_find_open_nodes(cloud, nodes_needed, job_data)
  <span class="ruby-comment"># TODO: assigning nodes -&gt; nodes_to_use should be atomic?</span>
  <span class="ruby-comment"># or should going through this list be atomic?</span>

  cloud_num = cloud.scan(<span class="ruby-regexp">/cloud(.*)/</span>).flatten.to_s

  nodes_to_use = []
  <span class="ruby-ivar">@nodes</span>.each { |node|
    break if nodes_to_use.length == nodes_needed
    if node.is_open? and node.cloud == cloud
      nodes_to_use &lt;&lt; node
    end
  }

  <span class="ruby-ivar">@neptune_nodes</span> = nodes_to_use

  nodes_available = nodes_to_use.length
  new_nodes_needed = nodes_needed - nodes_available
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;need #{nodes_needed} total, currently have #{nodes_available} to spare&quot;)

  if is_cloud?
    if new_nodes_needed &gt; 0
      <span class="ruby-constant">Djinn</span>.log_debug(&quot;spawning up #{new_nodes_needed} for neptune job in cloud 1&quot;)
      neptune_acquire_nodes_for_cloud(cloud_num, new_nodes_needed, job_data)
    end
  else
    if new_nodes_needed &gt; 0
      <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;non-cloud deployment and the neptune user has asked for too many nodes&quot;</span>)
      <span class="ruby-comment"># TODO: find a way to reject the job here</span>
    end
  end

  nodes_to_use = []
  <span class="ruby-ivar">@neptune_nodes</span>.each { |node|
    break if nodes_to_use.length == nodes_needed
    if node.is_open? and node.cloud == cloud
      <span class="ruby-constant">Djinn</span>.log_debug(&quot;will use node [#{node}] for computation&quot;)
      nodes_to_use &lt;&lt; node
    end
  }

  return nodes_to_use
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="neptune_get_acl-method" class="method-detail ">
        <a name="method-i-neptune_get_acl"></a>

        
        <div class="method-heading">
          <span class="method-name">neptune_get_acl</span><span
            class="method-args">(job_data, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="neptune_get_acl-source">
<pre>
<span class="ruby-comment"># File ../Neptune/neptune.rb, line 184</span>
def neptune_get_acl(job_data, secret)
  message = validate_environment(job_data, secret)
  return message unless message == <span class="ruby-string">&quot;no error&quot;</span>

  <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;requesting acl&quot;</span>)

  type = job_data[<span class="ruby-string">&quot;@type&quot;</span>]

  output_location = job_data[<span class="ruby-string">&quot;@output&quot;</span>]
  if output_location.nil?
    return <span class="ruby-string">&quot;error: output not specified&quot;</span>
  else
    datastore = <span class="ruby-constant">DatastoreFactory</span>.get_datastore(job_data[<span class="ruby-string">'@storage'</span>], job_data)
    if datastore.does_file_exist?(output_location)
      return datastore.get_acl(output_location)
    else
      return <span class="ruby-string">&quot;error: output does not exist&quot;</span>
    end
  end
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="neptune_get_output-method" class="method-detail ">
        <a name="method-i-neptune_get_output"></a>

        
        <div class="method-heading">
          <span class="method-name">neptune_get_output</span><span
            class="method-args">(job_data, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="neptune_get_output-source">
<pre>
<span class="ruby-comment"># File ../Neptune/neptune.rb, line 161</span>
def neptune_get_output(job_data, secret)
  message = validate_environment(job_data, secret)
  return message unless message == <span class="ruby-string">&quot;no error&quot;</span>

  <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;requesting output&quot;</span>)

  type = job_data[<span class="ruby-string">&quot;@type&quot;</span>]

  output_location = job_data[<span class="ruby-string">&quot;@output&quot;</span>]
  if output_location.nil?
    return <span class="ruby-string">&quot;error: output not specified&quot;</span>
  else
    datastore = <span class="ruby-constant">DatastoreFactory</span>.get_datastore(job_data[<span class="ruby-string">'@storage'</span>], job_data)
    if datastore.does_file_exist?(output_location)
      <span class="ruby-comment"># TODO: maybe write to file or have</span>
      <span class="ruby-comment"># special flag for this?</span>
      return datastore.get_output_and_return_contents(output_location)
    else
      return <span class="ruby-string">&quot;error: output does not exist&quot;</span>
    end
  end
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="neptune_get_ssa_num_simulations-method" class="method-detail ">
        <a name="method-i-neptune_get_ssa_num_simulations"></a>

        
        <div class="method-heading">
          <span class="method-name">neptune_get_ssa_num_simulations</span><span
            class="method-args">(nodes, job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="neptune_get_ssa_num_simulations-source">
<pre>
<span class="ruby-comment"># File ../Neptune/ssa_helper.rb, line 228</span>
def neptune_get_ssa_num_simulations(nodes, job_data)
  num_nodes = nodes.length
  num_sims = job_data[<span class="ruby-string">&quot;@trajectories&quot;</span>] || job_data[<span class="ruby-string">&quot;@simulations&quot;</span>]
  sims_per_node = num_sims / num_nodes

  <span class="ruby-constant">Djinn</span>.log_debug(&quot;num nodes = #{num_nodes}&quot;)
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;num_sims = #{num_sims}&quot;)
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;sims_per_node = #{sims_per_node}&quot;)

  <span class="ruby-comment"># set up how many simulations each node</span>
  <span class="ruby-comment"># should run by divying it up equally</span>
  <span class="ruby-comment"># any remainder can be assigned to an</span>
  <span class="ruby-comment"># arbitrary node</span>

  sims = [sims_per_node] * num_nodes
  remainder = num_sims % num_nodes
  sims[-1] += remainder

  <span class="ruby-constant">Djinn</span>.log_debug(&quot;sims = #{sims.join(', ')}&quot;)
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;remainder = #{remainder}&quot;)

  return sims
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="neptune_get_ssa_seed_vals-method" class="method-detail ">
        <a name="method-i-neptune_get_ssa_seed_vals"></a>

        
        <div class="method-heading">
          <span class="method-name">neptune_get_ssa_seed_vals</span><span
            class="method-args">(num_vals)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="neptune_get_ssa_seed_vals-source">
<pre>
<span class="ruby-comment"># File ../Neptune/ssa_helper.rb, line 215</span>
def neptune_get_ssa_seed_vals(num_vals)
  random_numbers = []
  loop {
    possible_rand = rand(32000)
    unless random_numbers.include?(possible_rand)
      random_numbers &lt;&lt; possible_rand
    end
    break if num_vals == random_numbers.length
  }

  return random_numbers
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="neptune_get_supported_babel_engines-method" class="method-detail ">
        <a name="method-i-neptune_get_supported_babel_engines"></a>

        
        <div class="method-heading">
          <span class="method-name">neptune_get_supported_babel_engines</span><span
            class="method-args">(job_data, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Tasks can execute over a number of different engines (a queue and an
executor). From the credentials the user has given us (job_data), determine
which engines can be used.</p>
          

          
          <div class="method-source-code"
            id="neptune_get_supported_babel_engines-source">
<pre>
<span class="ruby-comment"># File ../Neptune/babel_helper.rb, line 116</span>
def neptune_get_supported_babel_engines(job_data, secret)
  return <span class="ruby-constant">BAD_SECRET_MSG</span> if !valid_secret?(secret)

  <span class="ruby-constant">Djinn</span>.log_debug(&quot;checking supported engines for job data #{job_data.inspect}&quot;)

  <span class="ruby-comment"># all jobs can use the internal engines</span>
  engines = <span class="ruby-constant">INTERNAL_ENGINES</span>

  <span class="ruby-comment"># but not necessarily the others, so check them one by one</span>
  engines &lt;&lt; get_engines_for_creds(job_data, <span class="ruby-constant">AMAZON_CREDENTIALS</span>, <span class="ruby-constant">AMAZON_ENGINES</span>)
  engines &lt;&lt; get_engines_for_creds(job_data, <span class="ruby-constant">AZURE_CREDENTIALS</span>, <span class="ruby-constant">AZURE_ENGINES</span>)
  engines &lt;&lt; get_engines_for_creds(job_data, <span class="ruby-constant">GOOGLE_CREDENTIALS</span>, <span class="ruby-constant">GOOGLE_ENGINES</span>)
  engines.flatten!  <span class="ruby-comment"># since we're appending arrays to arrays but want it 1D</span>

  <span class="ruby-constant">Djinn</span>.log_debug(&quot;supported engines for job data #{job_data.inspect} are [#{engines.join(', ')}]&quot;)

  return engines
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="neptune_go_run_job-method" class="method-detail ">
        <a name="method-i-neptune_go_run_job"></a>

        
        <div class="method-heading">
          <span class="method-name">neptune_go_run_job</span><span
            class="method-args">(nodes, job_data, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="neptune_go_run_job-source">
<pre>
<span class="ruby-comment"># File ../Neptune/go_helper.rb, line 16</span>
def neptune_go_run_job(nodes, job_data, secret)
  return <span class="ruby-constant">BAD_SECRET_MSG</span> unless valid_secret?(secret)
  <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;go - run&quot;</span>)

  <span class="ruby-constant">Thread</span>.new {
    keyname = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">'keyname'</span>]
    nodes = <span class="ruby-constant">Djinn</span>.convert_location_array_to_class(nodes, keyname)

    <span class="ruby-comment">#ENV['HOME'] = &quot;/root&quot;</span>
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;job data is #{job_data.inspect}&quot;)

    code = job_data[<span class="ruby-string">'@code'</span>].split(<span class="ruby-regexp">/\//</span>)[-1]

    code_dir = &quot;/tmp/go-#{rand()}/&quot;
    code_loc = &quot;#{code_dir}/#{code}&quot;
    output_loc = &quot;#{code_dir}/output.txt&quot;
    <span class="ruby-constant">FileUtils</span>.mkdir_p(code_dir)

    remote = job_data[<span class="ruby-string">'@code'</span>]
    storage = job_data[<span class="ruby-string">'@storage'</span>]

    datastore = <span class="ruby-constant">DatastoreFactory</span>.get_datastore(storage, job_data)
    datastore.get_output_and_save_to_fs(remote, code_loc)

    <span class="ruby-constant">Djinn</span>.log_debug(&quot;got code #{code}, saved at #{code_loc}&quot;)
    <span class="ruby-constant">Djinn</span>.log_run(&quot;chmod +x #{code_loc}&quot;)
    <span class="ruby-constant">Djinn</span>.log_run(&quot;cd #{code_dir}; ./#{code} &gt; #{output_loc}&quot;)

    datastore.write_remote_file_from_local_file(job_data[<span class="ruby-string">'@output'</span>], output_loc)
    remove_lock_file(job_data)
  }

  return <span class="ruby-string">&quot;OK&quot;</span>
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="neptune_is_job_running-method" class="method-detail ">
        <a name="method-i-neptune_is_job_running"></a>

        
        <div class="method-heading">
          <span class="method-name">neptune_is_job_running</span><span
            class="method-args">(job_data, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="neptune_is_job_running-source">
<pre>
<span class="ruby-comment"># File ../Neptune/neptune.rb, line 98</span>
def neptune_is_job_running(job_data, secret)
  return <span class="ruby-constant">BAD_SECRET_MSG</span> unless valid_secret?(secret)
  return lock_file_exists?(job_data)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="neptune_mapreduce_get_output-method" class="method-detail ">
        <a name="method-i-neptune_mapreduce_get_output"></a>

        
        <div class="method-heading">
          <span class="method-name">neptune_mapreduce_get_output</span><span
            class="method-args">(job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="neptune_mapreduce_get_output-source">
<pre>
<span class="ruby-comment"># File ../Neptune/mapreduce_helper.rb, line 134</span>
def neptune_mapreduce_get_output(job_data)
  output = job_data[<span class="ruby-string">&quot;@output&quot;</span>]
  output_location = &quot;/tmp/#{output}&quot;

  `rm -rf #{output_location}`
  run_on_db_master(&quot;rm -rf #{output_location}&quot;, <span class="ruby-constant">NO_OUTPUT</span>) 
  run_on_db_master(&quot;#{HADOOP} fs -get #{output} #{output_location}&quot;, <span class="ruby-constant">NO_OUTPUT</span>)
  unless my_node.is_db_master?
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;hey by the way output is [#{output}]&quot;)

    db_master = get_db_master
    ip = db_master.public_ip
    ssh_key = db_master.ssh_key

    <span class="ruby-constant">Djinn</span>.log_run(&quot;scp -i #{ssh_key} -o StrictHostkeyChecking=no -r #{ip}:#{output_location} #{output_location}&quot;)
  end

  return output_location
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="neptune_mapreduce_run_job-method" class="method-detail ">
        <a name="method-i-neptune_mapreduce_run_job"></a>

        
        <div class="method-heading">
          <span class="method-name">neptune_mapreduce_run_job</span><span
            class="method-args">(nodes, job_data, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="neptune_mapreduce_run_job-source">
<pre>
<span class="ruby-comment"># File ../Neptune/mapreduce_helper.rb, line 28</span>
def neptune_mapreduce_run_job(nodes, job_data, secret)
  return <span class="ruby-constant">BAD_SECRET_MSG</span> unless valid_secret?(secret)
  <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;mapreduce - run&quot;</span>)

  <span class="ruby-constant">Thread</span>.new {
    keyname = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">'keyname'</span>]
    nodes = <span class="ruby-constant">Djinn</span>.convert_location_array_to_class(nodes, keyname)

    storage = job_data[<span class="ruby-string">&quot;@storage&quot;</span>]
    datastore = <span class="ruby-constant">DatastoreFactory</span>.get_datastore(storage, job_data)

    mapreducejar = job_data[<span class="ruby-string">&quot;@mapreducejar&quot;</span>]
    main = job_data[<span class="ruby-string">&quot;@main&quot;</span>]

    map = job_data[<span class="ruby-string">&quot;@map&quot;</span>]
    reduce = job_data[<span class="ruby-string">&quot;@reduce&quot;</span>]

    input = job_data[<span class="ruby-string">&quot;@input&quot;</span>]
    output = job_data[<span class="ruby-string">&quot;@output&quot;</span>]

    <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;MR: Copying mapper and reducer to all boxes&quot;</span>)
    <span class="ruby-comment"># TODO: get files from shadow first if in cloud</span>

    if mapreducejar
      <span class="ruby-constant">Djinn</span>.log_debug(&quot;need to get mr jar located at #{mapreducejar}&quot;)
      mr_file = mapreducejar.split(<span class="ruby-string">'/'</span>)[-1]
      my_mrjar = &quot;/tmp/#{mr_file}&quot;
      datastore.get_output_and_save_to_fs(mapreducejar, my_mrjar)

      nodes.each { |node|
        <span class="ruby-constant">HelperFunctions</span>.scp_file(my_mrjar, my_mrjar, node.private_ip, node.ssh_key)
      }

      db_master = get_db_master
      ip = db_master.private_ip
      ssh_key = db_master.ssh_key
      <span class="ruby-constant">HelperFunctions</span>.scp_file(my_mrjar, my_mrjar, ip, ssh_key)

      run_mr_command = &quot;#{HADOOP} jar #{my_mrjar} #{main} #{input} #{output}&quot;
    else
      <span class="ruby-constant">Djinn</span>.log_debug(&quot;need to get map code located at #{map}, and reduce &quot; +
        &quot;code located at #{reduce}&quot;)

      map_file = map.split(<span class="ruby-string">'/'</span>)[-1]
      red_file = reduce.split(<span class="ruby-string">'/'</span>)[-1]

      my_map = &quot;/tmp/#{map_file}&quot;
      my_red = &quot;/tmp/#{red_file}&quot;

      datastore.get_output_and_save_to_fs(map, my_map)
      datastore.get_output_and_save_to_fs(reduce, my_red)

      <span class="ruby-comment"># since the db master is the initiator of the mapreduce job, it needs</span>
      <span class="ruby-comment"># to have both the mapper and reducer files handy</span>

      db_master = get_db_master
      ip = db_master.private_ip
      ssh_key = db_master.ssh_key
      <span class="ruby-constant">HelperFunctions</span>.scp_file(my_map, my_map, ip, ssh_key)
      <span class="ruby-constant">HelperFunctions</span>.scp_file(my_red, my_red, ip, ssh_key)

      nodes.each { |node|
        <span class="ruby-constant">HelperFunctions</span>.scp_file(my_map, my_map, node.private_ip, node.ssh_key)
        <span class="ruby-constant">HelperFunctions</span>.scp_file(my_red, my_red, node.private_ip, node.ssh_key)
      }

      map_cmd = <span class="ruby-string">&quot;\&quot;&quot;</span> + get_language(my_map) + <span class="ruby-string">&quot; &quot;</span> + my_map + <span class="ruby-string">&quot;\&quot;&quot;</span>
      reduce_cmd = <span class="ruby-string">&quot;\&quot;&quot;</span> + get_language(my_red) + <span class="ruby-string">&quot; &quot;</span> + my_red + <span class="ruby-string">&quot;\&quot;&quot;</span>

      run_mr_command = &quot;#{HADOOP} jar #{STREAMING} -input #{input} &quot; +
        &quot;-output #{output} -mapper #{map_cmd} -reducer #{reduce_cmd}&quot;
    end

    <span class="ruby-constant">Djinn</span>.log_debug(&quot;waiting for input file #{input} to exist in HDFS&quot;)
    wait_for_hdfs_file(input)

    <span class="ruby-comment"># run mr job</span>
    start = <span class="ruby-constant">Time</span>.now

    <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;MR: Running job&quot;</span>)
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;MR: Command is #{run_mr_command}&quot;)
    <span class="ruby-constant">Djinn</span>.log_run(run_mr_command)

    wait_for_hdfs_file(output)
    <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;MR: Done running job!&quot;</span>)

    fin = <span class="ruby-constant">Time</span>.now
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;TIMING: Total time is #{fin - start} seconds&quot;)

    <span class="ruby-comment"># TODO: check if no part-* files exist - if so, there's an error</span>
    <span class="ruby-comment"># that we should funnel to the user somehow</span>

    output_cmd = &quot;#{HADOOP} fs -cat #{output}/part-*&quot;
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;MR: Retrieving job output with command #{output_cmd}&quot;)
    output_str = `#{output_cmd}`

    neptune_write_job_output_str(job_data, output_str)

    remove_lock_file(job_data)
  }

  return <span class="ruby-string">&quot;OK&quot;</span>
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="neptune_mpi_get_output-method" class="method-detail ">
        <a name="method-i-neptune_mpi_get_output"></a>

        
        <div class="method-heading">
          <span class="method-name">neptune_mpi_get_output</span><span
            class="method-args">(job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="neptune_mpi_get_output-source">
<pre>
<span class="ruby-comment"># File ../Neptune/mpi_helper.rb, line 122</span>
def neptune_mpi_get_output(job_data)
  return <span class="ruby-constant">MPI_OUTPUT</span>
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="neptune_mpi_run_job-method" class="method-detail ">
        <a name="method-i-neptune_mpi_run_job"></a>

        
        <div class="method-heading">
          <span class="method-name">neptune_mpi_run_job</span><span
            class="method-args">(nodes, job_data, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="neptune_mpi_run_job-source">
<pre>
<span class="ruby-comment"># File ../Neptune/mpi_helper.rb, line 18</span>
def neptune_mpi_run_job(nodes, job_data, secret)
  return <span class="ruby-constant">BAD_SECRET_MSG</span> unless valid_secret?(secret)
  <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;mpi - run&quot;</span>)

  <span class="ruby-constant">Thread</span>.new {
    job_data[<span class="ruby-string">'@metadata_info'</span>] = {<span class="ruby-string">'received_job_at'</span> =&gt; <span class="ruby-constant">Time</span>.now.to_i}

    keyname = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">'keyname'</span>]
    nodes = <span class="ruby-constant">Djinn</span>.convert_location_array_to_class(nodes, keyname)

    <span class="ruby-constant">ENV</span>[<span class="ruby-string">'LD_LIBRARY_PATH'</span>] = <span class="ruby-string">&quot;/usr/lib&quot;</span>
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;library path = #{ENV['LD_LIBRARY_PATH']}&quot;)

    start_nfs(nodes)

    sleep(5) <span class="ruby-comment"># CGB</span>

    shadow = get_shadow
    shadow_ip = shadow.private_ip
    shadow_key = shadow.ssh_key

    remote = job_data[<span class="ruby-string">'@code'</span>]
    splitted_code = remote.split(<span class="ruby-string">'/'</span>)
    remote_dir = splitted_code[0..splitted_code.length-2].join(<span class="ruby-string">'/'</span>)
    filename_to_exec = splitted_code[2..splitted_code.length-1].join(<span class="ruby-string">'/'</span>)
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;remote dir is [#{remote_dir}], filename_to_exec is #{filename_to_exec}&quot;)

    storage = job_data[<span class="ruby-string">'@storage'</span>]

    unless my_node.is_shadow?
      <span class="ruby-constant">Djinn</span>.log_run(&quot;rm -fv /tmp/#{filename_to_exec}&quot;)
    end

    working_dir = &quot;/mirrornfs/#{HelperFunctions.get_random_alphanumeric()}&quot;
    <span class="ruby-constant">FileUtils</span>.mkdir_p(working_dir)
    <span class="ruby-constant">Djinn</span>.copy_code_and_inputs_to_dir(job_data, working_dir)

    start_mpd(nodes)
    sleep(5)

    if job_data[<span class="ruby-string">&quot;@procs_to_use&quot;</span>]
      num_of_procs = job_data[<span class="ruby-string">&quot;@procs_to_use&quot;</span>]
    else
      num_of_procs = nodes.length
    end

    <span class="ruby-comment"># Some job types (e.g., kdt) need to specify something a program to use</span>
    <span class="ruby-comment"># to run the user's code (e.g., Python), so let them do so via the</span>
    <span class="ruby-comment"># executable parameter.</span>
    if job_data[<span class="ruby-string">&quot;@executable&quot;</span>]
      executable = job_data[<span class="ruby-string">&quot;@executable&quot;</span>]
    else
      executable = <span class="ruby-string">&quot;&quot;</span>
    end

    <span class="ruby-comment"># If the user specifies an argv to pass to the code to exec, be sure to</span>
    <span class="ruby-comment"># capture it and pass it along</span>
    if job_data[<span class="ruby-string">&quot;@argv&quot;</span>]
      argv = job_data[<span class="ruby-string">&quot;@argv&quot;</span>]
      <span class="ruby-comment"># TODO(cgb): filter out colons and other things that malicious users could</span>
      <span class="ruby-comment"># use to hijack the system</span>
    else
      argv = <span class="ruby-string">&quot;&quot;</span>
    end

    output_file = &quot;/tmp/mpi-output-#{rand()}&quot;
    error_file = &quot;/tmp/mpi-error-#{rand()}&quot;

    full_path_to_file = &quot;#{working_dir}/#{filename_to_exec}&quot;

    start_time = <span class="ruby-constant">Time</span>.now
    <span class="ruby-constant">Djinn</span>.log_run(&quot;mpiexec -env X10_NTHREADS 1 -n #{num_of_procs} &quot; +
      &quot;#{executable} #{full_path_to_file} #{argv} 1&gt;#{output_file} 2&gt;#{error_file}&quot;)
    end_time = <span class="ruby-constant">Time</span>.now
 
    total = end_time - start_time
    <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;MPI: Done running job!&quot;</span>)
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;TIMING: Took #{total} seconds&quot;)

    job_data[<span class="ruby-string">'@metadata_info'</span>][<span class="ruby-string">'start_time'</span>] = start_time.to_i
    job_data[<span class="ruby-string">'@metadata_info'</span>][<span class="ruby-string">'end_time'</span>] = end_time.to_i
    job_data[<span class="ruby-string">'@metadata_info'</span>][<span class="ruby-string">'total_execution_time'</span>] = total

    stop_mpd()

    stop_nfs(nodes)

    <span class="ruby-constant">Djinn</span>.write_babel_outputs(output_file, error_file, job_data)

    <span class="ruby-comment"># clean up after ourselves - remove the user's code and any outputs</span>
    <span class="ruby-comment"># it may have produced</span>
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;Removing working dir #{working_dir}&quot;)
    <span class="ruby-constant">FileUtils</span>.rm_rf(working_dir)
    <span class="ruby-constant">FileUtils</span>.rm_rf(output_file)
    <span class="ruby-constant">FileUtils</span>.rm_rf(error_file)

    remove_lock_file(job_data)
  }

  return <span class="ruby-string">&quot;OK&quot;</span>
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="neptune_put_input-method" class="method-detail ">
        <a name="method-i-neptune_put_input"></a>

        
        <div class="method-heading">
          <span class="method-name">neptune_put_input</span><span
            class="method-args">(job_data, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="neptune_put_input-source">
<pre>
<span class="ruby-comment"># File ../Neptune/neptune.rb, line 103</span>
def neptune_put_input(job_data, secret)
  message = validate_environment(job_data, secret)
  return message unless message == <span class="ruby-string">&quot;no error&quot;</span>

  <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;requesting input&quot;</span>)

  type = job_data[<span class="ruby-string">&quot;@type&quot;</span>]

  [<span class="ruby-string">&quot;type&quot;</span>, <span class="ruby-string">&quot;storage&quot;</span>, <span class="ruby-string">&quot;local&quot;</span>, <span class="ruby-string">&quot;remote&quot;</span>].each { |item|
    if job_data[&quot;@#{item}&quot;].nil?
      return &quot;error: #{item} not specified&quot;
    end
  }

  input_location = job_data[<span class="ruby-string">&quot;@remote&quot;</span>]

  local_fs_location = <span class="ruby-constant">File</span>.expand_path(job_data[<span class="ruby-string">&quot;@local&quot;</span>])

  loop {
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;waiting for file #{local_fs_location} to exist&quot;)
    break if <span class="ruby-constant">File</span>.exists?(local_fs_location)
    sleep(1)
  }

  msg = &quot;storing local file #{local_fs_location} with size &quot; + 
    &quot;#{File.size(local_fs_location)}, storing to #{input_location}&quot;

  <span class="ruby-constant">Djinn</span>.log_debug(msg)

  datastore = <span class="ruby-constant">DatastoreFactory</span>.get_datastore(job_data[<span class="ruby-string">'@storage'</span>], job_data)
  ret_val = datastore.write_remote_file_from_local_file(input_location, local_fs_location)

  <span class="ruby-comment"># also, if we're running on hbase or hypertable, put a copy of the data</span>
  <span class="ruby-comment"># into HDFS for later processing via mapreduce</span>

  table = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;table&quot;</span>]

  if [<span class="ruby-string">&quot;hbase&quot;</span>, <span class="ruby-string">&quot;hypertable&quot;</span>].include?(table)
    unless my_node.is_db_master?
      db_master = get_db_master
      ip = db_master.private_ip
      ssh_key = db_master.ssh_key
      <span class="ruby-constant">HelperFunctions</span>.scp_file(local_fs_location, local_fs_location, ip, ssh_key)
    end

    cmd = &quot;#{HADOOP} fs -put #{local_fs_location} #{input_location}&quot;
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;putting input in hadoop with command [#{cmd}]&quot;)
    run_on_db_master(cmd)
  end

  return ret_val
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="neptune_r_run_job-method" class="method-detail ">
        <a name="method-i-neptune_r_run_job"></a>

        
        <div class="method-heading">
          <span class="method-name">neptune_r_run_job</span><span
            class="method-args">(nodes, job_data, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="neptune_r_run_job-source">
<pre>
<span class="ruby-comment"># File ../Neptune/r_helper.rb, line 15</span>
def neptune_r_run_job(nodes, job_data, secret)
  return <span class="ruby-constant">BAD_SECRET_MSG</span> unless valid_secret?(secret)
  <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;r - run&quot;</span>)

  <span class="ruby-constant">Thread</span>.new {
    keyname = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">'keyname'</span>]
    nodes = <span class="ruby-constant">Djinn</span>.convert_location_array_to_class(nodes, keyname)

    <span class="ruby-constant">Djinn</span>.log_debug(&quot;job data is #{job_data.inspect}&quot;)

    code = job_data[<span class="ruby-string">'@code'</span>].split(<span class="ruby-regexp">/\//</span>)[-1]

    code_dir = &quot;/tmp/r-#{rand()}/&quot;
    code_loc = &quot;#{code_dir}/#{code}&quot;
    output_loc = &quot;#{code_dir}/output.txt&quot;
    <span class="ruby-constant">FileUtils</span>.mkdir_p(code_dir)

    remote = job_data[<span class="ruby-string">'@code'</span>]
    storage = job_data[<span class="ruby-string">'@storage'</span>]

    datastore = <span class="ruby-constant">DatastoreFactory</span>.get_datastore(storage, job_data)
    datastore.get_output_and_save_to_fs(remote, code_loc)

    <span class="ruby-constant">Djinn</span>.log_debug(&quot;got code #{code}, saved at #{code_loc}&quot;)
    <span class="ruby-constant">Djinn</span>.log_run(&quot;chmod +x #{code_loc}&quot;)
    <span class="ruby-constant">Djinn</span>.log_run(&quot;Rscript --vanilla #{code_loc} &gt; #{output_loc}&quot;)

    datastore.write_remote_file_from_local_file(job_data[<span class="ruby-string">'@output'</span>], output_loc)
    remove_lock_file(job_data)
  }

  return <span class="ruby-string">&quot;OK&quot;</span>
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="neptune_release_nodes-method" class="method-detail ">
        <a name="method-i-neptune_release_nodes"></a>

        
        <div class="method-heading">
          <span class="method-name">neptune_release_nodes</span><span
            class="method-args">(nodes_to_use, job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="neptune_release_nodes-source">
<pre>
<span class="ruby-comment"># File ../Neptune/neptune.rb, line 647</span>
def neptune_release_nodes(nodes_to_use, job_data)
  if is_hybrid_cloud?
    abort(<span class="ruby-string">&quot;hybrid cloud mode is definitely not supported&quot;</span>)
  elsif is_cloud?
    nodes_to_use.each { |node|
      node.set_roles(<span class="ruby-string">&quot;open&quot;</span>)
    }

    <span class="ruby-comment"># don't worry about terminating the vms - the appcontroller</span>
    <span class="ruby-comment"># will take care of this in its heartbeat loop</span>
  else
    return
  end
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="neptune_set_acl-method" class="method-detail ">
        <a name="method-i-neptune_set_acl"></a>

        
        <div class="method-heading">
          <span class="method-name">neptune_set_acl</span><span
            class="method-args">(job_data, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="neptune_set_acl-source">
<pre>
<span class="ruby-comment"># File ../Neptune/neptune.rb, line 205</span>
def neptune_set_acl(job_data, secret)
  message = validate_environment(job_data, secret)
  return message unless message == <span class="ruby-string">&quot;no error&quot;</span>

  <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;setting acl&quot;</span>)

  type = job_data[<span class="ruby-string">&quot;@type&quot;</span>]

  new_acl = job_data[<span class="ruby-string">&quot;@acl&quot;</span>]

  if new_acl != <span class="ruby-string">&quot;public&quot;</span> and new_acl != <span class="ruby-string">&quot;private&quot;</span>
    return <span class="ruby-string">&quot;error: new acl is neither public nor private&quot;</span>
  end

  output_location = job_data[<span class="ruby-string">&quot;@output&quot;</span>]
  if output_location.nil?
    return <span class="ruby-string">&quot;error: output not specified&quot;</span>
  else
    datastore = <span class="ruby-constant">DatastoreFactory</span>.get_datastore(job_data[<span class="ruby-string">'@storage'</span>], job_data)
    if datastore.does_file_exist?(output_location)
      return datastore.set_acl(output_location, new_acl)
    else
      return <span class="ruby-string">&quot;error: output does not exist&quot;</span>
    end
  end
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="neptune_ssa_get_output-method" class="method-detail ">
        <a name="method-i-neptune_ssa_get_output"></a>

        
        <div class="method-heading">
          <span class="method-name">neptune_ssa_get_output</span><span
            class="method-args">(job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="neptune_ssa_get_output-source">
<pre>
<span class="ruby-comment"># File ../Neptune/ssa_helper.rb, line 195</span>
def neptune_ssa_get_output(job_data)
  return <span class="ruby-constant">SSA_HOME</span>
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="neptune_ssa_run_job-method" class="method-detail ">
        <a name="method-i-neptune_ssa_run_job"></a>

        
        <div class="method-heading">
          <span class="method-name">neptune_ssa_run_job</span><span
            class="method-args">(nodes, job_data, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="neptune_ssa_run_job-source">
<pre>
<span class="ruby-comment"># File ../Neptune/ssa_helper.rb, line 24</span>
def neptune_ssa_run_job(nodes, job_data, secret)
  return <span class="ruby-constant">BAD_SECRET_MSG</span> unless valid_secret?(secret)
  <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;ssa - run&quot;</span>)

  <span class="ruby-constant">Thread</span>.new {
    start_time = <span class="ruby-constant">Time</span>.now
    total_compute_time = 0
    total_storage_time = 0
    total_slowest_path = 0
    c_times = []
    s_times = []

    <span class="ruby-constant">Djinn</span>.log_debug(&quot;job data is #{job_data.inspect}&quot;)
    keyname = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">'keyname'</span>]

    nodes = <span class="ruby-constant">Djinn</span>.convert_location_array_to_class(nodes, keyname)

    sims = neptune_get_ssa_num_simulations(nodes, job_data)

    working_dir = &quot;/tmp/ssa-#{rand(10000)}&quot;
    <span class="ruby-constant">FileUtils</span>.mkdir_p(working_dir)

    tar = working_dir + <span class="ruby-string">&quot;/&quot;</span> + <span class="ruby-constant">File</span>.basename(job_data[<span class="ruby-string">'@tar'</span>])

    <span class="ruby-constant">Djinn</span>.log_debug(&quot;tar is #{job_data['@tar']}&quot;)
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;working dir is #{working_dir}&quot;)

    remote = job_data[<span class="ruby-string">'@tar'</span>]

    datastore = <span class="ruby-constant">DatastoreFactory</span>.get_datastore(job_data[<span class="ruby-string">'@storage'</span>], job_data)
    datastore.get_output_and_save_to_fs(remote, tar)

    neptune_uncompress_file(tar)

    num_sims = job_data[<span class="ruby-string">&quot;@trajectories&quot;</span>] || job_data[<span class="ruby-string">&quot;@simulations&quot;</span>]

    param_num = job_data[<span class="ruby-string">'@param_num'</span>]

    threads = []
    node_times = []
    at = 0 
    nodes.each_with_index { |node, i|
      threads &lt;&lt; <span class="ruby-constant">Thread</span>.new {
        node_times[i] = 0

        ip = node.private_ip
        ssh_key = node.ssh_key
        start = at
        fin = at + sims[i]
        at = fin
        fin -= 1 
        <span class="ruby-constant">Djinn</span>.log_debug(&quot;This node will run trajectories #{start} to #{fin}&quot;)

        code_path = &quot;#{working_dir}/code/run.sh&quot;
        <span class="ruby-constant">Djinn</span>.log_run(&quot;chmod +x #{code_path}&quot;)
        exec = &quot;bash #{code_path}&quot;

        input = &quot;#{working_dir}/code/#{job_data['@input']}&quot;

        unless ip == <span class="ruby-constant">HelperFunctions</span>.local_ip
          <span class="ruby-constant">Djinn</span>.log_run(&quot;scp -r -i #{ssh_key} -o StrictHostkeyChecking=no #{working_dir} root@#{ip}:#{working_dir}&quot;)
        end

        trajectories = fin - start + 1 

        if <span class="ruby-constant">MULTICORE</span>
          cores = <span class="ruby-constant">HelperFunctions</span>.get_num_cpus()
        else
          cores = 1
        end

        done = 0
        loop {
          trajectories_left = trajectories - done
          <span class="ruby-constant">Djinn</span>.log_debug(&quot;Need to run #{trajectories_left} more trajectories on #{cores} cores&quot;)
          break if trajectories_left.zero?
          need_to_run = [trajectories_left, cores].min

          <span class="ruby-constant">Djinn</span>.log_debug(&quot;Running #{need_to_run} trajectories&quot;)
          core_threads = []
          current_times = []
          need_to_run.times { |j|
            core_threads &lt;&lt; <span class="ruby-constant">Thread</span>.new {
              my_trajectory = start+done+j
              <span class="ruby-constant">Djinn</span>.log_debug(&quot;Thread #{j} is running trajectory #{my_trajectory}&quot;)
              output = <span class="ruby-constant">File</span>.expand_path(&quot;#{working_dir}/output-#{my_trajectory}&quot;)

              <span class="ruby-comment"># run the computation, remembering to place StochKit in the user's PATH</span>
              path = &quot;PATH=$PATH:#{SSA_HOME}&quot;
              run_command = &quot;#{path} #{exec} #{input} #{output} #{my_trajectory} #{param_num}&quot;

              start_compute = <span class="ruby-constant">Time</span>.now
              <span class="ruby-constant">Djinn</span>.log_run(&quot;ssh -i #{ssh_key} -o StrictHostkeyChecking=no root@#{ip} '#{run_command}'&quot;)
              end_compute = <span class="ruby-constant">Time</span>.now
              c_time = end_compute - start_compute
              total_compute_time += c_time
              c_times &lt;&lt; c_time

              <span class="ruby-comment"># copy the output back to this box - in the future we can do merges here</span>
              <span class="ruby-comment"># or in the future we can just have the node upload to s3</span>
              start_storage = <span class="ruby-constant">Time</span>.now
              unless <span class="ruby-constant">HelperFunctions</span>.local_ip == ip
                remote_cp_command = &quot;scp -r -i #{ssh_key} -o StrictHostkeyChecking=no root@#{ip}:#{output} #{output}&quot;
                <span class="ruby-constant">Djinn</span>.log_run(remote_cp_command)

              end

              remote_location = &quot;#{job_data['@output']}/output-#{my_trajectory}&quot;
              datastore.write_remote_file_from_local_file(remote_location, output)
              end_storage = <span class="ruby-constant">Time</span>.now
              s_time = end_storage - start_storage
              total_storage_time += s_time
              s_times &lt;&lt; s_time

              node_times[i] += (c_time + s_time)

              <span class="ruby-comment"># remove our output - we can't want the disk to fill up</span>
              remove_cmd = &quot;rm -rf #{output}&quot;
              <span class="ruby-constant">Djinn</span>.log_run(&quot;ssh -i #{ssh_key} -o StrictHostkeyChecking=no root@#{ip} '#{remove_cmd}'&quot;)
              <span class="ruby-constant">Djinn</span>.log_run(remove_cmd)
            }
          }

          core_threads.each { |c| c.join }

          done += need_to_run
          <span class="ruby-constant">Djinn</span>.log_debug(&quot;Done running #{need_to_run} trajectories, #{trajectories - done} to go&quot;)
        }
      }
    }

    <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;ssa - joining threads&quot;</span>)

    threads.each { |t| t.join }

    <span class="ruby-comment"># clean up after ourselves</span>
    <span class="ruby-constant">Djinn</span>.log_run(&quot;rm -rf #{working_dir}&quot;)

    fin_time = <span class="ruby-constant">Time</span>.now
    total = fin_time - start_time
    total_slowest_path = node_times.max
    total_overhead_time = total - total_slowest_path

    timing_info = <span class="ruby-string">    TIMING: total execution time is #{total} seconds.    TIMING: total compute time is #{total_compute_time} seconds.    TIMING: total storage time is #{total_storage_time} seconds.    TIMING: slowest path time is #{total_slowest_path} seconds.    TIMING: overhead time is #{total_overhead_time} seconds.    TIMING: average compute time is #{average(c_times)} seconds.    TIMING: stddev compute time is #{standard_deviation(c_times)} seconds.    TIMING: average storage time is #{average(s_times)} seconds.    TIMING: stddev storage time is #{standard_deviation(s_times)} seconds.    RAW_DATA: node times are: [#{node_times.join(', ')}]    RAW_DATA: compute times are: [#{c_times.join(', ')}]    RAW_DATA: storage times are: [#{s_times.join(', ')}]</span>

    <span class="ruby-constant">Djinn</span>.log_debug(timing_info)

    remote_location = &quot;#{job_data['@output']}/timing_info.txt&quot;
    datastore.write_remote_file_from_string(remote_location, timing_info)

    remove_lock_file(job_data)
  }

  return <span class="ruby-string">&quot;OK&quot;</span>
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="neptune_start_job-method" class="method-detail ">
        <a name="method-i-neptune_start_job"></a>

        
        <div class="method-heading">
          <span class="method-name">neptune_start_job</span><span
            class="method-args">(job_data, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="neptune_start_job-source">
<pre>
<span class="ruby-comment"># File ../Neptune/neptune.rb, line 44</span>
def neptune_start_job(job_data, secret)
  message = validate_environment(job_data, secret)
  return message unless message == <span class="ruby-string">&quot;no error&quot;</span>

  touch_lock_file(job_data)
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;got run request - #{job_data.inspect}&quot;)

  prejob_status = can_run_job(job_data)
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;Pre-job status for job_data [#{job_data}] is [#{prejob_status}]&quot;)
  unless prejob_status == :ok
    return prejob_status
  end

  <span class="ruby-constant">Thread</span>.new {
    nodes_to_use = neptune_acquire_nodes(job_data)

    <span class="ruby-constant">Djinn</span>.log_debug(&quot;nodes to use are [#{nodes_to_use.join(', ')}]&quot;)
    start_job(nodes_to_use, job_data)

    start_time = <span class="ruby-constant">Time</span>.now()
    master_node = nodes_to_use.first 
    run_job_on_master(master_node, nodes_to_use, job_data)
    end_time = <span class="ruby-constant">Time</span>.now()

    stop_job(nodes_to_use, job_data)

    neptune_release_nodes(nodes_to_use, job_data)

    name = get_job_name(job_data)
    num_nodes = nodes_to_use.length
    this_job = <span class="ruby-constant">NeptuneJobData</span>.new(name, num_nodes, start_time, end_time)
    if <span class="ruby-ivar">@neptune_jobs</span>[name].nil?
      <span class="ruby-ivar">@neptune_jobs</span>[name] = [this_job]
    else
      <span class="ruby-ivar">@neptune_jobs</span>[name] &lt;&lt; this_job
    end

    code = job_data[<span class="ruby-string">'@code'</span>]
    if code.nil?
      <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;no code to remove&quot;</span>)
    else
      dirs = code.split(<span class="ruby-regexp">/\//</span>)
      code_dir = dirs[0, dirs.length-1].join(<span class="ruby-string">&quot;/&quot;</span>)

      if code_dir != <span class="ruby-string">&quot;/tmp&quot;</span>
        <span class="ruby-constant">Djinn</span>.log_debug(&quot;code is located at #{code_dir}&quot;)
        <span class="ruby-constant">Djinn</span>.log_run(&quot;rm -rf #{code_dir}&quot;)
      end
    end
  }

  return &quot;#{job_data['@type']} job is now running&quot;
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="optimal_nodes-method" class="method-detail ">
        <a name="method-i-optimal_nodes"></a>

        
        <div class="method-heading">
          <span class="method-name">optimal_nodes</span><span
            class="method-args">(job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="optimal_nodes-source">
<pre>
<span class="ruby-comment"># File ../Neptune/neptune.rb, line 706</span>
def optimal_nodes(job_data)
  return job_data[<span class="ruby-string">&quot;@nodes_to_use&quot;</span>]
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="parse_resource_info-method" class="method-detail ">
        <a name="method-i-parse_resource_info"></a>

        
        <div class="method-heading">
          <span class="method-name">parse_resource_info</span><span
            class="method-args">(job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Grabs the @nodes_to_use parameter from the given job data and returns a
hash only containing info about the resources found in each cloud. These
resources are either an integer (describing the number of virtual machines
to use) or a URL (describing an opaque resource that conforms to the TaskQ
API).</p>
          

          
          <div class="method-source-code"
            id="parse_resource_info-source">
<pre>
<span class="ruby-comment"># File ../Neptune/cicero_helper.rb, line 113</span>
def parse_resource_info(job_data)
  nodes_to_use = job_data[<span class="ruby-string">&quot;@nodes_to_use&quot;</span>]
  if nodes_to_use.class == <span class="ruby-constant">Integer</span>  <span class="ruby-comment"># only use nodes in the current cloud</span>
    return {<span class="ruby-string">&quot;cloud1&quot;</span> =&gt; nodes_to_use}
  end

  return <span class="ruby-constant">Hash</span>[*nodes_to_use]
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="remove_lock_file-method" class="method-detail ">
        <a name="method-i-remove_lock_file"></a>

        
        <div class="method-heading">
          <span class="method-name">remove_lock_file</span><span
            class="method-args">(job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="remove_lock_file-source">
<pre>
<span class="ruby-comment"># File ../Neptune/neptune.rb, line 498</span>
def remove_lock_file(job_data)
  shadow = get_shadow
  shadow_ip = shadow.private_ip
  shadow_key = shadow.ssh_key
  done_running = &quot;rm #{get_lock_file_path(job_data)}&quot;

  <span class="ruby-constant">HelperFunctions</span>.run_remote_command(shadow_ip, done_running, shadow_key, <span class="ruby-constant">NO_OUTPUT</span>)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="remove_roles-method" class="method-detail ">
        <a name="method-i-remove_roles"></a>

        
        <div class="method-heading">
          <span class="method-name">remove_roles</span><span
            class="method-args">(nodes, roles)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="remove_roles-source">
<pre>
<span class="ruby-comment"># File ../Neptune/neptune.rb, line 686</span>
def remove_roles(nodes, roles)
  return if nodes.nil?

  nodes.each { |node|
    node.remove_roles(roles)
    acc = <span class="ruby-constant">AppControllerClient</span>.new(node.private_ip, <span class="ruby-constant">HelperFunctions</span>.get_secret)
    acc.remove_role(roles)
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;[just removed] node at #{node.private_ip} is now #{node.jobs.join(', ')}&quot;)
  }
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="run_job_on_master-method" class="method-detail ">
        <a name="method-i-run_job_on_master"></a>

        
        <div class="method-heading">
          <span class="method-name">run_job_on_master</span><span
            class="method-args">(master_node, nodes_to_use, job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="run_job_on_master-source">
<pre>
<span class="ruby-comment"># File ../Neptune/neptune.rb, line 415</span>
def run_job_on_master(master_node, nodes_to_use, job_data)
  <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;run job on master&quot;</span>)
  converted_nodes = <span class="ruby-constant">Djinn</span>.convert_location_class_to_array(nodes_to_use)

  <span class="ruby-comment"># in cases where only remote resources are used, we don't acquire a master</span>
  <span class="ruby-comment"># node. therefore, let this node be the master node for this job</span>
  if master_node.nil?
    <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;No master node found - using my node as the master node&quot;</span>)
    master_node = my_node
  end

  master_node_ip = master_node.private_ip
  master_acc = <span class="ruby-constant">AppControllerClient</span>.new(master_node_ip, <span class="ruby-constant">HelperFunctions</span>.get_secret)

  result = master_acc.run_neptune_job(converted_nodes, job_data)
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;run job result was #{result}&quot;)

  loop {
    shadow = get_shadow
    lock_file = get_lock_file_path(job_data)
    command = &quot;ls #{lock_file}; echo $?&quot;
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;shadow's ssh key is #{shadow.ssh_key}&quot;)
    job_is_running = `ssh -i #{shadow.ssh_key} -o StrictHostkeyChecking=no root@#{shadow.private_ip} '#{command}'`
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;is job running? [#{job_is_running}]&quot;)
    if job_is_running.length &gt; 1
      return_val = job_is_running[-2].chr
      <span class="ruby-constant">Djinn</span>.log_debug(&quot;return val for file #{lock_file} is #{return_val}&quot;)
      break if return_val != <span class="ruby-string">&quot;0&quot;</span>
    end
    sleep(30)
  }
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="run_on_db_master-method" class="method-detail ">
        <a name="method-i-run_on_db_master"></a>

        
        <div class="method-heading">
          <span class="method-name">run_on_db_master</span><span
            class="method-args">(command, output=WANT_OUTPUT)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="run_on_db_master-source">
<pre>
<span class="ruby-comment"># File ../Neptune/mapreduce_helper.rb, line 197</span>
def run_on_db_master(command, output=<span class="ruby-constant">WANT_OUTPUT</span>)
  db_master = get_db_master
  ip = db_master.public_ip
  ssh_key = db_master.ssh_key  
  <span class="ruby-constant">HelperFunctions</span>.run_remote_command(ip, command, ssh_key, <span class="ruby-constant">NO_OUTPUT</span>) 
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="run_task-method" class="method-detail ">
        <a name="method-i-run_task"></a>

        
        <div class="method-heading">
          <span class="method-name">run_task</span><span
            class="method-args">(job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="run_task-source">
<pre>
<span class="ruby-comment"># File ../Neptune/babel_helper.rb, line 306</span>
def run_task(job_data)
  dir = <span class="ruby-constant">Djinn</span>.create_temp_dir()
  <span class="ruby-constant">Djinn</span>.copy_code_and_inputs_to_dir(job_data, dir)
  output, error = <span class="ruby-constant">Djinn</span>.run_code(job_data, dir)
  <span class="ruby-constant">Djinn</span>.write_babel_outputs(output, error, job_data)
  <span class="ruby-constant">Djinn</span>.cleanup(dir)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="run_via_cicero-method" class="method-detail ">
        <a name="method-i-run_via_cicero"></a>

        
        <div class="method-heading">
          <span class="method-name">run_via_cicero</span><span
            class="method-args">(nodes, job_data, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Runs a Cicero job on the given nodes or via a remote cloud, indicated
within job_data.</p>
          

          
          <div class="method-source-code"
            id="run_via_cicero-source">
<pre>
<span class="ruby-comment"># File ../Neptune/cicero_helper.rb, line 44</span>
def run_via_cicero(nodes, job_data, secret)
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;job data is #{job_data.inspect}&quot;)

  resource_info = parse_resource_info(job_data)

  keyname = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">'keyname'</span>]
  nodes = <span class="ruby-constant">Djinn</span>.convert_location_array_to_class(nodes, keyname)

  app_name = job_data[<span class="ruby-string">&quot;@app_name&quot;</span>]
  urls = start_appengine_on_all_nodes(resource_info, nodes, app_name)

  num_tasks_total = job_data[<span class="ruby-string">&quot;@tasks&quot;</span>]
  tasks_for_each_cloud = get_execution_plan(nodes, resource_info, num_tasks_total)

  function_name = job_data[<span class="ruby-string">&quot;@function&quot;</span>]
  inputs = get_inputs_from_job_data(job_data)

  start_time = <span class="ruby-constant">Time</span>.now
  threads_per_cloud = []
  urls.each { |cloud, urls|
    threads_per_cloud &lt;&lt; <span class="ruby-constant">Thread</span>.new {
      num_tasks = tasks_for_each_cloud[cloud]
      num_urls = urls.length
      threads_per_url = []
      num_urls.times { |i|
        threads_per_url &lt;&lt; <span class="ruby-constant">Thread</span>.new {
          <span class="ruby-comment"># TODO - consider cases where this doesn't divide evenly</span>
          host = urls[i]
          num_tasks_for_this_url = num_tasks / num_urls
          task_ids = []
          num_tasks_for_this_url.times { |j|
            output = job_data[<span class="ruby-string">&quot;@output&quot;</span>] + <span class="ruby-constant">String</span>(j)
            <span class="ruby-comment">#self.execute_task(host, function_name, inputs, output) #Python</span>
            task_ids &lt;&lt; self.execute_task(host, function_name, inputs, output) <span class="ruby-comment">#Java</span>
            task_number = j + 1
            percent_done = task_number / <span class="ruby-constant">Float</span>(num_tasks_for_this_url) * 100
            <span class="ruby-constant">Djinn</span>.log_debug(&quot;done putting #{task_number}/&quot; +
              &quot;#{num_tasks_for_this_url} tasks (#{percent_done} percent)&quot;)
          }

          num_tasks_for_this_url.times { |j|
            <span class="ruby-comment"># TODO - the task id shouldn't be the output - refactor later</span>
            <span class="ruby-comment">#task_id = job_data[&quot;@output&quot;] + String(j) #Python</span>
            task_id = task_ids[j] <span class="ruby-comment">#Java</span>
            self.wait_for_task_to_complete(host, task_id)
            task_number = j + 1
            percent_done = task_number / <span class="ruby-constant">Float</span>(num_tasks_for_this_url) * 100
            <span class="ruby-constant">Djinn</span>.log_debug(&quot;done with #{task_number}&quot; +
              &quot;/#{num_tasks_for_this_url} tasks (#{percent_done} percent)&quot;)
          }
        }
      }
      threads_per_url.each { |t| t.join }
    }
  }
  threads_per_cloud.each { |t| t.join }
  end_time = <span class="ruby-constant">Time</span>.now
  total_time = end_time - start_time
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;TIMING: total execution time is #{total_time} seconds&quot;)

  stop_appengine_on_all_nodes(resource_info, nodes, app_name)
  remove_lock_file(job_data)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="run_via_engine-method" class="method-detail ">
        <a name="method-i-run_via_engine"></a>

        
        <div class="method-heading">
          <span class="method-name">run_via_engine</span><span
            class="method-args">(engine, job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Tasks may also be run via remote engines - that is, they may have an
internal queue but definitely have a remote executor that we can blindly
push the task to and let it take care of.</p>
          

          
          <div class="method-source-code"
            id="run_via_engine-source">
<pre>
<span class="ruby-comment"># File ../Neptune/babel_helper.rb, line 220</span>
def run_via_engine(engine, job_data)
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;running job with data #{job_data.inspect} via a remote engine&quot;)

  <span class="ruby-comment"># When pushing jobs to AppScale's push queues, we need to know where the</span>
  <span class="ruby-comment"># app is located (via the login node's IP address) and the UserAppServer's</span>
  <span class="ruby-comment"># IP address, so pass that info along.</span>
  if engine == <span class="ruby-string">&quot;appscale-push-q&quot;</span>
    job_data[<span class="ruby-string">'@login_ip'</span>] = get_login.public_ip
    job_data[<span class="ruby-string">'@uaserver_ip'</span>] = <span class="ruby-ivar">@userappserver_public_ip</span>
    job_data[<span class="ruby-string">'@secret'</span>] = <span class="ruby-constant">HelperFunctions</span>.get_secret()
    <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;Adding info for AppScale push queues - &quot;</span> +
      &quot;job data is now #{job_data.inspect}&quot;)
  end

  e = <span class="ruby-constant">EngineFactory</span>.get_engine(engine, job_data)
  e.push(job_data)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="run_via_executor-method" class="method-detail ">
        <a name="method-i-run_via_executor"></a>

        
        <div class="method-heading">
          <span class="method-name">run_via_executor</span><span
            class="method-args">(engine, job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Tasks can be run via our task executor, which will run tasks within
AppScale and store task data in a queue service, which may not be local to
AppScale.</p>
          

          
          <div class="method-source-code"
            id="run_via_executor-source">
<pre>
<span class="ruby-comment"># File ../Neptune/babel_helper.rb, line 196</span>
def run_via_executor(engine, job_data)
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;running job with data #{job_data.inspect} via executor&quot;)
  q = <span class="ruby-constant">QueueFactory</span>.get_queue(engine, job_data)
  credentials = q.get_creds()
  queue_and_creds = {engine =&gt; credentials}

  <span class="ruby-comment"># since the same queue / credentials can be used repeatedly, don't keep</span>
  <span class="ruby-comment"># adding the same queue info over and over again</span>
  if <span class="ruby-ivar">@queues_to_read</span>.include?(queue_and_creds)
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;not adding queue and creds #{queue_and_creds.inspect} &quot; +
      <span class="ruby-string">&quot;to @queues_to_read - it's already in the list&quot;</span>)
  else
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;adding queue and creds #{queue_and_creds.inspect} to @queues_to_read&quot;)
    <span class="ruby-ivar">@queues_to_read</span> &lt;&lt; queue_and_creds
  end

  <span class="ruby-constant">Djinn</span>.log_debug(&quot;@queues_to_read now contains [#{@queues_to_read.join(', ')}]&quot;)
  q.push(job_data)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="spawn_babel_slaves-method" class="method-detail ">
        <a name="method-i-spawn_babel_slaves"></a>

        
        <div class="method-heading">
          <span class="method-name">spawn_babel_slaves</span><span
            class="method-args">(num_of_waiting_tasks)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>A Babel master can call this method to add more workers (Babel slaves) to
the system as needed.</p>
          

          
          <div class="method-source-code"
            id="spawn_babel_slaves-source">
<pre>
<span class="ruby-comment"># File ../Neptune/babel_helper.rb, line 563</span>
def spawn_babel_slaves(num_of_waiting_tasks)
  <span class="ruby-comment"># TODO(cgb): move this info out of this method and include other instance types</span>
  instance_type = job_data[<span class="ruby-string">'@instance_type'</span>] or <span class="ruby-ivar">@creds</span>[<span class="ruby-string">'instance_type'</span>]

  if instance_type.empty?
    cores_per_machine = <span class="ruby-constant">HelperFunctions</span>.get_num_cpus()
  else
    cores_per_machine = <span class="ruby-constant">INSTANCE_CPU_INFO</span>[instance_type]
  end

  num_of_vms_needed = (num_of_waiting_tasks / <span class="ruby-constant">Float</span>(cores_per_machine)).ceil
  <span class="ruby-comment">#num_of_vms_needed = (num_of_waiting_tasks / Float(1)).ceil</span>

  <span class="ruby-comment"># Include rabbitmq_slave in here since we want to always be able to point</span>
  <span class="ruby-comment"># our RabbitMQ client to localhost to get tasks</span>
  roles = <span class="ruby-string">&quot;rabbitmq_slave:babel_slave&quot;</span>
  machine = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">'machine'</span>]

  <span class="ruby-constant">Djinn</span>.log_debug(&quot;spawning #{num_of_vms_needed} #{instance_type} nodes to &quot; +
    &quot;run #{num_of_waiting_tasks} tasks&quot;)

  <span class="ruby-comment"># first, use any open nodes that are idle</span>
  open_vms_used = 0
  <span class="ruby-ivar">@nodes</span>.each { |node|
    if node.is_open?
      <span class="ruby-constant">ZKInterface</span>.add_roles_to_node([<span class="ruby-string">&quot;babel_slave&quot;</span>], node)
    end
    open_vms_used += 1
    if open_vms_used &gt;= num_of_vms_needed
      <span class="ruby-constant">Djinn</span>.log_debug(&quot;Found #{open_vms_used} open VMs, using them instead &quot; +
        <span class="ruby-string">&quot;of spawning new VMs&quot;</span>)
      return
    end
  }

  num_of_vms_needed -= open_vms_used
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;Used #{open_vms_used} open VMs, still need to spawn &quot; +
    &quot;#{num_of_vms_needed} more VMs&quot;)

  <span class="ruby-comment"># if we still need more nodes, acquire them</span>
  <span class="ruby-constant">HelperFunctions</span>.set_creds_in_env(<span class="ruby-ivar">@creds</span>, <span class="ruby-string">&quot;1&quot;</span>)
  babel_slaves_info = <span class="ruby-constant">HelperFunctions</span>.spawn_vms(num_of_vms_needed, roles,
    <span class="ruby-ivar">@creds</span>[<span class="ruby-string">'machine'</span>], instance_type, <span class="ruby-ivar">@creds</span>[<span class="ruby-string">'keyname'</span>],
    <span class="ruby-ivar">@creds</span>[<span class="ruby-string">'infrastructure'</span>], <span class="ruby-string">&quot;cloud1&quot;</span>, <span class="ruby-ivar">@creds</span>[<span class="ruby-string">'group'</span>])
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;info about new nodes is [#{babel_slaves_info.join(', ')}]&quot;)
  add_nodes(babel_slaves_info)

  return babel_slaves_info
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="spawn_nodes_for_neptune-3F-method" class="method-detail ">
        <a name="method-i-spawn_nodes_for_neptune-3F"></a>

        
        <div class="method-heading">
          <span class="method-name">spawn_nodes_for_neptune?</span><span
            class="method-args">(job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="spawn_nodes_for_neptune-3F-source">
<pre>
<span class="ruby-comment"># File ../Neptune/neptune.rb, line 511</span>
def spawn_nodes_for_neptune?(job_data)
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;neptune_info = #{job_data}&quot;)
  return !job_data[<span class="ruby-string">&quot;@nodes_to_use&quot;</span>].nil?
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="standard_deviation-method" class="method-detail ">
        <a name="method-i-standard_deviation"></a>

        
        <div class="method-heading">
          <span class="method-name">standard_deviation</span><span
            class="method-args">(population)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="standard_deviation-source">
<pre>
<span class="ruby-comment"># File ../Neptune/ssa_helper.rb, line 279</span>
def standard_deviation(population)
  <span class="ruby-constant">Math</span>.sqrt(variance(population))
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="start_appengine_on_all_nodes-method" class="method-detail ">
        <a name="method-i-start_appengine_on_all_nodes"></a>

        
        <div class="method-heading">
          <span class="method-name">start_appengine_on_all_nodes</span><span
            class="method-args">(resource_info, nodes, app_name)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="start_appengine_on_all_nodes-source">
<pre>
<span class="ruby-comment"># File ../Neptune/cicero_helper.rb, line 122</span>
def start_appengine_on_all_nodes(resource_info, nodes, app_name)
  resource_info.each { |cloud, nodes_or_url|
    if nodes_or_url =~ <span class="ruby-constant">URL_REGEX</span>
      resource_info[cloud] = [nodes_or_url]
    else
      resource_info[cloud] = []
    end
  }

  if nodes.empty?
    <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;All resources used are remote resource - no need to&quot;</span> +
      <span class="ruby-string">&quot; start App Engine instances&quot;</span>)
    return resource_info
  end

  nodes.each { |node|
    <span class="ruby-comment"># update our local copy of what we think the nodes are doing</span>
    appengine_role = <span class="ruby-string">&quot;appengine&quot;</span>
    node.add_roles(appengine_role)

    <span class="ruby-comment"># tell the node that it should be running appengine apps</span>
    acc = <span class="ruby-constant">AppControllerClient</span>.new(node.public_ip, <span class="ruby-constant">HelperFunctions</span>.get_secret)
    acc.add_role(appengine_role)

    host = node.public_ip
    port = <span class="ruby-string">&quot;&quot;</span>
    uac = <span class="ruby-constant">UserAppClient</span>.new(<span class="ruby-ivar">@userappserver_private_ip</span>, <span class="ruby-constant">HelperFunctions</span>.get_secret)
    loop {
      app_data = uac.get_app_data(app_name)
      <span class="ruby-constant">Djinn</span>.log_debug(&quot;app data for app [#{app_name}] is [#{app_data}]&quot;)
      all_hosts = app_data.scan(<span class="ruby-regexp">/^hosts:(.*)/</span>).flatten.to_s.split(<span class="ruby-string">&quot;:&quot;</span>)
      all_ports = app_data.scan(<span class="ruby-regexp">/^ports:(.*)/</span>).flatten.to_s.split(<span class="ruby-string">&quot;:&quot;</span>)

      all_hosts.each_with_index { |this_host, index|
        if this_host == host
          port = all_ports[index].strip
          <span class="ruby-constant">Djinn</span>.log_debug(&quot;found a match: #{host}:#{port}&quot;)
          break
        end
      }
      break if !port.empty?

      <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;still waiting for app to come online...&quot;</span>)
      sleep(5)
    }
    uri = &quot;http://#{host}:#{port}&quot;
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;adding uri [#{uri}] to cloud [#{node.cloud}]&quot;)
    resource_info[node.cloud] &lt;&lt; uri
  }

  return resource_info
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="start_babel_master-method" class="method-detail ">
        <a name="method-i-start_babel_master"></a>

        
        <div class="method-heading">
          <span class="method-name">start_babel_master</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>The nodes that runs as a babel_master is a master in the system. It decides
when to spawn new workers, and how many to spawn, based on the number of
tasks waiting to be executed in all queues.</p>
          

          
          <div class="method-source-code"
            id="start_babel_master-source">
<pre>
<span class="ruby-comment"># File ../Neptune/babel_helper.rb, line 252</span>
def start_babel_master()
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;#{my_node.private_ip} is starting babel master&quot;)

  while !<span class="ruby-ivar">@kill_sig_received</span> do
    queues = get_queues_from_shadow()
    num_of_waiting_tasks = get_length_of_all_queues(queues)
    if num_of_waiting_tasks.zero?
      <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;all queues are empty - waiting for tasks to arrive&quot;</span>)
      <span class="ruby-constant">Kernel</span>.sleep(<span class="ruby-constant">TIME_TO_WAIT_FOR_NEW_TASKS</span>)
    else
      <span class="ruby-constant">Djinn</span>.log_debug(&quot;spawning workers to handle #{num_of_waiting_tasks} tasks&quot;)
      spawn_babel_slaves(num_of_waiting_tasks)
      <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;workers spawned - waiting for them to run tasks&quot;</span>)
      <span class="ruby-constant">Kernel</span>.sleep(<span class="ruby-constant">TIME_FOR_NEW_NODES_TO_GET_TASKS</span>)
    end
  end
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="start_babel_slave-method" class="method-detail ">
        <a name="method-i-start_babel_slave"></a>

        
        <div class="method-heading">
          <span class="method-name">start_babel_slave</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Nodes that run as babel_slaves are workers in the system. They ask the
master what queues tasks are stored on, and try to execute a configurable
number of tasks at a time.</p>
          

          
          <div class="method-source-code"
            id="start_babel_slave-source">
<pre>
<span class="ruby-comment"># File ../Neptune/babel_helper.rb, line 274</span>
def start_babel_slave()
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;#{my_node.private_ip} is starting babel slave&quot;)

  while !<span class="ruby-ivar">@kill_sig_received</span> do
    queues = get_queues_from_shadow()

    instance_type = job_data[<span class="ruby-string">'@instance_type'</span>] or <span class="ruby-ivar">@creds</span>[<span class="ruby-string">'instance_type'</span>]
    cores_per_machine = <span class="ruby-constant">INSTANCE_CPU_INFO</span>[instance_type]

    tasks = get_n_items_of_work(cores_per_machine, queues)
    <span class="ruby-comment"># tasks = get_n_items_of_work(1, queues)</span>
    if tasks.length.zero?
      <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;no tasks found, waiting for more to arrive&quot;</span>)
      <span class="ruby-constant">Kernel</span>.sleep(<span class="ruby-constant">TIME_TO_WAIT_FOR_NEW_TASKS</span>)
    else
      <span class="ruby-constant">Djinn</span>.log_debug(&quot;#{tasks.length} tasks found, executing&quot;)
      execute_multiple_tasks(tasks)
    end
  end
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="start_cewssa_master-method" class="method-detail ">
        <a name="method-i-start_cewssa_master"></a>

        
        <div class="method-heading">
          <span class="method-name">start_cewssa_master</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="start_cewssa_master-source">
<pre>
<span class="ruby-comment"># File ../Neptune/cewssa_helper.rb, line 99</span>
def start_cewssa_master()
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;#{my_node.private_ip} is starting cewssa master&quot;)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="start_cewssa_slave-method" class="method-detail ">
        <a name="method-i-start_cewssa_slave"></a>

        
        <div class="method-heading">
          <span class="method-name">start_cewssa_slave</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="start_cewssa_slave-source">
<pre>
<span class="ruby-comment"># File ../Neptune/cewssa_helper.rb, line 103</span>
def start_cewssa_slave()
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;#{my_node.private_ip} is starting cewssa slave&quot;)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="start_cicero_master-method" class="method-detail ">
        <a name="method-i-start_cicero_master"></a>

        
        <div class="method-heading">
          <span class="method-name">start_cicero_master</span><span
            class="method-args">(my_node)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="start_cicero_master-source">
<pre>
<span class="ruby-comment"># File ../Neptune/cicero_helper.rb, line 246</span>
def start_cicero_master(my_node)
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;#{my_node.private_ip} is starting cicero master&quot;)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="start_cicero_slave-method" class="method-detail ">
        <a name="method-i-start_cicero_slave"></a>

        
        <div class="method-heading">
          <span class="method-name">start_cicero_slave</span><span
            class="method-args">(my_node)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="start_cicero_slave-source">
<pre>
<span class="ruby-comment"># File ../Neptune/cicero_helper.rb, line 250</span>
def start_cicero_slave(my_node)
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;#{my_node.private_ip} is starting cicero slave&quot;)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="start_dfsp_master-method" class="method-detail ">
        <a name="method-i-start_dfsp_master"></a>

        
        <div class="method-heading">
          <span class="method-name">start_dfsp_master</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="start_dfsp_master-source">
<pre>
<span class="ruby-comment"># File ../Neptune/dfsp_helper.rb, line 88</span>
def start_dfsp_master()
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;#{my_node.private_ip} is starting dfsp master&quot;)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="start_dfsp_slave-method" class="method-detail ">
        <a name="method-i-start_dfsp_slave"></a>

        
        <div class="method-heading">
          <span class="method-name">start_dfsp_slave</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="start_dfsp_slave-source">
<pre>
<span class="ruby-comment"># File ../Neptune/dfsp_helper.rb, line 92</span>
def start_dfsp_slave()
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;#{my_node.private_ip} is starting dfsp slave&quot;)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="start_erlang_master-method" class="method-detail ">
        <a name="method-i-start_erlang_master"></a>

        
        <div class="method-heading">
          <span class="method-name">start_erlang_master</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="start_erlang_master-source">
<pre>
<span class="ruby-comment"># File ../Neptune/erlang_helper.rb, line 56</span>
def start_erlang_master()
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;#{my_node.private_ip} is starting erlang master&quot;)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="start_erlang_slave-method" class="method-detail ">
        <a name="method-i-start_erlang_slave"></a>

        
        <div class="method-heading">
          <span class="method-name">start_erlang_slave</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="start_erlang_slave-source">
<pre>
<span class="ruby-comment"># File ../Neptune/erlang_helper.rb, line 60</span>
def start_erlang_slave()
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;#{my_node.private_ip} is starting erlang slave&quot;)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="start_go_master-method" class="method-detail ">
        <a name="method-i-start_go_master"></a>

        
        <div class="method-heading">
          <span class="method-name">start_go_master</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="start_go_master-source">
<pre>
<span class="ruby-comment"># File ../Neptune/go_helper.rb, line 53</span>
def start_go_master()
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;#{my_node.private_ip} is starting go master&quot;)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="start_go_slave-method" class="method-detail ">
        <a name="method-i-start_go_slave"></a>

        
        <div class="method-heading">
          <span class="method-name">start_go_slave</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="start_go_slave-source">
<pre>
<span class="ruby-comment"># File ../Neptune/go_helper.rb, line 57</span>
def start_go_slave()
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;#{my_node.private_ip} is starting go slave&quot;)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="start_job-method" class="method-detail ">
        <a name="method-i-start_job"></a>

        
        <div class="method-heading">
          <span class="method-name">start_job</span><span
            class="method-args">(nodes, job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="start_job-source">
<pre>
<span class="ruby-comment"># File ../Neptune/neptune.rb, line 364</span>
def start_job(nodes, job_data)
  <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;job - start&quot;</span>)

  <span class="ruby-comment"># if all the resources are remotely owned, we can't add roles to</span>
  <span class="ruby-comment"># them, so don't</span>
  if nodes.empty?
    <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;no nodes to add roles to, returning...&quot;</span>)
    return
  end

  master_role, slave_role = get_node_roles(job_data)

  other_nodes = nodes - [nodes.first]
  add_roles_and_wait(other_nodes, slave_role)
  if !other_nodes.nil? and !other_nodes.empty? <span class="ruby-comment"># TODO: prettify me</span>
  other_nodes.each { |node|
    node.add_roles(slave_role)
  }
  end

  master_node = nodes.first
  master_node_ip = master_node.private_ip

  master_acc = <span class="ruby-constant">AppControllerClient</span>.new(master_node_ip, <span class="ruby-constant">HelperFunctions</span>.get_secret)
  master_acc.add_role(master_role)

  <span class="ruby-comment"># finally, update our local copy of what the master is doing</span>
  master_node.add_roles(master_role)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="start_mapreduce_master-method" class="method-detail ">
        <a name="method-i-start_mapreduce_master"></a>

        
        <div class="method-heading">
          <span class="method-name">start_mapreduce_master</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="start_mapreduce_master-source">
<pre>
<span class="ruby-comment"># File ../Neptune/mapreduce_helper.rb, line 154</span>
def start_mapreduce_master()
  <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;start mapreduce master - starting up hadoop first&quot;</span>)
  <span class="ruby-comment">#start_db_master</span>
  <span class="ruby-comment">#start_hadoop_slave</span>
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="start_mapreduce_slave-method" class="method-detail ">
        <a name="method-i-start_mapreduce_slave"></a>

        
        <div class="method-heading">
          <span class="method-name">start_mapreduce_slave</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="start_mapreduce_slave-source">
<pre>
<span class="ruby-comment"># File ../Neptune/mapreduce_helper.rb, line 160</span>
def start_mapreduce_slave()
  <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;start mapreduce slave - starting up hadoop first&quot;</span>)
  <span class="ruby-comment">#start_db_slave</span>
  <span class="ruby-comment">#start_hadoop_slave</span>
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="start_mpd-method" class="method-detail ">
        <a name="method-i-start_mpd"></a>

        
        <div class="method-heading">
          <span class="method-name">start_mpd</span><span
            class="method-args">(nodes)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="start_mpd-source">
<pre>
<span class="ruby-comment"># File ../Neptune/mpi_helper.rb, line 182</span>
def start_mpd(nodes)
  mpd_hosts_contents = <span class="ruby-string">&quot;&quot;</span>
  nodes.each { |node|
    mpd_hosts_contents &lt;&lt; &quot;#{node.private_ip}\n&quot;
  }
  mpd_hosts_contents.chomp!
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;MPD Hosts are: #{mpd_hosts_contents}&quot;)
  <span class="ruby-constant">HelperFunctions</span>.write_file(<span class="ruby-constant">MPD_HOSTS</span>, mpd_hosts_contents) 

  ssh_keys = []
  nodes.each { |node|
     ssh_keys &lt;&lt; node.ssh_key
  }
  ssh_keys.uniq!

  <span class="ruby-constant">Djinn</span>.log_run(&quot;mpdboot -r 'ssh -o StrictHostkeyChecking=no -i #{ssh_keys.join(' -i ')}' -f #{MPD_HOSTS} -n #{nodes.length}&quot;)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="start_mpi_master-method" class="method-detail ">
        <a name="method-i-start_mpi_master"></a>

        
        <div class="method-heading">
          <span class="method-name">start_mpi_master</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="start_mpi_master-source">
<pre>
<span class="ruby-comment"># File ../Neptune/mpi_helper.rb, line 205</span>
def start_mpi_master()
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;#{my_node.private_ip} is starting mpi master&quot;)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="start_mpi_slave-method" class="method-detail ">
        <a name="method-i-start_mpi_slave"></a>

        
        <div class="method-heading">
          <span class="method-name">start_mpi_slave</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="start_mpi_slave-source">
<pre>
<span class="ruby-comment"># File ../Neptune/mpi_helper.rb, line 209</span>
def start_mpi_slave()
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;#{my_node.private_ip} is starting mpi slave&quot;)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="start_nfs-method" class="method-detail ">
        <a name="method-i-start_nfs"></a>

        
        <div class="method-heading">
          <span class="method-name">start_nfs</span><span
            class="method-args">(nodes)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="start_nfs-source">
<pre>
<span class="ruby-comment"># File ../Neptune/mpi_helper.rb, line 126</span>
def start_nfs(nodes)
  <span class="ruby-constant">Djinn</span>.log_run(<span class="ruby-string">&quot;/etc/init.d/nfs-kernel-server start&quot;</span>)
  sleep(10)

  slave_nodes = nodes - [my_node]
  return if slave_nodes.empty?

  slave_mount = &quot;mount #{my_node.private_ip}:/mirrornfs /mirrornfs&quot;
  slave_nodes.each { |node|
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;[nfs master] node at #{node.private_ip} is currently doing #{node.jobs.join(', ')}&quot;)
    next if node.private_ip == my_node.private_ip
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;mounting /mirrornfs on machine located at [#{node.private_ip}]&quot;)
    <span class="ruby-constant">HelperFunctions</span>.run_remote_command(node.private_ip, slave_mount, node.ssh_key, <span class="ruby-constant">NO_OUTPUT</span>)
  }

  sleep(10)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="start_r_master-method" class="method-detail ">
        <a name="method-i-start_r_master"></a>

        
        <div class="method-heading">
          <span class="method-name">start_r_master</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="start_r_master-source">
<pre>
<span class="ruby-comment"># File ../Neptune/r_helper.rb, line 51</span>
def start_r_master()
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;#{my_node.private_ip} is starting r master&quot;)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="start_r_slave-method" class="method-detail ">
        <a name="method-i-start_r_slave"></a>

        
        <div class="method-heading">
          <span class="method-name">start_r_slave</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="start_r_slave-source">
<pre>
<span class="ruby-comment"># File ../Neptune/r_helper.rb, line 55</span>
def start_r_slave()
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;#{my_node.private_ip} is starting r slave&quot;)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="start_ssa_master-method" class="method-detail ">
        <a name="method-i-start_ssa_master"></a>

        
        <div class="method-heading">
          <span class="method-name">start_ssa_master</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="start_ssa_master-source">
<pre>
<span class="ruby-comment"># File ../Neptune/ssa_helper.rb, line 199</span>
def start_ssa_master()
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;#{my_node.private_ip} is starting ssa master&quot;)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="start_ssa_slave-method" class="method-detail ">
        <a name="method-i-start_ssa_slave"></a>

        
        <div class="method-heading">
          <span class="method-name">start_ssa_slave</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="start_ssa_slave-source">
<pre>
<span class="ruby-comment"># File ../Neptune/ssa_helper.rb, line 203</span>
def start_ssa_slave()
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;#{my_node.private_ip} is starting ssa slave&quot;)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="stop_appengine_on_all_nodes-method" class="method-detail ">
        <a name="method-i-stop_appengine_on_all_nodes"></a>

        
        <div class="method-heading">
          <span class="method-name">stop_appengine_on_all_nodes</span><span
            class="method-args">(resource_info, nodes, app_name)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="stop_appengine_on_all_nodes-source">
<pre>
<span class="ruby-comment"># File ../Neptune/cicero_helper.rb, line 175</span>
def stop_appengine_on_all_nodes(resource_info, nodes, app_name)
  if nodes.empty?
    <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;All resources used are remote resource - no need to&quot;</span> +
      <span class="ruby-string">&quot; stop App Engine instances&quot;</span>)
    return
  end

  nodes.each { |node|
    <span class="ruby-comment"># update our local copy of what we think the nodes are doing</span>
    appengine_role = <span class="ruby-string">&quot;appengine&quot;</span>
    node.remove_roles(appengine_role)

    <span class="ruby-comment"># tell the node that it should no longer be running appengine apps</span>
    acc = <span class="ruby-constant">AppControllerClient</span>.new(node.public_ip, <span class="ruby-constant">HelperFunctions</span>.get_secret)
    acc.remove_role(appengine_role)
  }

  return
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="stop_babel_master-method" class="method-detail ">
        <a name="method-i-stop_babel_master"></a>

        
        <div class="method-heading">
          <span class="method-name">stop_babel_master</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="stop_babel_master-source">
<pre>
<span class="ruby-comment"># File ../Neptune/babel_helper.rb, line 296</span>
def stop_babel_master()
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;#{my_node.private_ip} is stopping babel master&quot;)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="stop_babel_slave-method" class="method-detail ">
        <a name="method-i-stop_babel_slave"></a>

        
        <div class="method-heading">
          <span class="method-name">stop_babel_slave</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="stop_babel_slave-source">
<pre>
<span class="ruby-comment"># File ../Neptune/babel_helper.rb, line 301</span>
def stop_babel_slave()
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;#{my_node.private_ip} is stopping babel slave&quot;)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="stop_cewssa_master-method" class="method-detail ">
        <a name="method-i-stop_cewssa_master"></a>

        
        <div class="method-heading">
          <span class="method-name">stop_cewssa_master</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="stop_cewssa_master-source">
<pre>
<span class="ruby-comment"># File ../Neptune/cewssa_helper.rb, line 107</span>
def stop_cewssa_master()
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;#{my_node.private_ip} is stopping cewssa master&quot;)
  <span class="ruby-comment"># tell the shadow we're done running cewssa jobs</span>
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="stop_cewssa_slave-method" class="method-detail ">
        <a name="method-i-stop_cewssa_slave"></a>

        
        <div class="method-heading">
          <span class="method-name">stop_cewssa_slave</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="stop_cewssa_slave-source">
<pre>
<span class="ruby-comment"># File ../Neptune/cewssa_helper.rb, line 112</span>
def stop_cewssa_slave()
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;#{my_node.private_ip} is stopping cewssa slave&quot;)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="stop_cicero_master-method" class="method-detail ">
        <a name="method-i-stop_cicero_master"></a>

        
        <div class="method-heading">
          <span class="method-name">stop_cicero_master</span><span
            class="method-args">(my_node)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="stop_cicero_master-source">
<pre>
<span class="ruby-comment"># File ../Neptune/cicero_helper.rb, line 254</span>
def stop_cicero_master(my_node)
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;#{my_node.private_ip} is stopping cicero master&quot;)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="stop_cicero_slave-method" class="method-detail ">
        <a name="method-i-stop_cicero_slave"></a>

        
        <div class="method-heading">
          <span class="method-name">stop_cicero_slave</span><span
            class="method-args">(my_node)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="stop_cicero_slave-source">
<pre>
<span class="ruby-comment"># File ../Neptune/cicero_helper.rb, line 258</span>
def stop_cicero_slave(my_node)
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;#{my_node.private_ip} is stopping cicero slave&quot;)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="stop_dfsp_master-method" class="method-detail ">
        <a name="method-i-stop_dfsp_master"></a>

        
        <div class="method-heading">
          <span class="method-name">stop_dfsp_master</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="stop_dfsp_master-source">
<pre>
<span class="ruby-comment"># File ../Neptune/dfsp_helper.rb, line 96</span>
def stop_dfsp_master()
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;#{my_node.private_ip} is stopping dfsp master&quot;)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="stop_dfsp_slave-method" class="method-detail ">
        <a name="method-i-stop_dfsp_slave"></a>

        
        <div class="method-heading">
          <span class="method-name">stop_dfsp_slave</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="stop_dfsp_slave-source">
<pre>
<span class="ruby-comment"># File ../Neptune/dfsp_helper.rb, line 100</span>
def stop_dfsp_slave()
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;#{my_node.private_ip} is stopping dfsp slave&quot;)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="stop_erlang_master-method" class="method-detail ">
        <a name="method-i-stop_erlang_master"></a>

        
        <div class="method-heading">
          <span class="method-name">stop_erlang_master</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="stop_erlang_master-source">
<pre>
<span class="ruby-comment"># File ../Neptune/erlang_helper.rb, line 64</span>
def stop_erlang_master()
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;#{my_node.private_ip} is stopping erlang master&quot;)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="stop_erlang_slave-method" class="method-detail ">
        <a name="method-i-stop_erlang_slave"></a>

        
        <div class="method-heading">
          <span class="method-name">stop_erlang_slave</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="stop_erlang_slave-source">
<pre>
<span class="ruby-comment"># File ../Neptune/erlang_helper.rb, line 68</span>
def stop_erlang_slave()
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;#{my_node.private_ip} is stopping erlang slave&quot;)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="stop_go_master-method" class="method-detail ">
        <a name="method-i-stop_go_master"></a>

        
        <div class="method-heading">
          <span class="method-name">stop_go_master</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="stop_go_master-source">
<pre>
<span class="ruby-comment"># File ../Neptune/go_helper.rb, line 61</span>
def stop_go_master()
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;#{my_node.private_ip} is stopping go master&quot;)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="stop_go_slave-method" class="method-detail ">
        <a name="method-i-stop_go_slave"></a>

        
        <div class="method-heading">
          <span class="method-name">stop_go_slave</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="stop_go_slave-source">
<pre>
<span class="ruby-comment"># File ../Neptune/go_helper.rb, line 65</span>
def stop_go_slave()
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;#{my_node.private_ip} is stopping go slave&quot;)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="stop_job-method" class="method-detail ">
        <a name="method-i-stop_job"></a>

        
        <div class="method-heading">
          <span class="method-name">stop_job</span><span
            class="method-args">(nodes, job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="stop_job-source">
<pre>
<span class="ruby-comment"># File ../Neptune/neptune.rb, line 448</span>
def stop_job(nodes, job_data)
  <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;job - stop&quot;</span>)

  <span class="ruby-comment"># if all the resources are remotely owned, we can't add roles to</span>
  <span class="ruby-comment"># them, so don't</span>
  if nodes.empty?
    <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;no nodes to add roles to, returning...&quot;</span>)
    return
  end

  master_role, slave_role = get_node_roles(job_data)

  master_node = nodes.first
  master_node_ip = master_node.private_ip
  master_node.remove_roles(master_role)

  master_acc = <span class="ruby-constant">AppControllerClient</span>.new(master_node_ip, <span class="ruby-constant">HelperFunctions</span>.get_secret)
  master_acc.remove_role(master_role)

  other_nodes = nodes - [nodes.first]
  remove_roles(other_nodes, slave_role)
  if !other_nodes.nil? and !other_nodes.empty? <span class="ruby-comment"># TODO: prettify me</span>
    other_nodes.each { |node|
      node.remove_roles(slave_role)
    }
  end
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="stop_mapreduce_master-method" class="method-detail ">
        <a name="method-i-stop_mapreduce_master"></a>

        
        <div class="method-heading">
          <span class="method-name">stop_mapreduce_master</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="stop_mapreduce_master-source">
<pre>
<span class="ruby-comment"># File ../Neptune/mapreduce_helper.rb, line 166</span>
def stop_mapreduce_master()
  <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;stop mapreduce master - stopping hadoop&quot;</span>)
  <span class="ruby-comment">#stop_db_master</span>
  <span class="ruby-comment">#stop_hadoop_slave</span>
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="stop_mapreduce_slave-method" class="method-detail ">
        <a name="method-i-stop_mapreduce_slave"></a>

        
        <div class="method-heading">
          <span class="method-name">stop_mapreduce_slave</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="stop_mapreduce_slave-source">
<pre>
<span class="ruby-comment"># File ../Neptune/mapreduce_helper.rb, line 172</span>
def stop_mapreduce_slave()
  <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;stop mapreduce slave - stopping hadoop&quot;</span>)
  <span class="ruby-comment">#stop_db_slave</span>
  <span class="ruby-comment">#stop_hadoop_slave</span>
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="stop_mpd-method" class="method-detail ">
        <a name="method-i-stop_mpd"></a>

        
        <div class="method-heading">
          <span class="method-name">stop_mpd</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="stop_mpd-source">
<pre>
<span class="ruby-comment"># File ../Neptune/mpi_helper.rb, line 200</span>
def stop_mpd()
  <span class="ruby-constant">Djinn</span>.log_run(<span class="ruby-string">&quot;mpdallexit&quot;</span>)
  `rm -fv #{MPD_HOSTS}`
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="stop_mpi_master-method" class="method-detail ">
        <a name="method-i-stop_mpi_master"></a>

        
        <div class="method-heading">
          <span class="method-name">stop_mpi_master</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="stop_mpi_master-source">
<pre>
<span class="ruby-comment"># File ../Neptune/mpi_helper.rb, line 213</span>
def stop_mpi_master()
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;#{my_node.private_ip} is stopping mpi master&quot;)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="stop_mpi_slave-method" class="method-detail ">
        <a name="method-i-stop_mpi_slave"></a>

        
        <div class="method-heading">
          <span class="method-name">stop_mpi_slave</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="stop_mpi_slave-source">
<pre>
<span class="ruby-comment"># File ../Neptune/mpi_helper.rb, line 217</span>
def stop_mpi_slave()
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;#{my_node.private_ip} is stopping mpi slave&quot;)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="stop_nfs-method" class="method-detail ">
        <a name="method-i-stop_nfs"></a>

        
        <div class="method-heading">
          <span class="method-name">stop_nfs</span><span
            class="method-args">(nodes)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="stop_nfs-source">
<pre>
<span class="ruby-comment"># File ../Neptune/mpi_helper.rb, line 144</span>
def stop_nfs(nodes)
  slave_nodes = nodes - [my_node]

  unless slave_nodes.empty?
    slave_nodes.each { |node|
      next if node.private_ip == my_node.private_ip
      unmount_nfs_store(node.private_ip, node.ssh_key)
    }
  end

  <span class="ruby-constant">Djinn</span>.log_run(<span class="ruby-string">&quot;/etc/init.d/nfs-kernel-server stop&quot;</span>)

  nodes.each { |node|
    <span class="ruby-constant">Djinn</span>.log_run(&quot;ssh #{node.private_ip} 'ps ax | grep nfs'&quot;)
    sleep(1)
  }
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="stop_r_master-method" class="method-detail ">
        <a name="method-i-stop_r_master"></a>

        
        <div class="method-heading">
          <span class="method-name">stop_r_master</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="stop_r_master-source">
<pre>
<span class="ruby-comment"># File ../Neptune/r_helper.rb, line 59</span>
def stop_r_master()
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;#{my_node.private_ip} is stopping r master&quot;)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="stop_r_slave-method" class="method-detail ">
        <a name="method-i-stop_r_slave"></a>

        
        <div class="method-heading">
          <span class="method-name">stop_r_slave</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="stop_r_slave-source">
<pre>
<span class="ruby-comment"># File ../Neptune/r_helper.rb, line 63</span>
def stop_r_slave()
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;#{my_node.private_ip} is stopping r slave&quot;)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="stop_ssa_master-method" class="method-detail ">
        <a name="method-i-stop_ssa_master"></a>

        
        <div class="method-heading">
          <span class="method-name">stop_ssa_master</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="stop_ssa_master-source">
<pre>
<span class="ruby-comment"># File ../Neptune/ssa_helper.rb, line 207</span>
def stop_ssa_master()
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;#{my_node.private_ip} is stopping ssa master&quot;)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="stop_ssa_slave-method" class="method-detail ">
        <a name="method-i-stop_ssa_slave"></a>

        
        <div class="method-heading">
          <span class="method-name">stop_ssa_slave</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="stop_ssa_slave-source">
<pre>
<span class="ruby-comment"># File ../Neptune/ssa_helper.rb, line 211</span>
def stop_ssa_slave()
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;#{my_node.private_ip} is stopping ssa slave&quot;)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="touch_lock_file-method" class="method-detail ">
        <a name="method-i-touch_lock_file"></a>

        
        <div class="method-heading">
          <span class="method-name">touch_lock_file</span><span
            class="method-args">(job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="touch_lock_file-source">
<pre>
<span class="ruby-comment"># File ../Neptune/neptune.rb, line 492</span>
def touch_lock_file(job_data)
  job_data[<span class="ruby-string">&quot;@job_id&quot;</span>] = rand(1000000)
  touch_lock_file = &quot;touch #{get_lock_file_path(job_data)}&quot;
  <span class="ruby-constant">Djinn</span>.log_run(touch_lock_file)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="unmount_nfs_store-method" class="method-detail ">
        <a name="method-i-unmount_nfs_store"></a>

        
        <div class="method-heading">
          <span class="method-name">unmount_nfs_store</span><span
            class="method-args">(ip, ssh_key)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="unmount_nfs_store-source">
<pre>
<span class="ruby-comment"># File ../Neptune/mpi_helper.rb, line 162</span>
def unmount_nfs_store(ip, ssh_key)
  slave_umount = <span class="ruby-string">&quot;umount /mirrornfs&quot;</span>

  loop {
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;unmounting mirrornfs at #{ip} with ssh key #{ssh_key}&quot;)
    <span class="ruby-constant">HelperFunctions</span>.run_remote_command(ip, slave_umount, ssh_key, <span class="ruby-constant">NO_OUTPUT</span>)
    sleep(5)
    mount_status = `ssh root@#{ip} 'mount'`
    nfs_mounted = mount_status.scan(<span class="ruby-regexp">/mirrornfs/</span>)
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;NFS mount status at #{ip} is [#{nfs_mounted}]&quot;)

    if nfs_mounted == []
      <span class="ruby-constant">Djinn</span>.log_debug(&quot;NFS is stopped at #{ip}&quot;)
      break
    else
      <span class="ruby-constant">Djinn</span>.log_debug(&quot;NFS still not stopped at #{ip}&quot;)
    end
  }
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="validate_environment-method" class="method-detail ">
        <a name="method-i-validate_environment"></a>

        
        <div class="method-heading">
          <span class="method-name">validate_environment</span><span
            class="method-args">(job_data, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="validate_environment-source">
<pre>
<span class="ruby-comment"># File ../Neptune/neptune.rb, line 476</span>
def validate_environment(job_data, secret)
  return <span class="ruby-constant">BAD_SECRET_MSG</span> unless valid_secret?(secret)
  <span class="ruby-comment">#return JOB_IN_PROGRESS if lock_file_exists?(job_data)</span>
  return <span class="ruby-constant">BAD_TYPE_MSG</span> unless <span class="ruby-constant">NEPTUNE_JOBS</span>.include?(job_data[<span class="ruby-string">&quot;@type&quot;</span>])

  if job_data[<span class="ruby-string">&quot;@type&quot;</span>] == <span class="ruby-string">&quot;mapreduce&quot;</span>
    return <span class="ruby-constant">BAD_TABLE_MSG</span> unless <span class="ruby-constant">DBS_W_HADOOP</span>.include?(<span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;table&quot;</span>])
  end

  return <span class="ruby-string">&quot;no error&quot;</span>
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="variance-method" class="method-detail ">
        <a name="method-i-variance"></a>

        
        <div class="method-heading">
          <span class="method-name">variance</span><span
            class="method-args">(population)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="variance-source">
<pre>
<span class="ruby-comment"># File ../Neptune/ssa_helper.rb, line 264</span>
def variance(population)
  n    = 0
  mean = 0.0

  sum = population.reduce(0.0) do |sum, x|
    n     += 1
    delta  = x - mean
    mean  += delta / n

    sum + delta * (x - mean)
  end

  sum / n
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="wait_for_allotted_time-method" class="method-detail ">
        <a name="method-i-wait_for_allotted_time"></a>

        
        <div class="method-heading">
          <span class="method-name">wait_for_allotted_time</span><span
            class="method-args">(job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>When spawning up nodes to use for AppScale, we force the user to specify
how long the nodes should live for. This method simply waits that long.
TODO(cgb): What about cases when the nodes should last forever?</p>
          

          
          <div class="method-source-code"
            id="wait_for_allotted_time-source">
<pre>
<span class="ruby-comment"># File ../Neptune/appscale_helper.rb, line 33</span>
def wait_for_allotted_time(job_data)
  start_time = <span class="ruby-constant">Time</span>.now
  time_allotted = <span class="ruby-constant">Integer</span>(job_data[<span class="ruby-string">&quot;@time_needed_for&quot;</span>])
  item_spawned = job_data[<span class="ruby-string">&quot;@add_component&quot;</span>]

  loop {
    now = <span class="ruby-constant">Time</span>.now
    time_elapsed = now - start_time
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;time elapsed for #{item_spawned} so far is&quot; +
      &quot; #{time_elapsed}, time allotted is #{time_allotted}&quot;)
    break if time_elapsed &gt; time_allotted
    <span class="ruby-constant">Kernel</span>.sleep(60)
  }

  remove_lock_file(job_data)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="wait_for_hdfs_file-method" class="method-detail ">
        <a name="method-i-wait_for_hdfs_file"></a>

        
        <div class="method-heading">
          <span class="method-name">wait_for_hdfs_file</span><span
            class="method-args">(location)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="wait_for_hdfs_file-source">
<pre>
<span class="ruby-comment"># File ../Neptune/mapreduce_helper.rb, line 178</span>
def wait_for_hdfs_file(location)
  command = &quot;#{HADOOP} fs -ls #{location}&quot;
  db_master = get_db_master
  ip = db_master.public_ip
  ssh_key = db_master.ssh_key
  loop {
    cmd = &quot;ssh -o StrictHostkeyChecking=no -i #{ssh_key} #{ip} '#{command}'&quot;
    <span class="ruby-constant">Djinn</span>.log_debug(cmd)
    result = `#{cmd}`
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;oi: result was [#{result}]&quot;)
    break if result.match(<span class="ruby-regexp">/Found/</span>) <span class="ruby-comment"># this shows up when ls returns files</span>
    sleep(5)
  }
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
    </div>
  

  </div>

  <div id="validator-badges">
    <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
    <p><small>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish
      Rdoc Generator</a> 2</small>.</p>
  </div>

</body>
</html>

