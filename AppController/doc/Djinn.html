<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />

  <title>Class: Djinn</title>

  <link rel="stylesheet" href="./rdoc.css" type="text/css" media="screen" />

  <script src="./js/jquery.js" type="text/javascript"
    charset="utf-8"></script>
  <script src="./js/thickbox-compressed.js" type="text/javascript"
    charset="utf-8"></script>
  <script src="./js/quicksearch.js" type="text/javascript"
    charset="utf-8"></script>
  <script src="./js/darkfish.js" type="text/javascript"
    charset="utf-8"></script>

</head>
<body class="class">

  <div id="metadata">
    <div id="home-metadata">
      <div id="home-section" class="section">
        <h3 class="section-header">
          <a href="./index.html">Home</a>
          <a href="./index.html#classes">Classes</a>
          <a href="./index.html#methods">Methods</a>
        </h3>
      </div>
    </div>

    <div id="file-metadata">
      <div id="file-list-section" class="section">
        <h3 class="section-header">In Files</h3>
        <div class="section-body">
          <ul>
          
            <li><a href="./djinn_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="djinn.rb">djinn.rb</a></li>
          
            <li><a href="./__/Neptune/babel_helper_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="../Neptune/babel_helper.rb">../Neptune/babel_helper.rb</a></li>
          
            <li><a href="./__/Neptune/cicero_helper_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="../Neptune/cicero_helper.rb">../Neptune/cicero_helper.rb</a></li>
          
          </ul>
        </div>
      </div>

      
    </div>

    <div id="class-metadata">

      <!-- Parent Class -->
      
      <div id="parent-class-section" class="section">
        <h3 class="section-header">Parent</h3>
        
        <p class="link"><a href="Object.html">Object</a></p>
        
      </div>
      

      <!-- Namespace Contents -->
      

      <!-- Method Quickref -->
      
      <div id="method-list-section" class="section">
        <h3 class="section-header">Methods</h3>
        <ul class="link-list">
          
          <li><a href="#method-c-cleanup">::cleanup</a></li>
          
          <li><a href="#method-c-convert_location_array_to_class">::convert_location_array_to_class</a></li>
          
          <li><a href="#method-c-convert_location_class_to_array">::convert_location_class_to_array</a></li>
          
          <li><a href="#method-c-copy_code_and_inputs_to_dir">::copy_code_and_inputs_to_dir</a></li>
          
          <li><a href="#method-c-copy_code_to_dir">::copy_code_to_dir</a></li>
          
          <li><a href="#method-c-copy_file_to_dir">::copy_file_to_dir</a></li>
          
          <li><a href="#method-c-copy_inputs_to_dir">::copy_inputs_to_dir</a></li>
          
          <li><a href="#method-c-create_temp_dir">::create_temp_dir</a></li>
          
          <li><a href="#method-c-execute_task">::execute_task</a></li>
          
          <li><a href="#method-c-get_db_master_ip">::get_db_master_ip</a></li>
          
          <li><a href="#method-c-get_db_slave_ips">::get_db_slave_ips</a></li>
          
          <li><a href="#method-c-get_nearest_db_ip">::get_nearest_db_ip</a></li>
          
          <li><a href="#method-c-get_output">::get_output</a></li>
          
          <li><a href="#method-c-log_debug">::log_debug</a></li>
          
          <li><a href="#method-c-log_run">::log_run</a></li>
          
          <li><a href="#method-c-log_to_buffer">::log_to_buffer</a></li>
          
          <li><a href="#method-c-log_to_stdout">::log_to_stdout</a></li>
          
          <li><a href="#method-c-neptune_parse_creds">::neptune_parse_creds</a></li>
          
          <li><a href="#method-c-new">::new</a></li>
          
          <li><a href="#method-c-run_code">::run_code</a></li>
          
          <li><a href="#method-c-save_output">::save_output</a></li>
          
          <li><a href="#method-c-wait_for_task_to_complete">::wait_for_task_to_complete</a></li>
          
          <li><a href="#method-c-write_babel_outputs">::write_babel_outputs</a></li>
          
          <li><a href="#method-i-add_role">#add_role</a></li>
          
          <li><a href="#method-i-backup_appcontroller_state">#backup_appcontroller_state</a></li>
          
          <li><a href="#method-i-change_job">#change_job</a></li>
          
          <li><a href="#method-i-convert_fqdns_to_ips">#convert_fqdns_to_ips</a></li>
          
          <li><a href="#method-i-copy_app_to_local">#copy_app_to_local</a></li>
          
          <li><a href="#method-i-copy_encryption_keys">#copy_encryption_keys</a></li>
          
          <li><a href="#method-i-done_uploading">#done_uploading</a></li>
          
          <li><a href="#method-i-ensure_all_roles_are_running">#ensure_all_roles_are_running</a></li>
          
          <li><a href="#method-i-find_me_in_locations">#find_me_in_locations</a></li>
          
          <li><a href="#method-i-get_all_public_ips">#get_all_public_ips</a></li>
          
          <li><a href="#method-i-get_db_master">#get_db_master</a></li>
          
          <li><a href="#method-i-get_login">#get_login</a></li>
          
          <li><a href="#method-i-get_online_users_list">#get_online_users_list</a></li>
          
          <li><a href="#method-i-get_public_ip">#get_public_ip</a></li>
          
          <li><a href="#method-i-get_role_info">#get_role_info</a></li>
          
          <li><a href="#method-i-get_shadow">#get_shadow</a></li>
          
          <li><a href="#method-i-get_stats">#get_stats</a></li>
          
          <li><a href="#method-i-get_status">#get_status</a></li>
          
          <li><a href="#method-i-got_all_data">#got_all_data</a></li>
          
          <li><a href="#method-i-initialize_node">#initialize_node</a></li>
          
          <li><a href="#method-i-initialize_nodes_in_parallel">#initialize_nodes_in_parallel</a></li>
          
          <li><a href="#method-i-initialize_server">#initialize_server</a></li>
          
          <li><a href="#method-i-is_app_running">#is_app_running</a></li>
          
          <li><a href="#method-i-is_cloud-3F">#is_cloud?</a></li>
          
          <li><a href="#method-i-is_done_initializing">#is_done_initializing</a></li>
          
          <li><a href="#method-i-is_done_loading">#is_done_loading</a></li>
          
          <li><a href="#method-i-is_hybrid_cloud-3F">#is_hybrid_cloud?</a></li>
          
          <li><a href="#method-i-is_running-3F">#is_running?</a></li>
          
          <li><a href="#method-i-job_start">#job_start</a></li>
          
          <li><a href="#method-i-kill">#kill</a></li>
          
          <li><a href="#method-i-load_neptune_info">#load_neptune_info</a></li>
          
          <li><a href="#method-i-my_node">#my_node</a></li>
          
          <li><a href="#method-i-parse_creds">#parse_creds</a></li>
          
          <li><a href="#method-i-post_logs_to_sisyphus">#post_logs_to_sisyphus</a></li>
          
          <li><a href="#method-i-remove_node_from_local_and_zookeeper">#remove_node_from_local_and_zookeeper</a></li>
          
          <li><a href="#method-i-remove_role">#remove_role</a></li>
          
          <li><a href="#method-i-restore_appcontroller_state">#restore_appcontroller_state</a></li>
          
          <li><a href="#method-i-restore_db_state_if_needed">#restore_db_state_if_needed</a></li>
          
          <li><a href="#method-i-restore_from_db-3F">#restore_from_db?</a></li>
          
          <li><a href="#method-i-rsync_files">#rsync_files</a></li>
          
          <li><a href="#method-i-run_neptune_in_cloud-3F">#run_neptune_in_cloud?</a></li>
          
          <li><a href="#method-i-sanitize_credentials">#sanitize_credentials</a></li>
          
          <li><a href="#method-i-send_logs_to_sisyphus">#send_logs_to_sisyphus</a></li>
          
          <li><a href="#method-i-set_apps">#set_apps</a></li>
          
          <li><a href="#method-i-set_parameters">#set_parameters</a></li>
          
          <li><a href="#method-i-set_uaserver_ips">#set_uaserver_ips</a></li>
          
          <li><a href="#method-i-setup_config_files">#setup_config_files</a></li>
          
          <li><a href="#method-i-setup_hadoop_config_org">#setup_hadoop_config_org</a></li>
          
          <li><a href="#method-i-spawn_and_setup_appengine">#spawn_and_setup_appengine</a></li>
          
          <li><a href="#method-i-spawn_appengine">#spawn_appengine</a></li>
          
          <li><a href="#method-i-start_appcontroller">#start_appcontroller</a></li>
          
          <li><a href="#method-i-start_appengine">#start_appengine</a></li>
          
          <li><a href="#method-i-start_blobstore_server">#start_blobstore_server</a></li>
          
          <li><a href="#method-i-start_ejabberd">#start_ejabberd</a></li>
          
          <li><a href="#method-i-start_hadoop_org">#start_hadoop_org</a></li>
          
          <li><a href="#method-i-start_load_balancer">#start_load_balancer</a></li>
          
          <li><a href="#method-i-start_memcache">#start_memcache</a></li>
          
          <li><a href="#method-i-start_new_roles_on_nodes">#start_new_roles_on_nodes</a></li>
          
          <li><a href="#method-i-start_pbserver">#start_pbserver</a></li>
          
          <li><a href="#method-i-start_rabbitmq_server">#start_rabbitmq_server</a></li>
          
          <li><a href="#method-i-start_shadow">#start_shadow</a></li>
          
          <li><a href="#method-i-start_sisyphus">#start_sisyphus</a></li>
          
          <li><a href="#method-i-start_soap_server">#start_soap_server</a></li>
          
          <li><a href="#method-i-start_xmpp_for_app">#start_xmpp_for_app</a></li>
          
          <li><a href="#method-i-status">#status</a></li>
          
          <li><a href="#method-i-stop_app">#stop_app</a></li>
          
          <li><a href="#method-i-stop_appengine">#stop_appengine</a></li>
          
          <li><a href="#method-i-stop_blob_server">#stop_blob_server</a></li>
          
          <li><a href="#method-i-stop_ejabberd">#stop_ejabberd</a></li>
          
          <li><a href="#method-i-stop_load_balancer">#stop_load_balancer</a></li>
          
          <li><a href="#method-i-stop_memcache">#stop_memcache</a></li>
          
          <li><a href="#method-i-stop_pbserver">#stop_pbserver</a></li>
          
          <li><a href="#method-i-stop_shadow">#stop_shadow</a></li>
          
          <li><a href="#method-i-stop_sisyphus">#stop_sisyphus</a></li>
          
          <li><a href="#method-i-stop_soap_server">#stop_soap_server</a></li>
          
          <li><a href="#method-i-update">#update</a></li>
          
          <li><a href="#method-i-update_api_status">#update_api_status</a></li>
          
          <li><a href="#method-i-update_local_nodes">#update_local_nodes</a></li>
          
          <li><a href="#method-i-valid_format_for_credentials">#valid_format_for_credentials</a></li>
          
          <li><a href="#method-i-valid_secret-3F">#valid_secret?</a></li>
          
          <li><a href="#method-i-validate_image">#validate_image</a></li>
          
          <li><a href="#method-i-wait_for_data">#wait_for_data</a></li>
          
          <li><a href="#method-i-write_database_info">#write_database_info</a></li>
          
          <li><a href="#method-i-write_hypersoap">#write_hypersoap</a></li>
          
          <li><a href="#method-i-write_neptune_info">#write_neptune_info</a></li>
          
          <li><a href="#method-i-write_our_node_info">#write_our_node_info</a></li>
          
          <li><a href="#method-i-write_zookeeper_locations">#write_zookeeper_locations</a></li>
          
        </ul>
      </div>
      

      <!-- Included Modules -->
      
    </div>

    <div id="project-metadata">
      
      

      <div id="classindex-section" class="section project-section">
        <h3 class="section-header">Class/Module Index
          <span class="search-toggle"><img src="./images/find.png"
            height="16" width="16" alt="[+]"
            title="show/hide quicksearch" /></span></h3>
        <form action="#" method="get" accept-charset="utf-8" class="initially-hidden">
        <fieldset>
          <legend>Quicksearch</legend>
          <input type="text" name="quicksearch" value=""
            class="quicksearch-field" />
        </fieldset>
        </form>

        <ul class="link-list">
        
          <li><a href="./AppControllerClient.html">AppControllerClient</a></li>
        
          <li><a href="./BadConfigurationException.html">BadConfigurationException</a></li>
        
          <li><a href="./BlobServer.html">BlobServer</a></li>
        
          <li><a href="./Collectd.html">Collectd</a></li>
        
          <li><a href="./CronHelper.html">CronHelper</a></li>
        
          <li><a href="./Datastore.html">Datastore</a></li>
        
          <li><a href="./DatastoreFactory.html">DatastoreFactory</a></li>
        
          <li><a href="./DatastoreRepo.html">DatastoreRepo</a></li>
        
          <li><a href="./DatastoreRepoOnAppEngine.html">DatastoreRepoOnAppEngine</a></li>
        
          <li><a href="./DatastoreRepoOnAppScale.html">DatastoreRepoOnAppScale</a></li>
        
          <li><a href="./DatastoreS3.html">DatastoreS3</a></li>
        
          <li><a href="./Djinn.html">Djinn</a></li>
        
          <li><a href="./DjinnJobData.html">DjinnJobData</a></li>
        
          <li><a href="./DjinnServer.html">DjinnServer</a></li>
        
          <li><a href="./Ejabberd.html">Ejabberd</a></li>
        
          <li><a href="./EngineFactory.html">EngineFactory</a></li>
        
          <li><a href="./FailedZooKeeperOperationException.html">FailedZooKeeperOperationException</a></li>
        
          <li><a href="./GodInterface.html">GodInterface</a></li>
        
          <li><a href="./GoogleAppEnginePullQueue.html">GoogleAppEnginePullQueue</a></li>
        
          <li><a href="./GoogleAppEnginePushQueue.html">GoogleAppEnginePushQueue</a></li>
        
          <li><a href="./HAProxy.html">HAProxy</a></li>
        
          <li><a href="./HelperFunctions.html">HelperFunctions</a></li>
        
          <li><a href="./JSONClient.html">JSONClient</a></li>
        
          <li><a href="./LoadBalancer.html">LoadBalancer</a></li>
        
          <li><a href="./Monitoring.html">Monitoring</a></li>
        
          <li><a href="./NeptuneJobData.html">NeptuneJobData</a></li>
        
          <li><a href="./Nginx.html">Nginx</a></li>
        
          <li><a href="./Object.html">Object</a></li>
        
          <li><a href="./PbServer.html">PbServer</a></li>
        
          <li><a href="./QueueFactory.html">QueueFactory</a></li>
        
          <li><a href="./RabbitMQ.html">RabbitMQ</a></li>
        
          <li><a href="./Repo.html">Repo</a></li>
        
          <li><a href="./TaskEngine.html">TaskEngine</a></li>
        
          <li><a href="./TaskEngineAppScale.html">TaskEngineAppScale</a></li>
        
          <li><a href="./TaskEngineGoogleAppEngine.html">TaskEngineGoogleAppEngine</a></li>
        
          <li><a href="./TaskQueue.html">TaskQueue</a></li>
        
          <li><a href="./TaskQueueAzureQueue.html">TaskQueueAzureQueue</a></li>
        
          <li><a href="./TaskQueueGoogleAppEngine.html">TaskQueueGoogleAppEngine</a></li>
        
          <li><a href="./TaskQueueRabbitMQ.html">TaskQueueRabbitMQ</a></li>
        
          <li><a href="./TaskQueueSQS.html">TaskQueueSQS</a></li>
        
          <li><a href="./UserAppClient.html">UserAppClient</a></li>
        
          <li><a href="./ZKInterface.html">ZKInterface</a></li>
        
        </ul>
        <div id="no-class-search-results" style="display: none;">No matching classes.</div>
      </div>

      
    </div>
  </div>

  <div id="documentation">
    <h1 class="class">Djinn</h1>

    <div id="description">
      
<p><a href="Djinn.html">Djinn</a> (interchangeably known as ‘the
AppController’) automatically configures and deploys all services for a
single node. It relies on other Djinns or the AppScale Tools to tell it
what services (roles) it should be hosting, and exposes these methods via a
SOAP interface (as is provided in <a
href="DjinnServer.html">DjinnServer</a>).</p>

    </div>

    <!-- Constants -->
    
    <div id="constants-list" class="section">
      <h3 class="section-header">Constants</h3>
      <dl>
      
        <dt><a name="SERVER_PORT">SERVER_PORT</a></dt>
        
        <dd class="description"><p>The port that the AppController runs on by default</p></dd>
        
      
        <dt><a name="SSH_PORT">SSH_PORT</a></dt>
        
        <dd class="description"><p>The port that SSH connections are hosted over, by default.</p></dd>
        
      
        <dt><a name="USE_SSL">USE_SSL</a></dt>
        
        <dd class="description"><p>A boolean that should be used when we are waiting for a specific port to
open, and only if that port needs SSL to talk over it.</p></dd>
        
      
        <dt><a name="FIREWALL_IS_ON">FIREWALL_IS_ON</a></dt>
        
        <dd class="description"><p>A boolean that indicates whether or not we should turn the firewall on, and
continuously keep it on. Should definitely be on for releases, and on
whenever possible.</p></dd>
        
      
        <dt><a name="NEPTUNE_INFO">NEPTUNE_INFO</a></dt>
        
        <dd class="description"><p>The location on the local filesystem where the AppController writes
information about Neptune jobs that have finished. One day this information
may be used to more intelligently schedule jobs on the fly.</p></dd>
        
      
        <dt><a name="HEALTH_FILE">HEALTH_FILE</a></dt>
        
        <dd class="description"><p>The location on the local filesystem where the AppController writes
information about the status of App Engine APIs, which the AppLoadBalancer
will read and display to users.</p></dd>
        
      
        <dt><a name="STATE_FILE">STATE_FILE</a></dt>
        
        <dd class="description"><p>The location on the local filesystem where the AppController periodically
writes its state to, and recovers its state from if it crashes.</p></dd>
        
      
        <dt><a name="APPSCALE_HOME">APPSCALE_HOME</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="BAD_INPUT_MSG">BAD_INPUT_MSG</a></dt>
        
        <dd class="description"><p>The message that we display to the user if they call a SOAP-accessible
function with a malformed input (e.g., of the wrong class or format).</p></dd>
        
      
        <dt><a name="NOT_ENOUGH_OPEN_NODES">NOT_ENOUGH_OPEN_NODES</a></dt>
        
        <dd class="description"><p>The message that we display to the user if they want to scale up services
in an Xen/KVM deployment but don’t have enough open nodes to do so.</p></dd>
        
      
      </dl>
    </div>
    

    <!-- Attributes -->
    
    <div id="attribute-method-details" class="method-section section">
      <h3 class="section-header">Attributes</h3>

      
      <div id="nodes-attribute-method" class="method-detail">
        <a name="nodes"></a>
        
        <a name="nodes="></a>
        
        <div class="method-heading attribute-method-heading">
          <span class="method-name">nodes</span><span
            class="attribute-access-type">[RW]</span>
        </div>

        <div class="method-description">
        
        <p>An Array of <a href="DjinnJobData.html">DjinnJobData</a> objects, each of
which containing information about a node in the currently running AppScale
deployment.</p>
        
        </div>
      </div>
      
      <div id="creds-attribute-method" class="method-detail">
        <a name="creds"></a>
        
        <a name="creds="></a>
        
        <div class="method-heading attribute-method-heading">
          <span class="method-name">creds</span><span
            class="attribute-access-type">[RW]</span>
        </div>

        <div class="method-description">
        
        <p>A Hash containing all the parameters needed to configure any service on any
node. At a minimum, this is all the information from the AppScale Tools,
including information about database parameters and the roles for all
nodes.</p>
        
        </div>
      </div>
      
      <div id="app_names-attribute-method" class="method-detail">
        <a name="app_names"></a>
        
        <a name="app_names="></a>
        
        <div class="method-heading attribute-method-heading">
          <span class="method-name">app_names</span><span
            class="attribute-access-type">[RW]</span>
        </div>

        <div class="method-description">
        
        <p>An Array of Strings, each of which corresponding to the name of an App
Engine app that should be loaded.</p>
        
        </div>
      </div>
      
      <div id="apps_loaded-attribute-method" class="method-detail">
        <a name="apps_loaded"></a>
        
        <a name="apps_loaded="></a>
        
        <div class="method-heading attribute-method-heading">
          <span class="method-name">apps_loaded</span><span
            class="attribute-access-type">[RW]</span>
        </div>

        <div class="method-description">
        
        <p>An Array of Strings, each of which corresponding to the name of an App
Engine app that has been loaded on this node.</p>
        
        </div>
      </div>
      
      <div id="done_initializing-attribute-method" class="method-detail">
        <a name="done_initializing"></a>
        
        <a name="done_initializing="></a>
        
        <div class="method-heading attribute-method-heading">
          <span class="method-name">done_initializing</span><span
            class="attribute-access-type">[RW]</span>
        </div>

        <div class="method-description">
        
        <p>A boolean that is used to let remote callers know when this AppController
is done initializing itself, but not necessarily done starting or  stopping
roles.</p>
        
        </div>
      </div>
      
      <div id="done_loading-attribute-method" class="method-detail">
        <a name="done_loading"></a>
        
        <a name="done_loading="></a>
        
        <div class="method-heading attribute-method-heading">
          <span class="method-name">done_loading</span><span
            class="attribute-access-type">[RW]</span>
        </div>

        <div class="method-description">
        
        <p>A boolean that is used to let remote callers know when this AppController
is done starting all the services it is responsible for.</p>
        
        </div>
      </div>
      
      <div id="nginx_port-attribute-method" class="method-detail">
        <a name="nginx_port"></a>
        
        <a name="nginx_port="></a>
        
        <div class="method-heading attribute-method-heading">
          <span class="method-name">nginx_port</span><span
            class="attribute-access-type">[RW]</span>
        </div>

        <div class="method-description">
        
        <p>The port that nginx will listen to for the next App Engine app that is
uploaded into the system.</p>
        
        </div>
      </div>
      
      <div id="haproxy_port-attribute-method" class="method-detail">
        <a name="haproxy_port"></a>
        
        <a name="haproxy_port="></a>
        
        <div class="method-heading attribute-method-heading">
          <span class="method-name">haproxy_port</span><span
            class="attribute-access-type">[RW]</span>
        </div>

        <div class="method-description">
        
        <p>The port that haproxy will listen to for the next App Engine app that is
uploaded into the system.</p>
        
        </div>
      </div>
      
      <div id="userappserver_public_ip-attribute-method" class="method-detail">
        <a name="userappserver_public_ip"></a>
        
        <a name="userappserver_public_ip="></a>
        
        <div class="method-heading attribute-method-heading">
          <span class="method-name">userappserver_public_ip</span><span
            class="attribute-access-type">[RW]</span>
        </div>

        <div class="method-description">
        
        <p>The public IP address (or FQDN) that the UserAppServer can be found at,
initally set to a dummy value to tell callers not to use it until a real
value is set.</p>
        
        </div>
      </div>
      
      <div id="userappserver_private_ip-attribute-method" class="method-detail">
        <a name="userappserver_private_ip"></a>
        
        <a name="userappserver_private_ip="></a>
        
        <div class="method-heading attribute-method-heading">
          <span class="method-name">userappserver_private_ip</span><span
            class="attribute-access-type">[RW]</span>
        </div>

        <div class="method-description">
        
        <p>The public IP address (or FQDN) that the UserAppServer can be found at,
initally set to a dummy value to tell callers not to use it until a real
value is set.</p>
        
        </div>
      </div>
      
      <div id="state-attribute-method" class="method-detail">
        <a name="state"></a>
        
        <a name="state="></a>
        
        <div class="method-heading attribute-method-heading">
          <span class="method-name">state</span><span
            class="attribute-access-type">[RW]</span>
        </div>

        <div class="method-description">
        
        <p>The human-readable state that this AppController is in.</p>
        
        </div>
      </div>
      
      <div id="kill_sig_received-attribute-method" class="method-detail">
        <a name="kill_sig_received"></a>
        
        <a name="kill_sig_received="></a>
        
        <div class="method-heading attribute-method-heading">
          <span class="method-name">kill_sig_received</span><span
            class="attribute-access-type">[RW]</span>
        </div>

        <div class="method-description">
        
        <p>A boolean that is used to let remote callers start the shutdown process on
this AppController, which will cleanly shut down and terminate all services
on this node.</p>
        
        </div>
      </div>
      
      <div id="my_index-attribute-method" class="method-detail">
        <a name="my_index"></a>
        
        <a name="my_index="></a>
        
        <div class="method-heading attribute-method-heading">
          <span class="method-name">my_index</span><span
            class="attribute-access-type">[RW]</span>
        </div>

        <div class="method-description">
        
        <p>An Integer that indexes into @nodes, to return information about this node.</p>
        
        </div>
      </div>
      
      <div id="total_boxes-attribute-method" class="method-detail">
        <a name="total_boxes"></a>
        
        <a name="total_boxes="></a>
        
        <div class="method-heading attribute-method-heading">
          <span class="method-name">total_boxes</span><span
            class="attribute-access-type">[RW]</span>
        </div>

        <div class="method-description">
        
        <p>The number of nodes that are running in this AppScale deployment.
TODO(cgb): It would seem like we could always calculate this with
@nodes.length, so replace it accordingly.</p>
        
        </div>
      </div>
      
      <div id="num_appengines-attribute-method" class="method-detail">
        <a name="num_appengines"></a>
        
        <a name="num_appengines="></a>
        
        <div class="method-heading attribute-method-heading">
          <span class="method-name">num_appengines</span><span
            class="attribute-access-type">[RW]</span>
        </div>

        <div class="method-description">
        
        <p>The number of dev_appservers that should run for every App Engine
application.</p>
        
        </div>
      </div>
      
      <div id="restored-attribute-method" class="method-detail">
        <a name="restored"></a>
        
        <a name="restored="></a>
        
        <div class="method-heading attribute-method-heading">
          <span class="method-name">restored</span><span
            class="attribute-access-type">[RW]</span>
        </div>

        <div class="method-description">
        
        <p>A boolean that indicates if we are done restoring state from a previously
running AppScale deployment.</p>
        
        </div>
      </div>
      
      <div id="neptune_jobs-attribute-method" class="method-detail">
        <a name="neptune_jobs"></a>
        
        <a name="neptune_jobs="></a>
        
        <div class="method-heading attribute-method-heading">
          <span class="method-name">neptune_jobs</span><span
            class="attribute-access-type">[RW]</span>
        </div>

        <div class="method-description">
        
        <p>A Hash that maps information about each successfully completed Neptune job
to information about the job, that will one day be used to provide hints to
future jobs about how to schedule them optimally.</p>
        
        </div>
      </div>
      
      <div id="neptune_nodes-attribute-method" class="method-detail">
        <a name="neptune_nodes"></a>
        
        <a name="neptune_nodes="></a>
        
        <div class="method-heading attribute-method-heading">
          <span class="method-name">neptune_nodes</span><span
            class="attribute-access-type">[RW]</span>
        </div>

        <div class="method-description">
        
        <p>An Array of <a href="DjinnJobData.html">DjinnJobData</a> objects that
correspond to nodes used for Neptune computation. Nodes are reclaimed every
hour if they are not in use (to avoid being charged for them for another
hour).</p>
        
        </div>
      </div>
      
      <div id="api_status-attribute-method" class="method-detail">
        <a name="api_status"></a>
        
        <a name="api_status="></a>
        
        <div class="method-heading attribute-method-heading">
          <span class="method-name">api_status</span><span
            class="attribute-access-type">[RW]</span>
        </div>

        <div class="method-description">
        
        <p>A Hash that lists the status of each Google App Engine API made available
within AppScale. Keys are the names of the APIs (e.g., memcache), and
values are the statuses of those APIs (e.g., running).</p>
        
        </div>
      </div>
      
      <div id="queues_to_read-attribute-method" class="method-detail">
        <a name="queues_to_read"></a>
        
        <a name="queues_to_read="></a>
        
        <div class="method-heading attribute-method-heading">
          <span class="method-name">queues_to_read</span><span
            class="attribute-access-type">[RW]</span>
        </div>

        <div class="method-description">
        
        <p>For Babel jobs via Neptune, we keep a list of queues that may have tasks
stored for execution, as well as the parameters needed to execute them
(e.g., input location, output location, cloud credentials).</p>
        
        </div>
      </div>
      
      <div id="registered_with_sisyphus-attribute-method" class="method-detail">
        <a name="registered_with_sisyphus"></a>
        
        <a name="registered_with_sisyphus="></a>
        
        <div class="method-heading attribute-method-heading">
          <span class="method-name">registered_with_sisyphus</span><span
            class="attribute-access-type">[RW]</span>
        </div>

        <div class="method-description">
        
        <p>Each component that writes log data to Sisyphus must register itself first,
so this boolean ensures that we only register ourselves once.</p>
        
        </div>
      </div>
      
      <div id="last_updated-attribute-method" class="method-detail">
        <a name="last_updated"></a>
        
        <a name="last_updated="></a>
        
        <div class="method-heading attribute-method-heading">
          <span class="method-name">last_updated</span><span
            class="attribute-access-type">[RW]</span>
        </div>

        <div class="method-description">
        
        <p>An integer timestamp that corresponds to the last time this AppController
has updated @nodes, which we use to compare with a similar timestamp in
ZooKeeper to see when data in @nodes has changed on other nodes.</p>
        
        </div>
      </div>
      
    </div>
    

    <!-- Methods -->
    
    <div id="public-instance-method-details" class="method-section section">
      <h3 class="section-header">Public Instance Methods</h3>

    
      <div id="add_role-method" class="method-detail ">
        <a name="method-i-add_role"></a>

        
        <div class="method-heading">
          <span class="method-name">add_role</span><span
            class="method-args">(new_role, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="add_role-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 771</span>
def add_role(new_role, secret)
  if !valid_secret?(secret)
    return <span class="ruby-constant">BAD_SECRET_MSG</span>
  end

  <span class="ruby-comment"># new roles may run indefinitely in the background, so don't block</span>
  <span class="ruby-comment"># on them - just fire and forget</span>
  <span class="ruby-constant">Thread</span>.new {
    start_roles = new_role.split(<span class="ruby-string">&quot;:&quot;</span>)
    start_roles.each { |role|
      <span class="ruby-comment"># only start roles that we aren't already running</span>
      <span class="ruby-comment"># e.g., don't start_appengine if we already are, as this</span>
      <span class="ruby-comment"># will create two threads loading apps</span>
      if my_node.jobs.include?(role)
        <span class="ruby-constant">Djinn</span>.log_debug(&quot;Already running role #{role}, not invoking again&quot;)
      else
        <span class="ruby-constant">Djinn</span>.log_debug(&quot;Adding and starting role #{role}&quot;)
        my_node.add_roles(role)
        send(&quot;start_#{role}&quot;.to_sym)
      end
    }
  }

  return <span class="ruby-string">&quot;OK&quot;</span>
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="backup_appcontroller_state-method" class="method-detail ">
        <a name="method-i-backup_appcontroller_state"></a>

        
        <div class="method-heading">
          <span class="method-name">backup_appcontroller_state</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="backup_appcontroller_state-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 1205</span>
def backup_appcontroller_state()
  <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;Backing up AppController state to ZooKeeper&quot;</span>)
  state = {<span class="ruby-string">'@@secret'</span> =&gt; @@secret }

  instance_variables.each { |k|
    v = instance_variable_get(k)
    if k == <span class="ruby-string">&quot;@nodes&quot;</span>
      v = <span class="ruby-constant">Djinn</span>.convert_location_class_to_array(<span class="ruby-ivar">@nodes</span>)
    elsif k == <span class="ruby-string">&quot;@my_index&quot;</span> or k == <span class="ruby-string">&quot;@api_status&quot;</span>
      <span class="ruby-comment"># Don't back up @my_index - it's a node-specific pointer that</span>
      <span class="ruby-comment"># indicates which node is &quot;our node&quot; and thus should be regenerated</span>
      <span class="ruby-comment"># via find_me_in_locations. Also don't worry about @api_status - it</span>
      <span class="ruby-comment"># can take up a lot of space and can easily be regenerated with new</span>
      <span class="ruby-comment"># data.</span>
      next
    end

    state[k] = v
  }

  <span class="ruby-constant">ZKInterface</span>.write_appcontroller_state(state)
  <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;Backed up AppController state to ZooKeeper&quot;</span>)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="change_job-method" class="method-detail ">
        <a name="method-i-change_job"></a>

        
        <div class="method-heading">
          <span class="method-name">change_job</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="change_job-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 1789</span>
def change_job()
  my_data = my_node
  jobs_to_run = my_data.jobs
  
  if <span class="ruby-ivar">@creds</span>[<span class="ruby-string">'ips'</span>]
    <span class="ruby-ivar">@total_boxes</span> = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">'ips'</span>].length + 1
  elsif <span class="ruby-ivar">@creds</span>[<span class="ruby-string">'min_images'</span>]
    <span class="ruby-ivar">@total_boxes</span> = <span class="ruby-constant">Integer</span>(<span class="ruby-ivar">@creds</span>[<span class="ruby-string">'min_images'</span>])
  end

  <span class="ruby-constant">Djinn</span>.log_debug(&quot;Pre-loop: #{@nodes.join('\n')}&quot;)
  if <span class="ruby-ivar">@nodes</span>.size == 1 and <span class="ruby-ivar">@total_boxes</span> &gt; 1
    spawn_and_setup_appengine
    loop {
      <span class="ruby-constant">Djinn</span>.log_debug(&quot;Looping: #{@nodes.join('\n')}&quot;)
      <span class="ruby-ivar">@everyone_else_is_done</span> = true
      <span class="ruby-ivar">@nodes</span>.each_index { |index|
        unless index == <span class="ruby-ivar">@my_index</span>
          ip = <span class="ruby-ivar">@nodes</span>[index].private_ip
          acc = <span class="ruby-constant">AppControllerClient</span>.new(ip, @@secret)
          result = acc.is_done_initializing?()
          <span class="ruby-constant">Djinn</span>.log_debug(&quot;#{ip} returned #{result} (#{result.class})&quot;)
          <span class="ruby-ivar">@everyone_else_is_done</span> = false unless result
        end
      }
      break if <span class="ruby-ivar">@everyone_else_is_done</span>
      <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;Waiting on other nodes to come online&quot;</span>)
      <span class="ruby-constant">Kernel</span>.sleep(5)
    }
  end

  initialize_server
  <span class="ruby-comment"># start_load_balancer </span>

  memcache_ips = []
  <span class="ruby-ivar">@nodes</span>.each { |node|
    memcache_ips &lt;&lt; node.public_ip if node.is_memcache?
  }

  <span class="ruby-constant">Djinn</span>.log_debug(&quot;Memcache servers will be at #{memcache_ips.join(', ')}&quot;)

  memcache_file = <span class="ruby-string">&quot;/etc/appscale/memcache_ips&quot;</span>
  memcache_contents = memcache_ips.join(<span class="ruby-string">&quot;\n&quot;</span>)
  <span class="ruby-constant">HelperFunctions</span>.write_file(memcache_file, memcache_contents)

  setup_config_files
  set_uaserver_ips 
  write_hypersoap

  <span class="ruby-comment"># ejabberd uses uaserver for authentication</span>
  <span class="ruby-comment"># so start it after we find out the uaserver's ip</span>

  start_ejabberd if my_node.is_login?

  <span class="ruby-ivar">@done_initializing</span> = true

  <span class="ruby-comment"># start zookeeper</span>
  if my_node.is_zookeeper?
    configure_zookeeper(<span class="ruby-ivar">@nodes</span>, <span class="ruby-ivar">@my_index</span>)
    init = !(<span class="ruby-ivar">@creds</span>.include?(<span class="ruby-string">&quot;keep_zookeeper_data&quot;</span>))
    start_zookeeper(init)
  end

  <span class="ruby-constant">ZKInterface</span>.init(my_node, <span class="ruby-ivar">@nodes</span>)

  commands = {
    <span class="ruby-string">&quot;load_balancer&quot;</span> =&gt; <span class="ruby-string">&quot;start_load_balancer&quot;</span>,
    <span class="ruby-string">&quot;memcache&quot;</span> =&gt; <span class="ruby-string">&quot;start_memcache&quot;</span>,
    <span class="ruby-string">&quot;db_master&quot;</span> =&gt; <span class="ruby-string">&quot;start_db_master&quot;</span>,
    <span class="ruby-string">&quot;db_slave&quot;</span> =&gt; <span class="ruby-string">&quot;start_db_slave&quot;</span>
  }

  jobs_to_run.each do |job|
    if commands.include?(job)
      <span class="ruby-constant">Djinn</span>.log_debug(&quot;About to run [#{commands[job]}]&quot;)
      send(commands[job].to_sym)
    end
  end

  <span class="ruby-comment"># create initial tables</span>
  if (my_node.is_db_master? || (defined?(is_priming_needed?) &amp;&amp; is_priming_needed?(my_node))) &amp;&amp; !restore_from_db?
    table = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">'table'</span>]
    prime_script = &quot;#{APPSCALE_HOME}/AppDB/#{table}/prime_#{table}.py&quot;
    retries = 10
    retval = 0
    while retries &gt; 0
      replication = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;replication&quot;</span>]
      <span class="ruby-constant">Djinn</span>.log_run(&quot;MASTER_IP='localhost' LOCAL_DB_IP='localhost' python2.6 #{prime_script} #{replication}; echo $? &gt; /tmp/retval&quot;)
      retval = `cat /tmp/retval`.to_i
      break if retval == 0
      <span class="ruby-constant">Djinn</span>.log_debug(&quot;Fail to create initial table. Retry #{retries} times.&quot;)
      <span class="ruby-constant">Kernel</span>.sleep(5)
      retries -= 1
    end
    if retval != 0
      <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;Fail to create initial table. Could not startup AppScale.&quot;</span>)
      exit(1)
    end
  end

  <span class="ruby-comment"># start soap server and pb server</span>
  if has_soap_server?(my_node)
    <span class="ruby-ivar">@state</span> = <span class="ruby-string">&quot;Starting up SOAP Server and PBServer&quot;</span>
    start_pbserver
    start_soap_server
    <span class="ruby-constant">HelperFunctions</span>.sleep_until_port_is_open(<span class="ruby-constant">HelperFunctions</span>.local_ip, <span class="ruby-constant">UserAppClient</span>::<span class="ruby-constant">SERVER_PORT</span>)
  end

  start_blobstore_server if my_node.is_appengine?

  start_rabbitmq_server
  <span class="ruby-comment"># for neptune jobs, start a place where they can save output to</span>
  <span class="ruby-comment"># also, since repo does health checks on the app engine apis, start it up there too</span>

  repo_ip = get_shadow.public_ip
  repo_private_ip = get_shadow.private_ip
  repo_ip = my_node.public_ip if my_node.is_appengine?
  repo_private_ip = my_node.private_ip if my_node.is_appengine?
  <span class="ruby-constant">Repo</span>.init(repo_ip, repo_private_ip,  @@secret)

  if my_node.is_shadow? or my_node.is_appengine?
    start_sisyphus
    <span class="ruby-constant">Repo</span>.start(get_login.public_ip, <span class="ruby-ivar">@userappserver_private_ip</span>)
  end

  <span class="ruby-comment"># TODO(cgb): replace this with something more generic, in case other neptune</span>
  <span class="ruby-comment"># jobs need it down the road</span>
  if my_node.is_babel_slave?
    start_babel_slave
  end

  <span class="ruby-comment"># appengine is started elsewhere</span>
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="convert_fqdns_to_ips-method" class="method-detail ">
        <a name="method-i-convert_fqdns_to_ips"></a>

        
        <div class="method-heading">
          <span class="method-name">convert_fqdns_to_ips</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>If running in a cloud environment, we may be dealing with public and
private FQDNs instead of IP addresses, which makes it hard to find out
which node is our node (since we find our node by IP). This method looks
through all the nodes we currently know of and converts any private FQDNs
we see to private IPs.</p>
          

          
          <div class="method-source-code"
            id="convert_fqdns_to_ips-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 1707</span>
def convert_fqdns_to_ips()
  if is_cloud?
    <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;In a cloud deployment, so converting FQDNs -&gt; IPs&quot;</span>)
  else
    <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;Not in a cloud deployment, so not converting FQDNs -&gt; IPs&quot;</span>)
    return
  end

  if <span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;hostname&quot;</span>] =~ /#{FQDN_REGEX}/
    begin
      <span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;hostname&quot;</span>] = <span class="ruby-constant">HelperFunctions</span>.convert_fqdn_to_ip(<span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;hostname&quot;</span>])
    rescue <span class="ruby-constant">Exception</span> =&gt; e
      <span class="ruby-constant">Djinn</span>.log_debug(&quot;Failed to convert main hostname #{@creds['hostname']} to public, might want to look into this?&quot;)
    end
  end
  
  <span class="ruby-ivar">@nodes</span>.each { |node|
    <span class="ruby-comment"># Resolve the private FQDN to a private IP, but don't resolve the public</span>
    <span class="ruby-comment"># FQDN, as that will just resolve to the private IP.</span>

    pri = node.private_ip
    if pri =~ /#{FQDN_REGEX}/
      begin
        node.private_ip = <span class="ruby-constant">HelperFunctions</span>.convert_fqdn_to_ip(pri)
      rescue <span class="ruby-constant">Exception</span> =&gt; e
        node.private_ip = node.public_ip
      end
    end

    <span class="ruby-constant">Djinn</span>.log_debug(&quot;This node has public ip #{node.public_ip} and private ip #{node.private_ip}&quot;)
  }
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="copy_app_to_local-method" class="method-detail ">
        <a name="method-i-copy_app_to_local"></a>

        
        <div class="method-heading">
          <span class="method-name">copy_app_to_local</span><span
            class="method-args">(appname)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Returns true on success, false otherwise</p>
          

          
          <div class="method-source-code"
            id="copy_app_to_local-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 2686</span>
def copy_app_to_local(appname)
  app_dir = &quot;/var/apps/#{appname}/app&quot;
  app_path = &quot;#{app_dir}/#{appname}.tar.gz&quot;

  if <span class="ruby-constant">File</span>.exists?(app_path)
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;I already have a copy of app #{appname} - won't grab it remotely&quot;)
    return true
  else
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;I don't have a copy of app #{appname} - will grab it remotely&quot;)
  end

  nodes_with_app = []
  loop {
    nodes_with_app = <span class="ruby-constant">ZKInterface</span>.get_app_hosters(appname)
    break if !nodes_with_app.empty?
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;Waiting for a node to have a copy of app #{appname}&quot;)
    <span class="ruby-constant">Kernel</span>.sleep(5)
  }

  <span class="ruby-comment"># Try 3 times on each node known to have this application</span>
  nodes_with_app.each { |node|
    ssh_key = node.ssh_key
    ip = node.public_ip
    tries = 3
    loop {
      <span class="ruby-constant">Djinn</span>.log_debug(&quot;Trying #{ip}:#{app_path} for the application&quot;)
      <span class="ruby-constant">Djinn</span>.log_run(&quot;scp -o StrictHostkeyChecking=no -i #{ssh_key} #{ip}:#{app_path} #{app_path}&quot;)
      if <span class="ruby-constant">File</span>.exist?(&quot;#{app_path}&quot;) == true
        <span class="ruby-constant">Djinn</span>.log_debug(&quot;Got a copy of #{appname} from #{ip}&quot;)
        return true 
      end
      <span class="ruby-constant">Djinn</span>.log_debug(&quot;ERROR: Unable to get the application from #{ip}:#{app_path}! scp failed.&quot;) 
      if tries &gt; 0
        <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;Trying again in 5 seconds&quot;</span>) 
        tries = tries - 1
        <span class="ruby-constant">Kernel</span>.sleep(5)
      else
        <span class="ruby-constant">Djinn</span>.log_debug(&quot;Giving up on node #{ip} for the application&quot;)
        break
      end
    }
  }
  <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;Unable to get the application from any node&quot;</span>)
  return false 
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="copy_encryption_keys-method" class="method-detail ">
        <a name="method-i-copy_encryption_keys"></a>

        
        <div class="method-heading">
          <span class="method-name">copy_encryption_keys</span><span
            class="method-args">(dest_node)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="copy_encryption_keys-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 2133</span>
def copy_encryption_keys(dest_node)
  ip = dest_node.private_ip
  ssh_key = dest_node.ssh_key

  <span class="ruby-constant">HelperFunctions</span>.sleep_until_port_is_open(ip, <span class="ruby-constant">SSH_PORT</span>)
  <span class="ruby-constant">Kernel</span>.sleep(3)

  if <span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;infrastructure&quot;</span>] == <span class="ruby-string">&quot;ec2&quot;</span> or <span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;infrastructure&quot;</span>] == <span class="ruby-string">&quot;hybrid&quot;</span> or <span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;infrastructure&quot;</span>] == <span class="ruby-string">&quot;euca&quot;</span>
    options = <span class="ruby-string">&quot;-o StrictHostkeyChecking=no -o NumberOfPasswordPrompts=0&quot;</span>
    enable_root_login = <span class="ruby-string">&quot;sudo cp /home/ubuntu/.ssh/authorized_keys /root/.ssh/&quot;</span>
    <span class="ruby-constant">Djinn</span>.log_run(&quot;ssh -i #{ssh_key} #{options} 2&gt;&amp;1 ubuntu@#{ip} '#{enable_root_login}'&quot;)
  end

  secret_key_loc = <span class="ruby-string">&quot;/etc/appscale/secret.key&quot;</span>
  cert_loc = <span class="ruby-string">&quot;/etc/appscale/certs/mycert.pem&quot;</span>
  key_loc = <span class="ruby-string">&quot;/etc/appscale/certs/mykey.pem&quot;</span>

  <span class="ruby-constant">HelperFunctions</span>.scp_file(secret_key_loc, secret_key_loc, ip, ssh_key)
  <span class="ruby-constant">HelperFunctions</span>.scp_file(cert_loc, cert_loc, ip, ssh_key)
  <span class="ruby-constant">HelperFunctions</span>.scp_file(key_loc, key_loc, ip, ssh_key)

  <span class="ruby-comment"># TODO: should be able to merge these together</span>
  if is_hybrid_cloud?
    cloud_num = 1
    loop {
      cloud_type = <span class="ruby-ivar">@creds</span>[&quot;CLOUD#{cloud_num}_TYPE&quot;]
      break if cloud_type.nil? or cloud_type == <span class="ruby-string">&quot;&quot;</span>
      cloud_keys_dir = <span class="ruby-constant">File</span>.expand_path(&quot;/etc/appscale/keys/cloud#{cloud_num}&quot;)
      make_dir = &quot;mkdir -p #{cloud_keys_dir}&quot;

      keyname = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;keyname&quot;</span>]
      cloud_ssh_key = &quot;#{cloud_keys_dir}/#{keyname}.key&quot;
      cloud_private_key = &quot;#{cloud_keys_dir}/mykey.pem&quot;
      cloud_cert = &quot;#{cloud_keys_dir}/mycert.pem&quot;

      <span class="ruby-constant">HelperFunctions</span>.run_remote_command(ip, make_dir, ssh_key, <span class="ruby-constant">NO_OUTPUT</span>)
      <span class="ruby-constant">HelperFunctions</span>.scp_file(cloud_ssh_key, cloud_ssh_key, ip, ssh_key)
      <span class="ruby-constant">HelperFunctions</span>.scp_file(cloud_private_key, cloud_private_key, ip, ssh_key)
      <span class="ruby-constant">HelperFunctions</span>.scp_file(cloud_cert, cloud_cert, ip, ssh_key)
      cloud_num += 1
    }
  else
    cloud_keys_dir = <span class="ruby-constant">File</span>.expand_path(<span class="ruby-string">&quot;/etc/appscale/keys/cloud1&quot;</span>)
    make_dir = &quot;mkdir -p #{cloud_keys_dir}&quot;

    cloud_private_key = &quot;#{cloud_keys_dir}/mykey.pem&quot;
    cloud_cert = &quot;#{cloud_keys_dir}/mycert.pem&quot;

    <span class="ruby-constant">HelperFunctions</span>.run_remote_command(ip, make_dir, ssh_key, <span class="ruby-constant">NO_OUTPUT</span>)
    <span class="ruby-constant">HelperFunctions</span>.scp_file(ssh_key, ssh_key, ip, ssh_key)
    <span class="ruby-constant">HelperFunctions</span>.scp_file(cloud_private_key, cloud_private_key, ip, ssh_key)
    <span class="ruby-constant">HelperFunctions</span>.scp_file(cloud_cert, cloud_cert, ip, ssh_key)
  end
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="done_uploading-method" class="method-detail ">
        <a name="method-i-done_uploading"></a>

        
        <div class="method-heading">
          <span class="method-name">done_uploading</span><span
            class="method-args">(appname, location, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="done_uploading-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 738</span>
def done_uploading(appname, location, secret)
  if !valid_secret?(secret)
    return <span class="ruby-constant">BAD_SECRET_MSG</span>
  end

  if <span class="ruby-constant">File</span>.exists?(location)
    <span class="ruby-constant">ZKInterface</span>.add_app_entry(appname, my_node.serialize, location)
    result = <span class="ruby-string">&quot;success&quot;</span>
  else
    result = &quot;The #{appname} app was not found at #{location}.&quot;
  end

  <span class="ruby-constant">Djinn</span>.log_debug(result)
  return result
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="ensure_all_roles_are_running-method" class="method-detail ">
        <a name="method-i-ensure_all_roles_are_running"></a>

        
        <div class="method-heading">
          <span class="method-name">ensure_all_roles_are_running</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Each node has a responsibility to check up on other nodes and make sure
they are still running, and if not, to remedy it somehow. Returns an Array
of the roles that this process started.</p>
          

          
          <div class="method-source-code"
            id="ensure_all_roles_are_running-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 1556</span>
def ensure_all_roles_are_running
  <span class="ruby-comment"># Open nodes should be given priority to take on roles from other nodes.</span>
  <span class="ruby-comment"># if my node isnt open and there are open nodes, return</span>
  are_open_nodes = false
  <span class="ruby-ivar">@nodes</span>.each { |node|
    if node.is_open?
      are_open_nodes = true
      break
    end
  }

  if !my_node.is_open? and are_open_nodes
    <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;My node isn't open and other nodes are, so deferring &quot;</span> +
      <span class="ruby-string">&quot;cloud healing to other nodes&quot;</span>)
    return []
  end

  roles_to_add = []
  <span class="ruby-constant">ZKInterface</span>.lock_and_run {
    <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;Seeing if other roles need to be taken over&quot;</span>)

    ip_info = <span class="ruby-constant">ZKInterface</span>.get_ip_info()
    ip_info[<span class="ruby-string">'ips'</span>].each { |ip|
      <span class="ruby-constant">Djinn</span>.log_debug(&quot;Looking at roles for IP #{ip}&quot;)
      if !<span class="ruby-constant">ZKInterface</span>.is_node_done_loading?(ip)
        <span class="ruby-constant">Djinn</span>.log_debug(&quot;Node at IP #{ip} is not done loading yet, &quot; +
          <span class="ruby-string">&quot;skipping...&quot;</span>)
        next
      end

      if <span class="ruby-constant">ZKInterface</span>.is_node_live?(ip)
        <span class="ruby-constant">Djinn</span>.log_debug(&quot;Node at IP #{ip} appears to be up, skipping...&quot;)
        next
      else
        <span class="ruby-constant">Djinn</span>.log_debug(&quot;Node at IP #{ip} has failed&quot;)
          failed_job_data = <span class="ruby-constant">ZKInterface</span>.get_job_data_for_ip(ip)
          failed_node = <span class="ruby-constant">DjinnJobData</span>.deserialize(failed_job_data)
          roles_to_add &lt;&lt; failed_node.jobs

          instances_to_delete = <span class="ruby-constant">ZKInterface</span>.get_app_instances_for_ip(ip)
          uac = <span class="ruby-constant">UserAppClient</span>.new(<span class="ruby-ivar">@userappserver_private_ip</span>, @@secret)
          instances_to_delete.each { |instance|
            <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;Deleting app instance for app &quot;</span> +
              &quot;#{instance['app']} located at #{instance['ip']}:&quot; +
              &quot;#{instance['port']}&quot;)
            uac.delete_instance(instance[<span class="ruby-string">'app'</span>], instance[<span class="ruby-string">'ip'</span>], 
              instance[<span class="ruby-string">'port'</span>])
          }

          remove_node_from_local_and_zookeeper(ip)
          <span class="ruby-constant">Djinn</span>.log_debug(&quot;Will recover [#{failed_node.jobs.join(', ')}] &quot; +
            &quot; roles that were being run by the failed node at #{ip}&quot;)
      end
    }

    if !roles_to_add.empty?
      start_new_roles_on_nodes(roles_to_add, @@secret)
    end

    <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;Releasing ZK lock to see if other roles need to be &quot;</span> +
      <span class="ruby-string">&quot;taken over&quot;</span>)
  }

  return roles_to_add
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="find_me_in_locations-method" class="method-detail ">
        <a name="method-i-find_me_in_locations"></a>

        
        <div class="method-heading">
          <span class="method-name">find_me_in_locations</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Searches through @nodes to try to find out which node is ours. Strictly
speaking, we assume that our node is identifiable by private IP.</p>
          

          
          <div class="method-source-code"
            id="find_me_in_locations-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 1743</span>
def find_me_in_locations()
  <span class="ruby-ivar">@my_index</span> = nil
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;Searching for node index for #{HelperFunctions.local_ip}&quot;)
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;@nodes is #{@nodes.join(', ')}&quot;)
  <span class="ruby-ivar">@nodes</span>.each_index { |index|
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;Am I #{@nodes[index].private_ip}?&quot;)
    if <span class="ruby-ivar">@nodes</span>[index].private_ip == <span class="ruby-constant">HelperFunctions</span>.local_ip
      <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;Yes!&quot;</span>)
      <span class="ruby-ivar">@my_index</span> = index
      break
    end
    <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;No...&quot;</span>)
  }
  if <span class="ruby-ivar">@my_index</span>.nil?
    <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;I am lost, could not find my node&quot;</span>) 
  end
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="get_all_public_ips-method" class="method-detail ">
        <a name="method-i-get_all_public_ips"></a>

        
        <div class="method-heading">
          <span class="method-name">get_all_public_ips</span><span
            class="method-args">(secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="get_all_public_ips-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 643</span>
def get_all_public_ips(secret)
  if !valid_secret?(secret)
    return <span class="ruby-constant">BAD_SECRET_MSG</span>
  end

  public_ips = []
  <span class="ruby-ivar">@nodes</span>.each { |node|
    public_ips &lt;&lt; node.public_ip
  }
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;All public ips are [#{public_ips.join(', ')}]&quot;)
  return public_ips
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="get_db_master-method" class="method-detail ">
        <a name="method-i-get_db_master"></a>

        
        <div class="method-heading">
          <span class="method-name">get_db_master</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="get_db_master-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 958</span>
def get_db_master
  <span class="ruby-ivar">@nodes</span>.each { |node|
    return node if node.is_db_master?
  }

  abort(<span class="ruby-string">&quot;No db master nodes found.&quot;</span>)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="get_login-method" class="method-detail ">
        <a name="method-i-get_login"></a>

        
        <div class="method-heading">
          <span class="method-name">get_login</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="get_login-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 942</span>
def get_login
  <span class="ruby-ivar">@nodes</span>.each { |node|
    return node if node.is_login?
  }

  abort(<span class="ruby-string">&quot;No login nodes found.&quot;</span>)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="get_online_users_list-method" class="method-detail ">
        <a name="method-i-get_online_users_list"></a>

        
        <div class="method-heading">
          <span class="method-name">get_online_users_list</span><span
            class="method-args">(secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="get_online_users_list-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 720</span>
def get_online_users_list(secret)
  if !valid_secret?(secret)
    return <span class="ruby-constant">BAD_SECRET_MSG</span>
  end

  online_users = []

  login_node = get_login
  ip = login_node.public_ip
  key = login_node.ssh_key
  raw_list = `ssh -i #{key} -o StrictHostkeyChecking=no root@#{ip} 'ejabberdctl connected-users'`
  raw_list.split(<span class="ruby-string">&quot;\n&quot;</span>).each { |userdata|
    online_users &lt;&lt; userdata.split(<span class="ruby-string">&quot;/&quot;</span>)[0]
  }

  return online_users
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="get_public_ip-method" class="method-detail ">
        <a name="method-i-get_public_ip"></a>

        
        <div class="method-heading">
          <span class="method-name">get_public_ip</span><span
            class="method-args">(private_ip)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="get_public_ip-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 1054</span>
def get_public_ip(private_ip)
  return private_ip unless is_cloud?
  
  keyname = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;keyname&quot;</span>]
  infrastructure = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;infrastructure&quot;</span>]    

  if is_hybrid_cloud?
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;Getting hybrid ips with creds #{@creds.inspect}&quot;)
    public_ips, private_ips = <span class="ruby-constant">HelperFunctions</span>.get_hybrid_ips(<span class="ruby-ivar">@creds</span>)
  else
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;Getting cloud ips for #{infrastructure} with keyname #{keyname}&quot;)
    public_ips, private_ips = <span class="ruby-constant">HelperFunctions</span>.get_cloud_ips(infrastructure, keyname)
  end

  <span class="ruby-constant">Djinn</span>.log_debug(&quot;Public ips are #{public_ips.join(', ')}&quot;)
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;Private ips are #{private_ips.join(', ')}&quot;)
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;Looking for #{private_ip}&quot;)

  public_ips.each_index { |index|
    node_private_ip = <span class="ruby-constant">HelperFunctions</span>.convert_fqdn_to_ip(private_ips[index])
    node_public_ip = <span class="ruby-constant">HelperFunctions</span>.convert_fqdn_to_ip(public_ips[index])

    if node_private_ip == private_ip or node_public_ip == private_ip
      <span class="ruby-constant">Djinn</span>.log_debug(&quot;Mapped private ip #{private_ip} to public ip #{public_ips[index]}&quot;)
      return public_ips[index]
    end
  }

  unable_to_convert_msg = &quot;[get public ip] Couldn't convert private IP #{private_ip}&quot; + 
    &quot; to a public address. Public IPs are [#{public_ips.join(', ')}],&quot; + 
    &quot; private IPs are [#{private_ips.join(', ')}]&quot;

  abort(unable_to_convert_msg)  
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="get_role_info-method" class="method-detail ">
        <a name="method-i-get_role_info"></a>

        
        <div class="method-heading">
          <span class="method-name">get_role_info</span><span
            class="method-args">(secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>A SOAP-exposed method that callers can use to get information about what
roles each node in the AppScale deployment are running.</p>
          

          
          <div class="method-source-code"
            id="get_role_info-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 325</span>
def get_role_info(secret)
  if !valid_secret?(secret)
    return <span class="ruby-constant">BAD_SECRET_MSG</span>
  end

  all_nodes = []
  <span class="ruby-ivar">@nodes</span>.each { |node|
    all_nodes &lt;&lt; node.to_hash()
  }

  return all_nodes
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="get_shadow-method" class="method-detail ">
        <a name="method-i-get_shadow"></a>

        
        <div class="method-heading">
          <span class="method-name">get_shadow</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="get_shadow-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 950</span>
def get_shadow
  <span class="ruby-ivar">@nodes</span>.each { |node|
    return node if node.is_shadow?
  }

  abort(<span class="ruby-string">&quot;No shadow nodes found.&quot;</span>)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="get_stats-method" class="method-detail ">
        <a name="method-i-get_stats"></a>

        
        <div class="method-heading">
          <span class="method-name">get_stats</span><span
            class="method-args">(secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="get_stats-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 514</span>
def get_stats(secret)
  if !valid_secret?(secret)
    return <span class="ruby-constant">BAD_SECRET_MSG</span>
  end

  usage = <span class="ruby-constant">HelperFunctions</span>.get_usage
  mem = sprintf(<span class="ruby-string">&quot;%3.2f&quot;</span>, usage[<span class="ruby-string">'mem'</span>])

  jobs = my_node.jobs or [<span class="ruby-string">&quot;none&quot;</span>]
  <span class="ruby-comment"># don't use an actual % below, or it will cause a string format exception</span>
  stats = {
    <span class="ruby-string">'ip'</span> =&gt; my_node.public_ip,
    <span class="ruby-string">'cpu'</span> =&gt; usage[<span class="ruby-string">'cpu'</span>],
    <span class="ruby-string">'memory'</span> =&gt; mem,
    <span class="ruby-string">'disk'</span> =&gt; usage[<span class="ruby-string">'disk'</span>],
    <span class="ruby-string">'roles'</span> =&gt; jobs,
    <span class="ruby-string">'db_location'</span> =&gt; <span class="ruby-ivar">@userappserver_public_ip</span>,
    <span class="ruby-string">'cloud'</span> =&gt; my_node.cloud,
    <span class="ruby-string">'state'</span> =&gt; <span class="ruby-ivar">@state</span>
  }

  stats[<span class="ruby-string">'apps'</span>] = {}
  <span class="ruby-ivar">@app_names</span>.each { |name|
    stats[<span class="ruby-string">'apps'</span>][name] = <span class="ruby-ivar">@apps_loaded</span>.include?(name)
  }

  return stats
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="get_status-method" class="method-detail ">
        <a name="method-i-get_status"></a>

        
        <div class="method-heading">
          <span class="method-name">get_status</span><span
            class="method-args">(node)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="get_status-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 1089</span>
def get_status(node)
  ip = node.private_ip
  ssh_key = node.ssh_key
  acc = <span class="ruby-constant">AppControllerClient</span>.new(ip, @@secret)

  if !acc.is_done_loading?()
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;Node at #{ip} is not done loading yet - will try &quot; +
      <span class="ruby-string">&quot;again later.&quot;</span>)
    return
  end

  result = acc.get_status(ok_to_fail=true)
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;#{ip} returned [#{result}] - class is #{result.class}&quot;)

  if !result
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;#{ip} returned false - is it not running?&quot;)
    return
  end

  status_file = &quot;/etc/appscale/status-#{ip}.json&quot;
  stats = acc.get_stats()
  json_state = <span class="ruby-constant">JSON</span>.dump(stats) 
  <span class="ruby-constant">HelperFunctions</span>.write_file(status_file, json_state)

  if !my_node.is_login?
    login_ip = get_login.private_ip
    <span class="ruby-constant">HelperFunctions</span>.scp_file(status_file, status_file, login_ip, ssh_key)
  end

  <span class="ruby-comment"># copy remote log over - handy for debugging</span>
  local_log = &quot;#{APPSCALE_HOME}/.appscale/logs/#{ip}.log&quot;
  remote_log = <span class="ruby-string">&quot;/tmp/*.log&quot;</span>

  <span class="ruby-constant">FileUtils</span>.mkdir_p(&quot;#{APPSCALE_HOME}/.appscale/logs/&quot;)
  <span class="ruby-constant">Djinn</span>.log_run(&quot;scp -o StrictHostkeyChecking=no -i #{ssh_key} #{ip}:#{remote_log} #{local_log}&quot;)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="got_all_data-method" class="method-detail ">
        <a name="method-i-got_all_data"></a>

        
        <div class="method-heading">
          <span class="method-name">got_all_data</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="got_all_data-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 1694</span>
def got_all_data()
  return false if <span class="ruby-ivar">@nodes</span> == []
  return false if <span class="ruby-ivar">@creds</span> == {}
  return false if <span class="ruby-ivar">@app_names</span> == []
  return true
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="initialize_node-method" class="method-detail ">
        <a name="method-i-initialize_node"></a>

        
        <div class="method-heading">
          <span class="method-name">initialize_node</span><span
            class="method-args">(node)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="initialize_node-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 2107</span>
def initialize_node(node)
  copy_encryption_keys(node)
  validate_image(node)
  restore_db_state_if_needed(node)
  rsync_files(node)
  start_appcontroller(node)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="initialize_nodes_in_parallel-method" class="method-detail ">
        <a name="method-i-initialize_nodes_in_parallel"></a>

        
        <div class="method-heading">
          <span class="method-name">initialize_nodes_in_parallel</span><span
            class="method-args">(node_info)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="initialize_nodes_in_parallel-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 2096</span>
def initialize_nodes_in_parallel(node_info)
  threads = []
  node_info.each { |slave|
    threads &lt;&lt; <span class="ruby-constant">Thread</span>.new { 
      initialize_node(slave)
    }
  }

  threads.each { |t| t.join }
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="initialize_server-method" class="method-detail ">
        <a name="method-i-initialize_server"></a>

        
        <div class="method-heading">
          <span class="method-name">initialize_server</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Perform any necessary initialization steps before we begin starting up
services</p>
          

          
          <div class="method-source-code"
            id="initialize_server-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 2333</span>
def initialize_server
  my_public_ip = my_node.public_ip
  head_node_ip = get_public_ip(<span class="ruby-ivar">@creds</span>[<span class="ruby-string">'hostname'</span>])

  <span class="ruby-constant">HAProxy</span>.initialize_config
  <span class="ruby-constant">Nginx</span>.initialize_config
  <span class="ruby-constant">Collectd</span>.initialize_config(my_public_ip, head_node_ip)
  <span class="ruby-constant">Monitoring</span>.reset
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="is_app_running-method" class="method-detail ">
        <a name="method-i-is_app_running"></a>

        
        <div class="method-heading">
          <span class="method-name">is_app_running</span><span
            class="method-args">(appname, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="is_app_running-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 754</span>
def is_app_running(appname, secret)
  if !valid_secret?(secret)
    return <span class="ruby-constant">BAD_SECRET_MSG</span>
  end

  hosters = <span class="ruby-constant">ZKInterface</span>.get_app_hosters(appname)
  hosters_w_appengine = []
  hosters.each { |node|
    hosters_w_appengine &lt;&lt; node if node.is_appengine?
  }
 
  app_running = !hosters_w_appengine.empty?
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;Is app #{appname} running? #{app_running}&quot;)
  return app_running
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="is_cloud-3F-method" class="method-detail ">
        <a name="method-i-is_cloud-3F"></a>

        
        <div class="method-heading">
          <span class="method-name">is_cloud?</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="is_cloud-3F-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 2024</span>
def is_cloud?
  !<span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;infrastructure&quot;</span>].nil?
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="is_done_initializing-method" class="method-detail ">
        <a name="method-i-is_done_initializing"></a>

        
        <div class="method-heading">
          <span class="method-name">is_done_initializing</span><span
            class="method-args">(secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>A SOAP-exposed method that callers can use to determine if this node has
received information from another node and is starting up.</p>
          

          
          <div class="method-source-code"
            id="is_done_initializing-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 303</span>
def is_done_initializing(secret)
  if valid_secret?(secret)
    return <span class="ruby-ivar">@done_initializing</span>
  else
    return <span class="ruby-constant">BAD_SECRET_MSG</span>
  end
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="is_done_loading-method" class="method-detail ">
        <a name="method-i-is_done_loading"></a>

        
        <div class="method-heading">
          <span class="method-name">is_done_loading</span><span
            class="method-args">(secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>A SOAP-exposed method that callers use to determine if this node has
finished starting all the roles it should run when it initially starts.</p>
          

          
          <div class="method-source-code"
            id="is_done_loading-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 314</span>
def is_done_loading(secret)
  if valid_secret?(secret)
    return <span class="ruby-ivar">@done_loading</span>
  else
    return <span class="ruby-constant">BAD_SECRET_MSG</span>
  end
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="is_hybrid_cloud-3F-method" class="method-detail ">
        <a name="method-i-is_hybrid_cloud-3F"></a>

        
        <div class="method-heading">
          <span class="method-name">is_hybrid_cloud?</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="is_hybrid_cloud-3F-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 2016</span>
def is_hybrid_cloud?
  if <span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;infrastructure&quot;</span>].nil?
    false
  else
    <span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;infrastructure&quot;</span>] == <span class="ruby-string">&quot;hybrid&quot;</span>
  end
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="is_running-3F-method" class="method-detail ">
        <a name="method-i-is_running-3F"></a>

        
        <div class="method-heading">
          <span class="method-name">is_running?</span><span
            class="method-args">(name)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="is_running-3F-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 2382</span>
def is_running?(name)
  !`ps ax | grep #{name} | grep -v grep`.empty?
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="job_start-method" class="method-detail ">
        <a name="method-i-job_start"></a>

        
        <div class="method-heading">
          <span class="method-name">job_start</span><span
            class="method-args">(secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="job_start-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 656</span>
def job_start(secret)
  if !valid_secret?(secret)
    return <span class="ruby-constant">BAD_SECRET_MSG</span>
  end

  if restore_appcontroller_state 
    parse_creds
  else
    wait_for_data
    parse_creds
    change_job
  end
  
  <span class="ruby-ivar">@done_loading</span> = true
  write_our_node_info

  while !<span class="ruby-ivar">@kill_sig_received</span> do
    <span class="ruby-ivar">@state</span> = <span class="ruby-string">&quot;Done starting up AppScale, now in heartbeat mode&quot;</span>
    write_database_info
    write_zookeeper_locations
    write_neptune_info 
    update_api_status
    send_logs_to_sisyphus

    update_local_nodes

    if my_node.is_shadow?
      <span class="ruby-constant">Djinn</span>.log_debug(&quot;my node is #{my_node}&quot;)

      <span class="ruby-comment"># Since we now backup state to ZK, don't make everyone do it.</span>
      <span class="ruby-comment"># The Shadow has the most up-to-date info, so let it handle this</span>
      backup_appcontroller_state

      <span class="ruby-ivar">@nodes</span>.each { |node|
        get_status(node)
      }
      <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;Finished contacting all other nodes&quot;</span>)

      <span class="ruby-ivar">@neptune_nodes</span>.each { |node|
        <span class="ruby-constant">Djinn</span>.log_debug(&quot;Currently examining node [#{node}]&quot;)
        if node.should_extend?
          <span class="ruby-constant">Djinn</span>.log_debug(&quot;Extending time for node [#{node}]&quot;)
          node.extend_time
        elsif node.should_destroy?
          <span class="ruby-constant">Djinn</span>.log_debug(&quot;Time is up for node [#{node}] - destroying it&quot;)
          <span class="ruby-comment">#@nodes.delete(node)</span>
          <span class="ruby-comment">#@neptune_nodes.delete(node)</span>
          <span class="ruby-comment">##infrastructure = @creds[&quot;infrastructure&quot;]</span>
          <span class="ruby-comment">#HelperFunctions.terminate_vms([node], infrastructure)</span>
          <span class="ruby-comment">#FileUtils.rm_f(&quot;/etc/appscale/status-#{node.private_ip}.json&quot;)</span>
        end
      }
    else
      <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;No need to heartbeat, we aren't the shadow&quot;</span>)
    end

    ensure_all_roles_are_running

    <span class="ruby-comment"># TODO: consider only calling this if new apps are found</span>
    start_appengine
    <span class="ruby-constant">Kernel</span>.sleep(20)
  end
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="kill-method" class="method-detail ">
        <a name="method-i-kill"></a>

        
        <div class="method-heading">
          <span class="method-name">kill</span><span
            class="method-args">(secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="kill-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 339</span>
def kill(secret)
  if !valid_secret?(secret)
    return <span class="ruby-constant">BAD_SECRET_MSG</span>
  end
  <span class="ruby-ivar">@kill_sig_received</span> = true
  
  if is_hybrid_cloud? 
    <span class="ruby-constant">Thread</span>.new {
      <span class="ruby-constant">Kernel</span>.sleep(5)
      <span class="ruby-constant">HelperFunctions</span>.terminate_hybrid_vms(creds)
    }
  elsif is_cloud?
    <span class="ruby-constant">Thread</span>.new {
      <span class="ruby-constant">Kernel</span>.sleep(5)
      infrastructure = creds[<span class="ruby-string">&quot;infrastructure&quot;</span>]
      keyname = creds[<span class="ruby-string">&quot;keyname&quot;</span>]
      <span class="ruby-constant">HelperFunctions</span>.terminate_all_vms(infrastructure, keyname)
    }
  else
    <span class="ruby-comment"># in xen/kvm deployments we actually want to keep the boxes</span>
    <span class="ruby-comment"># turned on since that was the state they started in</span>

    stop_ejabberd if my_node.is_login?
    stop_sisyphus if my_node.is_appengine?
    <span class="ruby-constant">Repo</span>.stop if my_node.is_shadow? or my_node.is_appengine?

    jobs_to_run = my_node.jobs
    commands = {
      <span class="ruby-string">&quot;load_balancer&quot;</span> =&gt; <span class="ruby-string">&quot;stop_load_balancer&quot;</span>,
      <span class="ruby-string">&quot;appengine&quot;</span> =&gt; <span class="ruby-string">&quot;stop_appengine&quot;</span>,
      <span class="ruby-string">&quot;db_master&quot;</span> =&gt; <span class="ruby-string">&quot;stop_db_master&quot;</span>,
      <span class="ruby-string">&quot;db_slave&quot;</span> =&gt; <span class="ruby-string">&quot;stop_db_slave&quot;</span>,
      <span class="ruby-string">&quot;zookeeper&quot;</span> =&gt; <span class="ruby-string">&quot;stop_zookeeper&quot;</span>
    }

    my_node.jobs.each do |job|
      if commands.include?(job)
        <span class="ruby-constant">Djinn</span>.log_debug(&quot;About to run [#{commands[job]}]&quot;)
        send(commands[job].to_sym)
      else
        <span class="ruby-constant">Djinn</span>.log_debug(&quot;Unable to find command for job #{job}. Skipping it.&quot;)
      end
    end

    if has_soap_server?(my_node)
      stop_soap_server
      stop_pbserver
    end
  end

  <span class="ruby-constant">GodInterface</span>.shutdown
  <span class="ruby-constant">FileUtils</span>.rm_rf(<span class="ruby-constant">STATE_FILE</span>)
  return <span class="ruby-string">&quot;OK&quot;</span>  
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="load_neptune_info-method" class="method-detail ">
        <a name="method-i-load_neptune_info"></a>

        
        <div class="method-heading">
          <span class="method-name">load_neptune_info</span><span
            class="method-args">(file_to_load=NEPTUNE_INFO)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Loads Neptune data (stored in JSON format) into the instance variable
@neptune_info. Used to restore Neptune job data from a previously running
AppScale instance.</p>
          

          
          <div class="method-source-code"
            id="load_neptune_info-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 1178</span>
def load_neptune_info(file_to_load=<span class="ruby-constant">NEPTUNE_INFO</span>)
  if !<span class="ruby-constant">File</span>.exists?(file_to_load)
    <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;No neptune data found - no need to restore&quot;</span>)
    return
  end

  <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;Restoring neptune data!&quot;</span>)
  jobs_info = (<span class="ruby-constant">File</span>.open(file_to_load) { |f| f.read }).chomp
  jobs = []

  json_data = <span class="ruby-constant">JSON</span>.load(jobs_info)
  return if json_data.nil?
  num_jobs = json_data[<span class="ruby-string">&quot;num_jobs&quot;</span>]

  num_jobs.times { |i|
    info = json_data[&quot;job_#{i}&quot;]
    this_job = <span class="ruby-constant">NeptuneJobData</span>.from_hash(info)
    job_name = this_job.name

    if <span class="ruby-ivar">@neptune_jobs</span>[job_name].nil?
      <span class="ruby-ivar">@neptune_jobs</span>[job_name] = [this_job]
    else
      <span class="ruby-ivar">@neptune_jobs</span>[job_name] = [this_job]
    end
  }
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="my_node-method" class="method-detail ">
        <a name="method-i-my_node"></a>

        
        <div class="method-heading">
          <span class="method-name">my_node</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="my_node-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 2313</span>
def my_node()
  if <span class="ruby-ivar">@my_index</span>.nil?
    find_me_in_locations
  end

  if <span class="ruby-ivar">@my_index</span>.nil?
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;My index is nil - is nodes nil? #{@nodes.nil?}&quot;)
    if <span class="ruby-ivar">@nodes</span>.nil?
      <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;My nodes is nil also, timing error? race condition?&quot;</span>)
    else
      <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;Setting it to 0 position, even though it was not found&quot;</span>)
      <span class="ruby-comment"># pray its in the 0 position</span>
      return <span class="ruby-ivar">@nodes</span>[0]
    end
  end

  <span class="ruby-ivar">@nodes</span>[<span class="ruby-ivar">@my_index</span>]
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="parse_creds-method" class="method-detail ">
        <a name="method-i-parse_creds"></a>

        
        <div class="method-heading">
          <span class="method-name">parse_creds</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="parse_creds-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 1657</span>
def parse_creds
  got_data_msg = <span class="ruby-string">&quot;Got data from another node! DLoc = &quot;</span> +        &quot;#{@nodes.join(', ')}, #{@creds.inspect}, AppsToLoad = &quot; +        &quot;#{@app_names.join(', ')}&quot;
  <span class="ruby-constant">Djinn</span>.log_debug(got_data_msg)
      
  if <span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;appengine&quot;</span>]
    <span class="ruby-ivar">@num_appengines</span> = <span class="ruby-constant">Integer</span>(<span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;appengine&quot;</span>])
  end

  <span class="ruby-constant">Djinn</span>.log_debug(&quot;Keypath is #{@creds['keypath']}, keyname is #{@creds['keyname']}&quot;)

  if !<span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;keypath&quot;</span>].empty?
    my_key_dir = &quot;/etc/appscale/keys/#{my_node.cloud}&quot;
    my_key_loc = &quot;#{my_key_dir}/#{@creds['keypath']}&quot;
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;Creating directory #{my_key_dir} for my ssh key #{my_key_loc}&quot;)
    <span class="ruby-constant">FileUtils</span>.mkdir_p(my_key_dir)
    <span class="ruby-constant">Djinn</span>.log_run(&quot;cp /etc/appscale/ssh.key #{my_key_loc}&quot;)
  end
      
  if is_cloud?
    <span class="ruby-comment"># for euca</span>
    <span class="ruby-constant">ENV</span>[<span class="ruby-string">'EC2_ACCESS_KEY'</span>] = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;ec2_access_key&quot;</span>]
    <span class="ruby-constant">ENV</span>[<span class="ruby-string">'EC2_SECRET_KEY'</span>] = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;ec2_secret_key&quot;</span>]
    <span class="ruby-constant">ENV</span>[<span class="ruby-string">'EC2_URL'</span>] = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;ec2_url&quot;</span>]

    <span class="ruby-comment"># for ec2</span>
    cloud_keys_dir = <span class="ruby-constant">File</span>.expand_path(<span class="ruby-string">&quot;/etc/appscale/keys/cloud1&quot;</span>)
    <span class="ruby-constant">ENV</span>[<span class="ruby-string">'EC2_PRIVATE_KEY'</span>] = &quot;#{cloud_keys_dir}/mykey.pem&quot;
    <span class="ruby-constant">ENV</span>[<span class="ruby-string">'EC2_CERT'</span>] = &quot;#{cloud_keys_dir}/mycert.pem&quot;
  end

  write_database_info
  load_neptune_info
  write_neptune_info
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="post_logs_to_sisyphus-method" class="method-detail ">
        <a name="method-i-post_logs_to_sisyphus"></a>

        
        <div class="method-heading">
          <span class="method-name">post_logs_to_sisyphus</span><span
            class="method-args">(host, logs_to_push)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="post_logs_to_sisyphus-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 1450</span>
def post_logs_to_sisyphus(host, logs_to_push)
  this_component = {<span class="ruby-string">&quot;name&quot;</span> =&gt; <span class="ruby-string">&quot;AppController&quot;</span>, <span class="ruby-string">&quot;ip&quot;</span> =&gt; my_node.public_ip,
    <span class="ruby-string">&quot;logs&quot;</span> =&gt; logs_to_push}
  payload = {:body =&gt; {:payload =&gt; <span class="ruby-constant">JSON</span>.dump(this_component)}}

  begin
    send_response = <span class="ruby-constant">JSONClient</span>.post(&quot;http://#{host}/log&quot;, payload)
  rescue <span class="ruby-constant">Exception</span> =&gt; e
    <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;Posting to Sisyphus saw an exception of class &quot;</span> +
      &quot;#{e.class}&quot;)
    return false
  end

  <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;Done pushing logs to Sisyphus, received a response&quot;</span> +
    &quot; of #{send_response.inspect}&quot;)
  return true
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="remove_node_from_local_and_zookeeper-method" class="method-detail ">
        <a name="method-i-remove_node_from_local_and_zookeeper"></a>

        
        <div class="method-heading">
          <span class="method-name">remove_node_from_local_and_zookeeper</span><span
            class="method-args">(ip)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Removes information associated with the given IP address from our local
cache (@nodes) as well as the remote node storage mechanism (in ZooKeeper).</p>
          

          
          <div class="method-source-code"
            id="remove_node_from_local_and_zookeeper-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 1625</span>
def remove_node_from_local_and_zookeeper(ip)
  <span class="ruby-comment"># First, remove our local copy</span>
  index_to_remove = nil
  <span class="ruby-ivar">@nodes</span>.each_index { |i|
    if <span class="ruby-ivar">@nodes</span>[i].public_ip == ip
      index_to_remove = i
      break
    end
  }
  <span class="ruby-ivar">@nodes</span>.delete(<span class="ruby-ivar">@nodes</span>[index_to_remove])

  <span class="ruby-comment"># Then remove the remote copy</span>
  <span class="ruby-constant">ZKInterface</span>.remove_node_information(ip)
  <span class="ruby-constant">ZKInterface</span>.remove_ip_from_ip_list(ip)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="remove_role-method" class="method-detail ">
        <a name="method-i-remove_role"></a>

        
        <div class="method-heading">
          <span class="method-name">remove_role</span><span
            class="method-args">(old_role, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="remove_role-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 797</span>
def remove_role(old_role, secret)
  if !valid_secret?(secret)
    return <span class="ruby-constant">BAD_SECRET_MSG</span>
  end

  my_node.remove_roles(old_role)
  stop_roles = old_role.split(<span class="ruby-string">&quot;:&quot;</span>)
  stop_roles.each { |role|
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;Removing and stopping role #{role}&quot;)
    send(&quot;stop_#{role}&quot;.to_sym)
  }
  return <span class="ruby-string">&quot;OK&quot;</span>
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="restore_appcontroller_state-method" class="method-detail ">
        <a name="method-i-restore_appcontroller_state"></a>

        
        <div class="method-heading">
          <span class="method-name">restore_appcontroller_state</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Restores the state of each of the instance variables that the AppController
holds by pulling it from ZooKeeper (previously populated by the Shadow
node, who always has the most up-to-date version of this data).</p>
          

          
          <div class="method-source-code"
            id="restore_appcontroller_state-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 1234</span>
def restore_appcontroller_state()
  <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;Restoring AppController state from local file&quot;</span>)

  if !<span class="ruby-constant">File</span>.exists?(<span class="ruby-constant">ZK_LOCATIONS_FILE</span>)
    <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;No recovery data found - skipping recovery process&quot;</span>)
    return false
  end

  zookeeper_data = <span class="ruby-constant">HelperFunctions</span>.read_json_file(<span class="ruby-constant">ZK_LOCATIONS_FILE</span>)
  json_state = {}
  zookeeper_data[<span class="ruby-string">'locations'</span>].each { |ip|
    begin
      <span class="ruby-constant">Djinn</span>.log_debug(&quot;Restoring AppController state from ZK at #{ip}&quot;)
      <span class="ruby-constant">ZKInterface</span>.init_to_ip(my_node.public_ip, ip)
      json_state = <span class="ruby-constant">ZKInterface</span>.get_appcontroller_state()
    rescue <span class="ruby-constant">Exception</span> =&gt; e
      <span class="ruby-constant">Djinn</span>.log_debug(&quot;Saw exception of class #{e.class} from #{ip}, &quot; +
        <span class="ruby-string">&quot;trying next ZooKeeper node&quot;</span>)
      next
    end

    <span class="ruby-constant">Djinn</span>.log_debug(&quot;Got data #{json_state.inspect} successfully from #{ip}&quot;)
    break
  }

  @@secret = json_state[<span class="ruby-string">'@@secret'</span>]
  keyname = json_state[<span class="ruby-string">'@creds'</span>][<span class="ruby-string">'keyname'</span>]

  json_state.each { |k, v|
    next if k == <span class="ruby-string">&quot;@@secret&quot;</span>
    if k == <span class="ruby-string">&quot;@nodes&quot;</span>
      v = <span class="ruby-constant">Djinn</span>.convert_location_array_to_class(v, keyname)
    elsif k == <span class="ruby-string">&quot;@neptune_nodes&quot;</span>
      new_v = []

      v.each { |data|
        new_v &lt;&lt; <span class="ruby-constant">NeptuneJobData</span>.from_hash(data)
      }        

      v = new_v
    end

    instance_variable_set(k, v)
  }

  <span class="ruby-comment"># Now that we've restored our state, update the pointer that indicates</span>
  <span class="ruby-comment"># which node in @nodes is ours</span>
  find_me_in_locations

  return true
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="restore_db_state_if_needed-method" class="method-detail ">
        <a name="method-i-restore_db_state_if_needed"></a>

        
        <div class="method-heading">
          <span class="method-name">restore_db_state_if_needed</span><span
            class="method-args">(dest_node)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="restore_db_state_if_needed-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 2122</span>
def restore_db_state_if_needed(dest_node)
  return unless dest_node.is_db_master?
  return unless <span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;restore_from_tar&quot;</span>]

  ip = dest_node.private_ip
  ssh_key = dest_node.ssh_key
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;Restoring DB, copying data to DB master at #{ip}&quot;)
  db_tar_loc = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;restore_from_tar&quot;</span>]
  <span class="ruby-constant">HelperFunctions</span>.scp_file(db_tar_loc, db_tar_loc, ip, ssh_key)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="restore_from_db-3F-method" class="method-detail ">
        <a name="method-i-restore_from_db-3F"></a>

        
        <div class="method-heading">
          <span class="method-name">restore_from_db?</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="restore_from_db-3F-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 2028</span>
def restore_from_db?
  <span class="ruby-ivar">@creds</span>[<span class="ruby-string">'restore_from_tar'</span>] || <span class="ruby-ivar">@creds</span>[<span class="ruby-string">'restore_from_ebs'</span>]
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="rsync_files-method" class="method-detail ">
        <a name="method-i-rsync_files"></a>

        
        <div class="method-heading">
          <span class="method-name">rsync_files</span><span
            class="method-args">(dest_node)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="rsync_files-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 2188</span>
def rsync_files(dest_node)
  controller = &quot;#{APPSCALE_HOME}/AppController&quot;
  server = &quot;#{APPSCALE_HOME}/AppServer&quot;
  loadbalancer = &quot;#{APPSCALE_HOME}/AppLoadBalancer&quot;
  appdb = &quot;#{APPSCALE_HOME}/AppDB&quot;
  neptune = &quot;#{APPSCALE_HOME}/Neptune&quot;
  loki = &quot;#{APPSCALE_HOME}/Loki&quot;

  ssh_key = dest_node.ssh_key
  ip = dest_node.private_ip

  <span class="ruby-constant">Djinn</span>.log_run(&quot;rsync -e 'ssh -i #{ssh_key}' -arv #{controller}/* root@#{ip}:#{controller}&quot;)
  <span class="ruby-constant">Djinn</span>.log_run(&quot;rsync -e 'ssh -i #{ssh_key}' -arv --filter '- *.pyc' #{server}/* root@#{ip}:#{server}&quot;)
  <span class="ruby-constant">Djinn</span>.log_run(&quot;rsync -e 'ssh -i #{ssh_key}' -arv #{loadbalancer}/* root@#{ip}:#{loadbalancer}&quot;)
  <span class="ruby-constant">Djinn</span>.log_run(&quot;rsync -e 'ssh -i #{ssh_key}' -arv --exclude='logs/*' --exclude='hadoop-*' --exclude='hbase/hbase-*' --exclude='voldemort/voldemort/*' --exclude='cassandra/cassandra/*' #{appdb}/* root@#{ip}:#{appdb}&quot;)
  <span class="ruby-constant">Djinn</span>.log_run(&quot;rsync -e 'ssh -i #{ssh_key}' -arv #{neptune}/* root@#{ip}:#{neptune}&quot;)
  <span class="ruby-constant">Djinn</span>.log_run(&quot;rsync -e 'ssh -i #{ssh_key}' -arv #{loki}/* root@#{ip}:#{loki}&quot;)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="run_neptune_in_cloud-3F-method" class="method-detail ">
        <a name="method-i-run_neptune_in_cloud-3F"></a>

        
        <div class="method-heading">
          <span class="method-name">run_neptune_in_cloud?</span><span
            class="method-args">(neptune_info)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>TODO: add neptune file, which will have this function</p>
          

          
          <div class="method-source-code"
            id="run_neptune_in_cloud-3F-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 1127</span>
def run_neptune_in_cloud?(neptune_info)
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;Activecloud_info = #{neptune_info}&quot;)
  return true if is_cloud? &amp;&amp; !neptune_info[<span class="ruby-string">&quot;nodes&quot;</span>].nil?
  return true if !is_cloud? &amp;&amp; !neptune_info[<span class="ruby-string">&quot;nodes&quot;</span>].nil? &amp;&amp; !neptune_info[<span class="ruby-string">&quot;machine&quot;</span>].nil?
  return false
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="sanitize_credentials-method" class="method-detail ">
        <a name="method-i-sanitize_credentials"></a>

        
        <div class="method-heading">
          <span class="method-name">sanitize_credentials</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="sanitize_credentials-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 1775</span>
def sanitize_credentials()
  newcreds = {}
  <span class="ruby-ivar">@creds</span>.each { |key, val|
    newkey = key.gsub(<span class="ruby-regexp">/[^\w\d_@-]/</span>, <span class="ruby-string">&quot;&quot;</span>) unless key.nil?
    if newkey.include? <span class="ruby-string">&quot;_key&quot;</span>
      newval = val.gsub(<span class="ruby-regexp">/[^\w\d\.\+:\/_-]/</span>, <span class="ruby-string">&quot;&quot;</span>) unless val.nil?
    else
      newval = val.gsub(<span class="ruby-regexp">/[^\w\d\.:\/_-]/</span>, <span class="ruby-string">&quot;&quot;</span>) unless val.nil?
    end
    newcreds[newkey] = newval
  }
  return newcreds
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="send_logs_to_sisyphus-method" class="method-detail ">
        <a name="method-i-send_logs_to_sisyphus"></a>

        
        <div class="method-heading">
          <span class="method-name">send_logs_to_sisyphus</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>This method empties the logs buffer that this AppController has accumulated
and pushes the logs to Sisyphus, an App Engine app that displays logs from
various components. IMPORTANT: Don’t write logs in the loop below,
otherwise an infinite loop will be created (since you’re pulling off
items at the same rate that you’re pushing items onto it).</p>
          

          
          <div class="method-source-code"
            id="send_logs_to_sisyphus-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 1356</span>
def send_logs_to_sisyphus
  <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;Popping logs off of @@log_buffer to send to Sisyphus&quot;</span>)

  retries_left = 3
  begin
    if !<span class="ruby-constant">HelperFunctions</span>.is_port_open?(<span class="ruby-ivar">@userappserver_private_ip</span>,  
      <span class="ruby-constant">UserAppClient</span>::<span class="ruby-constant">SERVER_PORT</span>, <span class="ruby-constant">HelperFunctions</span>::<span class="ruby-constant">USE_SSL</span>)
      raise <span class="ruby-constant">Exception</span>
    end
  rescue <span class="ruby-constant">Exception</span> =&gt; except
    if retries_left &gt; 0
      <span class="ruby-constant">Djinn</span>.log_debug(&quot;Saw an exception of class #{except.class} when &quot; +
        <span class="ruby-string">&quot;trying to connect to UserAppServer - trying again shortly&quot;</span>)
      <span class="ruby-constant">Kernel</span>.sleep(5)
      retries_left -= 1
      retry
    else
      <span class="ruby-constant">Djinn</span>.log_debug(&quot;UserAppServer at #{@userappserver_private_ip} &quot; +
        <span class="ruby-string">&quot;does not appear to be up - will try again later.&quot;</span>)
      return
    end
  end

  uac = <span class="ruby-constant">UserAppClient</span>.new(<span class="ruby-ivar">@userappserver_private_ip</span>, @@secret)

  host = <span class="ruby-string">&quot;&quot;</span>
  loop {
    hosts = uac.get_hosts_for_app(<span class="ruby-string">&quot;sisyphus&quot;</span>)
    if hosts.length.zero?
      <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;Nobody is currently hosting the Sisyphus app - &quot;</span> +
        <span class="ruby-string">&quot;will try again later&quot;</span>)
    else
      host = hosts[rand(hosts.length)]
      break
    end
  }

  retries_left = 3
  begin
    ip, port = host.split(<span class="ruby-string">&quot;:&quot;</span>)
    if !<span class="ruby-constant">HelperFunctions</span>.is_port_open?(ip, port, 
      <span class="ruby-constant">HelperFunctions</span>::<span class="ruby-constant">DONT_USE_SSL</span>)
      raise <span class="ruby-constant">Exception</span>
    end
  rescue <span class="ruby-constant">Exception</span> =&gt; except
    if retries_left &gt; 0
      <span class="ruby-constant">Djinn</span>.log_debug(&quot;Saw an exception of class #{except.class} when &quot; +
        &quot;trying to connect to Sisyphus (#{ip}:#{port}) - trying again &quot; +
        <span class="ruby-string">&quot;shortly&quot;</span>)
      <span class="ruby-constant">Kernel</span>.sleep(5)
      retries_left -= 1
      retry
    else
      <span class="ruby-constant">Djinn</span>.log_debug(&quot;Sisyphus at #{ip}:#{port} does not appear to be &quot; +
        <span class="ruby-string">&quot;up - will try again later.&quot;</span>)
      return
    end
  end
 
  <span class="ruby-comment"># The first time around, we may not be registered with Sisyphus, so do</span>
  <span class="ruby-comment"># so now.</span>
  this_component = {<span class="ruby-string">&quot;name&quot;</span> =&gt; <span class="ruby-string">&quot;AppController&quot;</span>, <span class="ruby-string">&quot;ip&quot;</span> =&gt; my_node.public_ip}
  if !<span class="ruby-ivar">@registered_with_sisyphus</span>
    <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;Not registered with Sisyphus, doing so now&quot;</span>)
    payload = {<span class="ruby-string">&quot;payload&quot;</span> =&gt; <span class="ruby-constant">JSON</span>.dump({<span class="ruby-string">&quot;components&quot;</span> =&gt; [this_component]})}
    register_response = <span class="ruby-constant">JSONClient</span>.post(&quot;http://#{host}/component&quot;, 
      :body =&gt; <span class="ruby-string">''</span>, :query =&gt; payload)
    <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;Done registering with Sisyphus, received a response&quot;</span> +
      &quot; of #{register_response.inspect}&quot;)
    <span class="ruby-ivar">@registered_with_sisyphus</span> = true
  end

  <span class="ruby-comment"># If Sisyphus isn't ready for requests, it may reject requests, so send</span>
  <span class="ruby-comment"># it a dummy log to see if it's ready for us</span>
  if !post_logs_to_sisyphus(host, [{:text =&gt; <span class="ruby-string">&quot;Dummy log message&quot;</span>, 
    :timestamp =&gt; <span class="ruby-constant">Time</span>.now.to_i}])
    <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;Saw a problem pushing dummy log to Sisyphus - &quot;</span> + 
      <span class="ruby-string">&quot; will try again later.&quot;</span>)
    return
  end

  <span class="ruby-comment"># Now that we know that the Sisyphus app is up, dump our logs to it.</span>
  logs_to_push = []
  loop {
    break if @@log_buffer.empty?
    logs_to_push &lt;&lt; @@log_buffer.pop
  }
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;Sending #{logs_to_push.length} logs to Sisyphus&quot;)
 
  <span class="ruby-comment"># do a POST /logs</span>
  post_logs_to_sisyphus(host, logs_to_push)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="set_apps-method" class="method-detail ">
        <a name="method-i-set_apps"></a>

        
        <div class="method-heading">
          <span class="method-name">set_apps</span><span
            class="method-args">(app_names, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Validates and sets the list of applications that should be loaded on this
node.</p>
          

          
          <div class="method-source-code"
            id="set_apps-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 473</span>
def set_apps(app_names, secret)
  if !valid_secret?(secret)
    return <span class="ruby-constant">BAD_SECRET_MSG</span>
  end

  if app_names.class != <span class="ruby-constant">Array</span>
    return &quot;app names was not an Array but was a #{app_names.class}&quot;
  end

  <span class="ruby-ivar">@app_names</span> = app_names
  return &quot;App names is now #{@app_names.join(', ')}&quot;
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="set_parameters-method" class="method-detail ">
        <a name="method-i-set_parameters"></a>

        
        <div class="method-heading">
          <span class="method-name">set_parameters</span><span
            class="method-args">(djinn_locations, database_credentials, app_names, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Validates and sets the instance variables that <a
href="Djinn.html">Djinn</a> needs before it can begin configuring and
deploying services on a given node (and if it is the first <a
href="Djinn.html">Djinn</a>, starting up the other Djinns).</p>
          

          
          <div class="method-source-code"
            id="set_parameters-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 398</span>
def set_parameters(djinn_locations, database_credentials, app_names, secret)
  if !valid_secret?(secret)
    return <span class="ruby-constant">BAD_SECRET_MSG</span>
  end

  <span class="ruby-constant">Djinn</span>.log_debug(&quot;Djinn locations class: #{djinn_locations.class}&quot;)
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;DB Credentials class: #{database_credentials.class}&quot;)
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;Apps to load class: #{app_names.class}&quot;)

  if djinn_locations.class != <span class="ruby-constant">Array</span>
    msg = <span class="ruby-string">&quot;Error: djinn_locations wasn't an Array, but was a &quot;</span> +
      djinn_locations.class.to_s
    <span class="ruby-constant">Djinn</span>.log_debug(msg)
    return msg
  end

  if database_credentials.class != <span class="ruby-constant">Array</span>
    msg = <span class="ruby-string">&quot;Error: database_credentials wasn't an Array, but was a &quot;</span> +
      database_credentials.class.to_s
    <span class="ruby-constant">Djinn</span>.log_debug(msg)
    return msg
  end

  if app_names.class != <span class="ruby-constant">Array</span>
    msg = <span class="ruby-string">&quot;Error: app_names wasn't an Array, but was a &quot;</span> + 
      app_names.class.to_s
    <span class="ruby-constant">Djinn</span>.log_debug(msg)
    return msg
  end

  <span class="ruby-comment"># credentials is an array that we're converting to</span>
  <span class="ruby-comment"># hash tables, so we need to make sure that every key maps to a value</span>
  <span class="ruby-comment"># e.g., ['foo', 'bar'] becomes {'foo' =&gt; 'bar'}</span>
  <span class="ruby-comment"># so we need to make sure that the array has an even number of elements</span>
      
  if database_credentials.length % 2 != 0
    error_msg = <span class="ruby-string">&quot;Error: DB Credentials wasn't of even length: Len = &quot;</span> +          &quot;#{database_credentials.length}&quot;
    <span class="ruby-constant">Djinn</span>.log_debug(error_msg)
    return error_msg
  end

  possible_credentials = <span class="ruby-constant">Hash</span>[*database_credentials]
  if !valid_format_for_credentials(possible_credentials)
    return <span class="ruby-string">&quot;Error: Credential format wrong&quot;</span>
  end

  <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;Parameters were valid&quot;</span>)

  keyname = possible_credentials[<span class="ruby-string">&quot;keyname&quot;</span>]
  <span class="ruby-ivar">@nodes</span> = <span class="ruby-constant">Djinn</span>.convert_location_array_to_class(djinn_locations, keyname)
  <span class="ruby-ivar">@creds</span> = possible_credentials
  <span class="ruby-ivar">@app_names</span> = app_names
  
  convert_fqdns_to_ips
  <span class="ruby-ivar">@creds</span> = sanitize_credentials

  <span class="ruby-constant">Djinn</span>.log_debug(&quot;(set_parameters) locations: #{@nodes.join(', ')}&quot;)
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;(set_parameters) DB Credentials: #{HelperFunctions.obscure_creds(@creds).inspect}&quot;)
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;Apps to load: #{@app_names.join(', ')}&quot;)

  find_me_in_locations
  if <span class="ruby-ivar">@my_index</span>.nil?
    return <span class="ruby-string">&quot;Error: Couldn't find me in the node map&quot;</span>
  end
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;(set_parameters) My index = #{@my_index}&quot;)

  <span class="ruby-constant">ENV</span>[<span class="ruby-string">'EC2_URL'</span>] = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">'ec2_url'</span>]
  
  return <span class="ruby-string">&quot;OK&quot;</span>
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="set_uaserver_ips-method" class="method-detail ">
        <a name="method-i-set_uaserver_ips"></a>

        
        <div class="method-heading">
          <span class="method-name">set_uaserver_ips</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="set_uaserver_ips-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 1007</span>
def set_uaserver_ips()
  ip_addr = get_uaserver_ip()
  if !is_cloud?
    <span class="ruby-ivar">@userappserver_public_ip</span> = ip_addr
    <span class="ruby-ivar">@userappserver_private_ip</span> = ip_addr
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;\n\nUAServer is at [#{@userappserver_public_ip}]\n\n&quot;)
    return
  end
  
  keyname = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;keyname&quot;</span>]
  infrastructure = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;infrastructure&quot;</span>]    
 
  if is_hybrid_cloud?
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;Getting hybrid ips with creds #{@creds.inspect}&quot;)
    public_ips, private_ips = <span class="ruby-constant">HelperFunctions</span>.get_hybrid_ips(<span class="ruby-ivar">@creds</span>)
  else
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;Getting cloud ips for #{infrastructure} with keyname #{keyname}&quot;)
    public_ips, private_ips = <span class="ruby-constant">HelperFunctions</span>.get_cloud_ips(infrastructure, keyname)
  end
 
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;Public ips are #{public_ips.join(', ')}&quot;)
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;Private ips are #{private_ips.join(', ')}&quot;)
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;Looking for #{ip_addr}&quot;)

  public_ips.each_index { |index|
    node_public_ip = <span class="ruby-constant">HelperFunctions</span>.convert_fqdn_to_ip(public_ips[index])
    node_private_ip = <span class="ruby-constant">HelperFunctions</span>.convert_fqdn_to_ip(private_ips[index])

    if node_public_ip == ip_addr or node_private_ip == ip_addr
      <span class="ruby-comment"># don't set the uaserver_public_ip to node_public_ip, as then the tools</span>
      <span class="ruby-comment"># won't be able to resolve that ip (it may be the same as the </span>
      <span class="ruby-comment"># unresolvable private ip)</span>
      <span class="ruby-constant">Djinn</span>.log_debug(&quot;Setting uaserver public ip to #{public_ips[index]}&quot;)
      <span class="ruby-constant">Djinn</span>.log_debug(&quot;Setting uaserver private ip to #{node_private_ip}&quot;)
      <span class="ruby-ivar">@userappserver_public_ip</span> = public_ips[index]
      <span class="ruby-ivar">@userappserver_private_ip</span> = node_private_ip
      return
    end
  }

  unable_to_convert_msg = &quot;[get uaserver ip] Couldn't find out whether #{ip_addr} was &quot; + 
    <span class="ruby-string">&quot;a public or private IP address. Public IPs are &quot;</span> +
    &quot;[#{public_ips.join(', ')}], private IPs are [#{private_ips.join(', ')}]&quot;

  abort(unable_to_convert_msg)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="setup_config_files-method" class="method-detail ">
        <a name="method-i-setup_config_files"></a>

        
        <div class="method-heading">
          <span class="method-name">setup_config_files</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="setup_config_files-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 2207</span>
def setup_config_files()
  <span class="ruby-ivar">@state</span> = <span class="ruby-string">&quot;Setting up database configuration files&quot;</span>

  master_ip = []
  slave_ips = []

  <span class="ruby-comment"># load datastore helper</span>
  <span class="ruby-comment"># TODO: this should be the class or module</span>
  table = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">'table'</span>]
  <span class="ruby-comment"># require db_file</span>
  begin
    require &quot;#{APPSCALE_HOME}/AppDB/#{table}/#{table}_helper&quot;
  rescue <span class="ruby-constant">Exception</span> =&gt; e
    backtrace = e.backtrace.join(<span class="ruby-string">&quot;\n&quot;</span>)
    bad_datastore_msg = &quot;Unable to find #{table} helper.&quot; +          &quot; Please verify datastore type: #{e}\n#{backtrace}&quot;
    <span class="ruby-constant">Djinn</span>.log_debug(bad_datastore_msg)
    abort(bad_datastore_msg)
  end
  <span class="ruby-constant">FileUtils</span>.mkdir_p(&quot;#{APPSCALE_HOME}/AppDB/logs&quot;)

  <span class="ruby-ivar">@nodes</span>.each { |node| 
    master_ip = node.private_ip if node.jobs.include?(<span class="ruby-string">&quot;db_master&quot;</span>)
    slave_ips &lt;&lt; node.private_ip if node.jobs.include?(<span class="ruby-string">&quot;db_slave&quot;</span>)
  }

  <span class="ruby-constant">Djinn</span>.log_debug(&quot;Master is at #{master_ip}, slaves are at #{slave_ips.join(', ')}&quot;)

  my_public = my_node.public_ip
  <span class="ruby-constant">HelperFunctions</span>.write_file(&quot;#{APPSCALE_HOME}/.appscale/my_public_ip&quot;, &quot;#{my_public}\n&quot;)

  my_private = my_node.private_ip
  <span class="ruby-constant">HelperFunctions</span>.write_file(&quot;#{APPSCALE_HOME}/.appscale/my_private_ip&quot;, &quot;#{my_private}\n&quot;)
 
  head_node_ip = get_public_ip(<span class="ruby-ivar">@creds</span>[<span class="ruby-string">'hostname'</span>])
  <span class="ruby-constant">HelperFunctions</span>.write_file(&quot;#{APPSCALE_HOME}/.appscale/head_node_ip&quot;, &quot;#{head_node_ip}\n&quot;)

  login_ip = get_login.public_ip
  <span class="ruby-constant">HelperFunctions</span>.write_file(&quot;#{APPSCALE_HOME}/.appscale/login_ip&quot;, &quot;#{login_ip}\n&quot;)
  
  masters_file = &quot;#{APPSCALE_HOME}/.appscale/masters&quot;
  <span class="ruby-constant">HelperFunctions</span>.write_file(masters_file, &quot;#{master_ip}\n&quot;)

  if <span class="ruby-ivar">@total_boxes</span> == 1
    slave_ips = [ <span class="ruby-ivar">@creds</span>[<span class="ruby-string">'hostname'</span>] ]
  end
  
  slave_ips_newlined = slave_ips.join(<span class="ruby-string">&quot;\n&quot;</span>)
  <span class="ruby-constant">HelperFunctions</span>.write_file(&quot;#{APPSCALE_HOME}/.appscale/slaves&quot;, &quot;#{slave_ips_newlined}\n&quot;)

  <span class="ruby-comment"># n = @creds[&quot;replication&quot;]</span>

  <span class="ruby-comment"># setup_hadoop_config(template_loc, hadoop_hbase_loc, master_ip, slave_ips, n)</span>

  <span class="ruby-comment"># Invoke datastore helper function</span>
  setup_db_config_files(master_ip, slave_ips, <span class="ruby-ivar">@creds</span>)

  all_nodes = <span class="ruby-string">&quot;&quot;</span>
  <span class="ruby-ivar">@nodes</span>.each_with_index { |node, index|
    all_nodes &lt;&lt; &quot;#{node.private_ip} appscale-image#{index}\n&quot;
  }
  
  etc_hosts = <span class="ruby-string">&quot;/etc/hosts&quot;</span>
  my_hostname = &quot;appscale-image#{@my_index}&quot;
  etc_hostname = <span class="ruby-string">&quot;/etc/hostname&quot;</span>

  new_etc_hosts = <span class="ruby-string">127.0.0.1 localhost.localdomain localhost127.0.1.1 localhost::1     ip6-localhost ip6-loopbackfe00::0 ip6-localnetff00::0 ip6-mcastprefixff02::1 ip6-allnodesff02::2 ip6-allroutersff02::3 ip6-allhosts#{all_nodes}</span>

  <span class="ruby-constant">File</span>.open(etc_hosts, <span class="ruby-string">&quot;w+&quot;</span>) { |file| file.write(new_etc_hosts) }    
  <span class="ruby-constant">File</span>.open(etc_hostname, <span class="ruby-string">&quot;w+&quot;</span>) { |file| file.write(my_hostname) }

  <span class="ruby-comment"># on ubuntu jaunty, we can change the hostname by running hostname.sh</span>
  <span class="ruby-comment"># on karmic, this file doesn't exist - run /bin/hostname instead</span>
  <span class="ruby-comment"># TODO: does the fix for karmic hold for lucid?</span>

  jaunty_hostname_file = <span class="ruby-string">&quot;/etc/init.d/hostname.sh&quot;</span>

  if <span class="ruby-constant">File</span>.exists?(jaunty_hostname_file)
    <span class="ruby-constant">Djinn</span>.log_run(<span class="ruby-string">&quot;/etc/init.d/hostname.sh&quot;</span>)
  else
    <span class="ruby-constant">Djinn</span>.log_run(&quot;/bin/hostname #{my_hostname}&quot;)
  end

  <span class="ruby-comment"># use iptables to lock down outside traffic</span>
  <span class="ruby-comment"># nodes can talk to each other on any port</span>
  <span class="ruby-comment"># but only the outside world on certain ports</span>
  <span class="ruby-comment">#`iptables --flush`</span>
  if <span class="ruby-constant">FIREWALL_IS_ON</span>
    <span class="ruby-constant">Djinn</span>.log_run(&quot;bash #{APPSCALE_HOME}/firewall.conf&quot;)
  end
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="setup_hadoop_config_org-method" class="method-detail ">
        <a name="method-i-setup_hadoop_config_org"></a>

        
        <div class="method-heading">
          <span class="method-name">setup_hadoop_config_org</span><span
            class="method-args">(source_dir, dest_dir, master_ip, slave_ips, n)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>TODO: this function should use hadoop_helper</p>
          

          
          <div class="method-source-code"
            id="setup_hadoop_config_org-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 2442</span>
def setup_hadoop_config_org(source_dir, dest_dir, master_ip, slave_ips, n)
  [<span class="ruby-string">&quot;source_dir&quot;</span>, <span class="ruby-string">&quot;dest_dir&quot;</span>, <span class="ruby-string">&quot;master_ip&quot;</span>].each { |param_name|
    param = eval(param_name)
    abort(&quot;#{param_name} wasn't a String. It was a/an #{param.class}&quot;) if param.class != <span class="ruby-constant">String</span>
  }

  source_dir = <span class="ruby-constant">File</span>.expand_path(source_dir)
  dest_dir = <span class="ruby-constant">File</span>.expand_path(dest_dir)

  abort(&quot;Source dir [#{source_dir}] didn't exist&quot;) unless <span class="ruby-constant">File</span>.directory?(source_dir)
  abort(&quot;Dest dir [#{dest_dir}] didn't exist&quot;) unless <span class="ruby-constant">File</span>.directory?(dest_dir)

  files_to_config = `ls #{source_dir}`.split
  files_to_config.each{ |filename|
    full_path_to_read = source_dir + <span class="ruby-constant">File</span>::<span class="ruby-constant">Separator</span> + filename
    full_path_to_write = dest_dir + <span class="ruby-constant">File</span>::<span class="ruby-constant">Separator</span> + filename
    <span class="ruby-constant">File</span>.open(full_path_to_read) { |source_file|
      contents = source_file.read
      contents.gsub!(<span class="ruby-regexp">/APPSCALE-MASTER/</span>, master_ip)
      contents.gsub!(<span class="ruby-regexp">/APPSCALE-SLAVES/</span>, slave_ips.join(<span class="ruby-string">&quot;\n&quot;</span>))
      contents.gsub!(<span class="ruby-regexp">/REPLICATION/</span>, n)

      <span class="ruby-constant">HelperFunctions</span>.write_file(full_path_to_write, contents)
    }
  }
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="spawn_and_setup_appengine-method" class="method-detail ">
        <a name="method-i-spawn_and_setup_appengine"></a>

        
        <div class="method-heading">
          <span class="method-name">spawn_and_setup_appengine</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="spawn_and_setup_appengine-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 2032</span>
def spawn_and_setup_appengine()
  <span class="ruby-comment"># should also make sure the tools are on the vm and the envvars are set</span>

  table = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">'table'</span>]

  nodes = <span class="ruby-constant">HelperFunctions</span>.deserialize_info_from_tools(<span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;ips&quot;</span>])
  appengine_info = spawn_appengine(nodes)

  <span class="ruby-ivar">@state</span> = <span class="ruby-string">&quot;Copying over needed files and starting the AppController on the other VMs&quot;</span>
  
  keyname = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;keyname&quot;</span>] 
  appengine_info = <span class="ruby-constant">Djinn</span>.convert_location_array_to_class(appengine_info, keyname)
  <span class="ruby-ivar">@nodes</span>.concat(appengine_info)
  write_database_info
  
  creds = <span class="ruby-ivar">@creds</span>.to_a.flatten
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;Djinn locations: #{@nodes.join(', ')}&quot;)
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;DB Credentials: #{@creds.inspect}&quot;)
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;Apps to load: #{@app_names.join(', ')}&quot;)

  <span class="ruby-constant">Djinn</span>.log_debug(&quot;Appengine info: #{appengine_info}&quot;)
  initialize_nodes_in_parallel(appengine_info)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="spawn_appengine-method" class="method-detail ">
        <a name="method-i-spawn_appengine"></a>

        
        <div class="method-heading">
          <span class="method-name">spawn_appengine</span><span
            class="method-args">(nodes)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="spawn_appengine-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 2056</span>
def spawn_appengine(nodes)
  appengine_info = []
  if nodes.length &gt; 0
    if is_hybrid_cloud?
      num_of_vms_needed = nodes.length
      <span class="ruby-ivar">@state</span> = <span class="ruby-string">&quot;Spawning up hybrid virtual machines&quot;</span>
      appengine_info = <span class="ruby-constant">HelperFunctions</span>.spawn_hybrid_vms(<span class="ruby-ivar">@creds</span>, nodes)
    elsif is_cloud?
      num_of_vms_needed = nodes.length
      machine = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;machine&quot;</span>]
      <span class="ruby-constant">ENV</span>[<span class="ruby-string">'EC2_URL'</span>] = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;ec2_url&quot;</span>]
      instance_type = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;instance_type&quot;</span>]
      keyname = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;keyname&quot;</span>]
      infrastructure = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;infrastructure&quot;</span>]
      group = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;group&quot;</span>]

      <span class="ruby-ivar">@state</span> = &quot;Spawning up #{num_of_vms_needed} virtual machines&quot;
      roles = nodes.values

      <span class="ruby-comment"># since there's only one cloud, call it cloud1 to tell us</span>
      <span class="ruby-comment"># to use the first ssh key (the only key)</span>
      <span class="ruby-constant">HelperFunctions</span>.set_creds_in_env(<span class="ruby-ivar">@creds</span>, <span class="ruby-string">&quot;1&quot;</span>)
      appengine_info = <span class="ruby-constant">HelperFunctions</span>.spawn_vms(num_of_vms_needed, roles, 
        machine, instance_type, keyname, infrastructure, <span class="ruby-string">&quot;cloud1&quot;</span>, group)
    else
      nodes.each_pair do |ip,roles|
        <span class="ruby-comment"># for xen the public and private ips are the same</span>
        <span class="ruby-comment"># and we call it cloud1 since the first key (only key)</span>
        <span class="ruby-comment"># is the key to use</span>

        info = &quot;#{ip}:#{ip}:#{roles}:i-SGOOBARZ:cloud1&quot;
        appengine_info &lt;&lt; info
        <span class="ruby-constant">Djinn</span>.log_debug(&quot;Received appengine info: #{info}&quot;)
      end
    end
  end

  return appengine_info
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="start_appcontroller-method" class="method-detail ">
        <a name="method-i-start_appcontroller"></a>

        
        <div class="method-heading">
          <span class="method-name">start_appcontroller</span><span
            class="method-args">(node)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="start_appcontroller-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 2343</span>
def start_appcontroller(node)
  ip = node.private_ip
  ssh_key = node.ssh_key

  remote_home = <span class="ruby-constant">HelperFunctions</span>.get_remote_appscale_home(ip, ssh_key)
  env = {<span class="ruby-string">'APPSCALE_HOME'</span> =&gt; remote_home}

  start = &quot;ruby #{remote_home}/AppController/djinnServer.rb&quot;
  stop = &quot;ruby #{remote_home}/AppController/terminate.rb&quot;

  <span class="ruby-comment"># remove any possible appcontroller state that may not have been</span>
  <span class="ruby-comment"># properly removed in non-cloud runs</span>
  remove_state = <span class="ruby-string">&quot;rm -rf /etc/appscale/appcontroller-state.json&quot;</span>
  <span class="ruby-constant">HelperFunctions</span>.run_remote_command(ip, remove_state, ssh_key, <span class="ruby-constant">NO_OUTPUT</span>)

  <span class="ruby-constant">GodInterface</span>.start_god(ip, ssh_key)
  <span class="ruby-constant">Kernel</span>.sleep(1)

  begin
    <span class="ruby-constant">GodInterface</span>.start(:controller, start, stop, <span class="ruby-constant">SERVER_PORT</span>, env, ip, ssh_key)
    <span class="ruby-constant">HelperFunctions</span>.sleep_until_port_is_open(ip, <span class="ruby-constant">SERVER_PORT</span>, <span class="ruby-constant">USE_SSL</span>)
  rescue <span class="ruby-constant">Exception</span> =&gt; except
    backtrace = except.backtrace.join(<span class="ruby-string">&quot;\n&quot;</span>)
    remote_start_msg = <span class="ruby-string">&quot;[remote_start] Unforeseen exception when &quot;</span> +          &quot;talking to #{ip}: #{except}\nBacktrace: #{backtrace}&quot;
    <span class="ruby-constant">Djinn</span>.log_debug(remote_start_msg)
    retry
  end
  
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;Sending data to #{ip}&quot;)
  acc = <span class="ruby-constant">AppControllerClient</span>.new(ip, @@secret)

  loc_array = <span class="ruby-constant">Djinn</span>.convert_location_class_to_array(<span class="ruby-ivar">@nodes</span>)
  credentials = <span class="ruby-ivar">@creds</span>.to_a.flatten

  result = acc.set_parameters(loc_array, credentials, <span class="ruby-ivar">@app_names</span>)
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;#{ip} responded with #{result}&quot;)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="start_appengine-method" class="method-detail ">
        <a name="method-i-start_appengine"></a>

        
        <div class="method-heading">
          <span class="method-name">start_appengine</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="start_appengine-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 2493</span>
def start_appengine()
  <span class="ruby-ivar">@state</span> = <span class="ruby-string">&quot;Preparing to run AppEngine apps if needed&quot;</span>
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;Starting appengine - pbserver is at [#{@userappserver_private_ip}]&quot;)

  uac = <span class="ruby-constant">UserAppClient</span>.new(<span class="ruby-ivar">@userappserver_private_ip</span>, @@secret)

  if <span class="ruby-ivar">@restored</span> == false <span class="ruby-comment">#and restore_from_db?</span>
    <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;Need to restore&quot;</span>)
    app_list = uac.get_all_apps()
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;All apps are [#{app_list.join(', ')}]&quot;)
    app_list.each { |app|
      if uac.does_app_exist?(app) and !<span class="ruby-constant">RESTRICTED_APPS</span>.include?(app)
        <span class="ruby-constant">Djinn</span>.log_debug(&quot;App #{app} is enabled, so restoring it&quot;)
        <span class="ruby-ivar">@app_names</span> = <span class="ruby-ivar">@app_names</span> + [app]
      else
        <span class="ruby-constant">Djinn</span>.log_debug(&quot;App #{app} is not enabled, moving on&quot;)
      end
    }

    <span class="ruby-ivar">@app_names</span>.uniq!
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;Decided to restore these apps: [#{@app_names.join(', ')}]&quot;)
    <span class="ruby-ivar">@restored</span> = true
  else
    <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;Don't need to restore&quot;</span>)
  end

  apps_to_load = <span class="ruby-ivar">@app_names</span> - <span class="ruby-ivar">@apps_loaded</span> - [<span class="ruby-string">&quot;none&quot;</span>]
  apps_to_load.each { |app|
    app_data = uac.get_app_data(app)
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;Get app data for #{app} said [#{app_data}]&quot;)

    loop {
      app_version = app_data.scan(<span class="ruby-regexp">/version:(\d+)/</span>).flatten.to_s
      <span class="ruby-constant">Djinn</span>.log_debug(&quot;Waiting for app data to have instance info for app named #{app}: #{app_data}&quot;)
      <span class="ruby-constant">Djinn</span>.log_debug(&quot;The app's version is #{app_version}, and its class is #{app_version.class}&quot;)

      if app_data[0..4] != <span class="ruby-string">&quot;Error&quot;</span>
        app_version = <span class="ruby-string">&quot;0&quot;</span> if app_version == <span class="ruby-string">&quot;&quot;</span>
        app_version = <span class="ruby-constant">Integer</span>(app_version)
        break if app_version &gt;= 0
      end

      app_data = uac.get_app_data(app)
      <span class="ruby-constant">Kernel</span>.sleep(5)
    }

    my_public = my_node.public_ip
    my_private = my_node.private_ip
    app_version = app_data.scan(<span class="ruby-regexp">/version:(\d+)/</span>).flatten.to_s
    app_language = app_data.scan(<span class="ruby-regexp">/language:(\w+)/</span>).flatten.to_s
          
    <span class="ruby-comment"># TODO: merge these </span>
    shadow = get_shadow
    shadow_ip = shadow.private_ip
    ssh_key = shadow.ssh_key
    app_dir = &quot;/var/apps/#{app}/app&quot;
    app_path = &quot;#{app_dir}/#{app}.tar.gz&quot;
    <span class="ruby-constant">FileUtils</span>.mkdir_p(app_dir)
     
    copy_app_to_local(app)
    <span class="ruby-constant">HelperFunctions</span>.setup_app(app)

     
    if my_node.is_shadow?
      <span class="ruby-constant">CronHelper</span>.update_cron(my_public, app_language, app)
      start_xmpp_for_app(app, app_language)
    end

    if my_node.is_appengine?
      app_number = <span class="ruby-ivar">@nginx_port</span> - 8080
      start_port = <span class="ruby-constant">HelperFunctions</span>::<span class="ruby-constant">APP_START_PORT</span>
      static_handlers = <span class="ruby-constant">HelperFunctions</span>.parse_static_data(app)
      proxy_port = <span class="ruby-constant">HAProxy</span>.app_listen_port(app_number)
      login_ip = get_login.public_ip
      success = <span class="ruby-constant">Nginx</span>.write_app_config(app, app_number, my_public, proxy_port, static_handlers, login_ip)
      if not success
        <span class="ruby-constant">Djinn</span>.log_debug(&quot;ERROR: Failure to create valid nginx config file for application #{app}.&quot;)
        next
      end
      <span class="ruby-constant">HAProxy</span>.write_app_config(app, app_number, <span class="ruby-ivar">@num_appengines</span>, my_private)
      <span class="ruby-constant">Collectd</span>.write_app_config(app)

      <span class="ruby-comment"># send a warmup request to the app to get it loaded - can shave a</span>
      <span class="ruby-comment"># number of seconds off the initial request if it's java or go</span>
      <span class="ruby-comment"># go provides a default warmup route</span>
      <span class="ruby-comment"># TODO: if the user specifies a warmup route, call it instead of /</span>
      warmup_url = <span class="ruby-string">&quot;/&quot;</span>

      <span class="ruby-ivar">@num_appengines</span>.times { |index|
        app_true_port = start_port + app_number * <span class="ruby-ivar">@num_appengines</span> + index
        <span class="ruby-constant">Djinn</span>.log_debug(&quot;Starting #{app_language} app #{app} on #{HelperFunctions.local_ip}:#{app_true_port}&quot;)
        xmpp_ip = get_login.public_ip
        pid = <span class="ruby-constant">HelperFunctions</span>.run_app(app, app_true_port, <span class="ruby-ivar">@userappserver_private_ip</span>, my_public, my_private, app_version, app_language, <span class="ruby-ivar">@nginx_port</span>, xmpp_ip)
        if pid == -1
          <span class="ruby-constant">Djinn</span>.log_debug(&quot;ERROR: Unable to start application #{app}.&quot;) 
          next
        end
        pid_file_name = &quot;#{APPSCALE_HOME}/.appscale/#{app}-#{app_true_port}.pid&quot;
        <span class="ruby-constant">HelperFunctions</span>.write_file(pid_file_name, pid)

        location = &quot;http://#{my_public}:#{app_true_port}#{warmup_url}&quot;
        wget_cmd = &quot;wget --tries=1000 --no-check-certificate #{location} -q -O /dev/null&quot;
        <span class="ruby-constant">Djinn</span>.log_run(wget_cmd)
      }

      <span class="ruby-constant">Nginx</span>.reload
      <span class="ruby-constant">HAProxy</span>.reload
      <span class="ruby-constant">Collectd</span>.restart

      loop {
        <span class="ruby-constant">Kernel</span>.sleep(5)
        success = uac.add_instance(app, my_public, <span class="ruby-ivar">@nginx_port</span>)
        <span class="ruby-constant">Djinn</span>.log_debug(&quot;Add instance returned #{success}&quot;)
        if success  
          <span class="ruby-comment"># tell ZK that we are hosting the app in case we die, so that</span>
          <span class="ruby-comment"># other nodes can update the UserAppServer on its behalf</span>
          <span class="ruby-constant">ZKInterface</span>.add_app_instance(app, my_public, <span class="ruby-ivar">@nginx_port</span>)
          break
        end
      }

      nginx = <span class="ruby-ivar">@nginx_port</span>
      haproxy = <span class="ruby-ivar">@haproxy_port</span>
      login_ip = get_login.public_ip

      <span class="ruby-constant">Thread</span>.new {
        haproxy_location = &quot;http://#{my_public}:#{haproxy}#{warmup_url}&quot;
        nginx_location = &quot;http://#{my_public}:#{nginx}#{warmup_url}&quot;

        wget_haproxy = &quot;wget --tries=1000 --no-check-certificate #{haproxy_location} -q -O /dev/null&quot;
        wget_nginx = &quot;wget --tries=1000 --no-check-certificate #{nginx_location} -q -O /dev/null&quot;

        <span class="ruby-constant">Djinn</span>.log_run(wget_haproxy)
        <span class="ruby-constant">Djinn</span>.log_run(wget_nginx)
      }

      <span class="ruby-ivar">@nginx_port</span> += 1
      <span class="ruby-ivar">@haproxy_port</span> += 1

      <span class="ruby-comment"># now doing this at the real end so that the tools will</span>
      <span class="ruby-comment"># wait for the app to actually be running before returning</span>
      done_uploading(app, app_path, @@secret)
    end

    <span class="ruby-constant">Monitoring</span>.restart if my_node.is_shadow?

    if <span class="ruby-ivar">@app_names</span>.include?(<span class="ruby-string">&quot;none&quot;</span>)
      <span class="ruby-ivar">@apps_loaded</span> = <span class="ruby-ivar">@apps_loaded</span> - [<span class="ruby-string">&quot;none&quot;</span>]
      <span class="ruby-ivar">@app_names</span> = <span class="ruby-ivar">@app_names</span> - [<span class="ruby-string">&quot;none&quot;</span>]
    end
      
    <span class="ruby-ivar">@apps_loaded</span> &lt;&lt; app
  }

  <span class="ruby-constant">Djinn</span>.log_debug(&quot;#{apps_to_load.size} apps loaded&quot;)  
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="start_blobstore_server-method" class="method-detail ">
        <a name="method-i-start_blobstore_server"></a>

        
        <div class="method-heading">
          <span class="method-name">start_blobstore_server</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="start_blobstore_server-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 1923</span>
def start_blobstore_server
  db_local_ip = <span class="ruby-ivar">@userappserver_private_ip</span>
  my_ip = my_node.public_ip
  <span class="ruby-constant">BlobServer</span>.start(db_local_ip, <span class="ruby-constant">PbServer</span>::<span class="ruby-constant">LISTEN_PORT_NO_SSL</span>, my_ip)
  <span class="ruby-constant">BlobServer</span>.is_running(db_local_ip)

  return true
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="start_ejabberd-method" class="method-detail ">
        <a name="method-i-start_ejabberd"></a>

        
        <div class="method-heading">
          <span class="method-name">start_ejabberd</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="start_ejabberd-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 2398</span>
def start_ejabberd()
  <span class="ruby-ivar">@state</span> = <span class="ruby-string">&quot;Starting up XMPP server&quot;</span>
  my_public = my_node.public_ip
  <span class="ruby-constant">Ejabberd</span>.stop
  <span class="ruby-constant">Djinn</span>.log_run(<span class="ruby-string">&quot;rm -f /var/lib/ejabberd/*&quot;</span>)
  <span class="ruby-constant">Ejabberd</span>.write_auth_script(my_public, @@secret)
  <span class="ruby-constant">Ejabberd</span>.write_config_file(my_public)
  <span class="ruby-constant">Ejabberd</span>.start
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="start_hadoop_org-method" class="method-detail ">
        <a name="method-i-start_hadoop_org"></a>

        
        <div class="method-heading">
          <span class="method-name">start_hadoop_org</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>TODO: this function should use hadoop_helper</p>
          

          
          <div class="method-source-code"
            id="start_hadoop_org-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 2470</span>
def start_hadoop_org()
  i = my_node
  return unless i.is_shadow? <span class="ruby-comment"># change this later to db_master</span>
  hadoop_home = <span class="ruby-constant">File</span>.expand_path(&quot;#{APPSCALE_HOME}/AppDB/hadoop-0.20.2/&quot;)
  <span class="ruby-constant">Djinn</span>.log_run(&quot;#{hadoop_home}/bin/hadoop namenode -format 2&gt;&amp;1&quot;)
  <span class="ruby-constant">Djinn</span>.log_run(&quot;#{hadoop_home}/bin/start-dfs.sh 2&gt;&amp;1&quot;)
  <span class="ruby-constant">Djinn</span>.log_run(&quot;python #{hadoop_home}/../wait_on_hadoop.py 2&gt;&amp;1&quot;)
  <span class="ruby-constant">Djinn</span>.log_run(&quot;#{hadoop_home}/bin/start-mapred.sh 2&gt;&amp;1&quot;)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="start_load_balancer-method" class="method-detail ">
        <a name="method-i-start_load_balancer"></a>

        
        <div class="method-heading">
          <span class="method-name">start_load_balancer</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="start_load_balancer-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 2412</span>
def start_load_balancer()
  <span class="ruby-ivar">@state</span> = <span class="ruby-string">&quot;Starting up Load Balancer&quot;</span>
  <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;Starting up Load Balancer&quot;</span>)

  my_ip = my_node.public_ip
  <span class="ruby-constant">HAProxy</span>.create_app_load_balancer_config(my_node.private_ip, <span class="ruby-constant">LoadBalancer</span>.proxy_port)
  <span class="ruby-constant">Nginx</span>.create_app_load_balancer_config(my_ip, <span class="ruby-constant">LoadBalancer</span>.proxy_port)
  <span class="ruby-constant">LoadBalancer</span>.start
  <span class="ruby-constant">Nginx</span>.restart
  <span class="ruby-constant">Collectd</span>.restart

  head_node_ip = get_public_ip(<span class="ruby-ivar">@creds</span>[<span class="ruby-string">'hostname'</span>])
  if my_ip == head_node_ip
    <span class="ruby-comment"># Only start monitoring on the head node</span>
    <span class="ruby-constant">HAProxy</span>.create_app_monitoring_config(my_node.private_ip, <span class="ruby-constant">Monitoring</span>.proxy_port)
    <span class="ruby-constant">Nginx</span>.create_app_monitoring_config(my_ip, <span class="ruby-constant">Monitoring</span>.proxy_port)
    <span class="ruby-constant">Nginx</span>.restart
    <span class="ruby-constant">Monitoring</span>.start
  end

  <span class="ruby-constant">LoadBalancer</span>.server_ports.each do |port|
    <span class="ruby-constant">HelperFunctions</span>.sleep_until_port_is_open(<span class="ruby-string">&quot;localhost&quot;</span>, port)
    begin
      <span class="ruby-constant">Net</span>::<span class="ruby-constant">HTTP</span>.get_response(&quot;localhost:#{port}&quot;, <span class="ruby-string">'/'</span>)
    rescue <span class="ruby-constant">SocketError</span>
    end
  end
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="start_memcache-method" class="method-detail ">
        <a name="method-i-start_memcache"></a>

        
        <div class="method-heading">
          <span class="method-name">start_memcache</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="start_memcache-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 2386</span>
def start_memcache()
  <span class="ruby-ivar">@state</span> = <span class="ruby-string">&quot;Starting up memcache&quot;</span>
  <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;Starting up memcache&quot;</span>)
  start_cmd = <span class="ruby-string">&quot;/usr/bin/memcached -d -m 32 -p 11211 -u root&quot;</span>
  stop_cmd = <span class="ruby-string">&quot;pkill memcached&quot;</span>
  <span class="ruby-constant">GodInterface</span>.start(:memcached, start_cmd, stop_cmd, [11211])
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="start_new_roles_on_nodes-method" class="method-detail ">
        <a name="method-i-start_new_roles_on_nodes"></a>

        
        <div class="method-heading">
          <span class="method-name">start_new_roles_on_nodes</span><span
            class="method-args">(nodes_needed, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Starts the given roles by using open nodes, spawning new nodes, or some
combination of the two. ‘nodes_needed’ should be an Array, where each 
item is an Array of the roles to start on each node.</p>
          

          
          <div class="method-source-code"
            id="start_new_roles_on_nodes-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 815</span>
def start_new_roles_on_nodes(nodes_needed, secret)
   if !valid_secret?(secret)
    return <span class="ruby-constant">BAD_SECRET_MSG</span>
  end

  if nodes_needed.class != <span class="ruby-constant">Array</span>
    return <span class="ruby-constant">BAD_INPUT_MSG</span>
  end

  <span class="ruby-constant">ZKInterface</span>.lock_and_run {
    num_of_vms_needed = nodes_needed.length
    vms_to_use = []

    <span class="ruby-ivar">@nodes</span>.each { |node|
      if node.is_open?
        vms_to_use &lt;&lt; node
        if vms_to_use.length == nodes_needed.length
          <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;Only using open nodes to run new roles&quot;</span>)
          break
        end
      end
    }

    vms_to_spawn = nodes_needed.length - vms_to_use.length
  
    if vms_to_spawn &gt; 0 and !is_cloud?
      <span class="ruby-constant">Djinn</span>.log_debug(&quot;Still need #{vms_to_spawn} more nodes, but we &quot; +
      <span class="ruby-string">&quot;aren't in a cloud environment, so we can't acquire more nodes - &quot;</span> +
      <span class="ruby-string">&quot;failing the caller's request.&quot;</span>)
      return <span class="ruby-constant">NOT_ENOUGH_OPEN_NODES</span>
    end

    if vms_to_spawn &gt; 0
      <span class="ruby-comment"># start up vms_to_spawn vms as open</span>
      <span class="ruby-comment"># initialize them and wait for them to start up</span>
      <span class="ruby-comment"># wait for them to finish loading</span>
      <span class="ruby-comment"># also, be sure to add them to @nodes</span>
    end
  
    nodes_needed.each_index { |i|
      <span class="ruby-constant">ZKInterface</span>.add_roles_to_node(nodes_needed[i], vms_to_use[i])
    }
  }

  return <span class="ruby-string">&quot;OK&quot;</span>
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="start_pbserver-method" class="method-detail ">
        <a name="method-i-start_pbserver"></a>

        
        <div class="method-heading">
          <span class="method-name">start_pbserver</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="start_pbserver-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 1984</span>
def start_pbserver
  db_master_ip = nil
  my_ip = my_node.public_ip
  <span class="ruby-ivar">@nodes</span>.each { |node|
    db_master_ip = node.private_ip if node.is_db_master?
  }
  abort(<span class="ruby-string">&quot;db master ip was nil&quot;</span>) if db_master_ip.nil?

  table = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">'table'</span>]
  zoo_connection = get_zk_connection_string(<span class="ruby-ivar">@nodes</span>)
  <span class="ruby-constant">PbServer</span>.start(db_master_ip, <span class="ruby-ivar">@userappserver_private_ip</span>, my_ip, table, zoo_connection)
  <span class="ruby-constant">HAProxy</span>.create_pbserver_config(my_node.private_ip, <span class="ruby-constant">PbServer</span>::<span class="ruby-constant">PROXY_PORT</span>, table)
  <span class="ruby-constant">Nginx</span>.create_pbserver_config(my_ip, <span class="ruby-constant">PbServer</span>::<span class="ruby-constant">PROXY_PORT</span>)
  <span class="ruby-constant">Nginx</span>.restart()

  <span class="ruby-comment"># TODO check the return value</span>
  <span class="ruby-constant">PbServer</span>.is_running(my_ip)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="start_rabbitmq_server-method" class="method-detail ">
        <a name="method-i-start_rabbitmq_server"></a>

        
        <div class="method-heading">
          <span class="method-name">start_rabbitmq_server</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Starts a <a href="RabbitMQ.html">RabbitMQ</a> server on this node if it has
either of the rabbitmq roles. Returns a boolean indicating whether or not a
server was started on this node.</p>
          

          
          <div class="method-source-code"
            id="start_rabbitmq_server-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 1936</span>
def start_rabbitmq_server()
  if my_node.is_rabbitmq_master?
    <span class="ruby-constant">RabbitMQ</span>.start_master()
    return true
  elsif my_node.is_rabbitmq_slave?
    <span class="ruby-comment"># All slaves connect to the master to start</span>
    master_ip = nil
    <span class="ruby-ivar">@nodes</span>.each { |node|
      master_ip = node.private_ip if node.is_rabbitmq_master?
    }

    <span class="ruby-constant">RabbitMQ</span>.start_slave(master_ip)
    return true
  end

  return false
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="start_shadow-method" class="method-detail ">
        <a name="method-i-start_shadow"></a>

        
        <div class="method-heading">
          <span class="method-name">start_shadow</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="start_shadow-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 2485</span>
def start_shadow()
  <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;Starting Shadow role&quot;</span>)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="start_sisyphus-method" class="method-detail ">
        <a name="method-i-start_sisyphus"></a>

        
        <div class="method-heading">
          <span class="method-name">start_sisyphus</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="start_sisyphus-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 2766</span>
def start_sisyphus
  <span class="ruby-comment"># its just another app engine app - but since numbering starts</span>
  <span class="ruby-comment"># at zero, this app has to be app neg two</span>

  <span class="ruby-comment"># TODO: tell the tools to disallow uploading apps called 'sisyphus'</span>
  <span class="ruby-comment"># and start_appengine to do the same</span>
  <span class="ruby-comment"># TODO: this code is copy-pasted from repo - should be a way to</span>
  <span class="ruby-comment"># extract this code to a helper function of some kind</span>

  <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;Starting Sisyphus&quot;</span>)

  num_servers = 3
  app_number = -2
  nginx_port = 8078
  start_port = 19994
  app = <span class="ruby-string">&quot;sisyphus&quot;</span>
  app_language = <span class="ruby-string">&quot;python&quot;</span>
  app_version = <span class="ruby-string">&quot;1&quot;</span>

  app_location = &quot;/var/apps/#{app}/app&quot;
  <span class="ruby-constant">Djinn</span>.log_run(&quot;mkdir -p #{app_location}&quot;)
  <span class="ruby-constant">Djinn</span>.log_run(&quot;cp -r #{APPSCALE_HOME}/AppServer/demos/sisyphus/* #{app_location}&quot;)
  <span class="ruby-constant">HelperFunctions</span>.setup_app(app, untar=false)

  my_public = my_node.public_ip
  my_private = my_node.private_ip
  login_ip = get_login.public_ip

  static_handlers = <span class="ruby-constant">HelperFunctions</span>.parse_static_data(app)
  proxy_port = <span class="ruby-constant">HAProxy</span>.app_listen_port(app_number)
  <span class="ruby-constant">Nginx</span>.write_app_config(app, app_number, my_public, proxy_port, static_handlers, login_ip)
  <span class="ruby-constant">HAProxy</span>.write_app_config(app, app_number, num_servers, my_private)
  <span class="ruby-constant">Collectd</span>.write_app_config(app)

  [19994, 19995, 19996].each { |port|
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;Starting #{app_language} app #{app} on #{HelperFunctions.local_ip}:#{port}&quot;)
    pid = <span class="ruby-constant">HelperFunctions</span>.run_app(app, port, <span class="ruby-ivar">@userappserver_private_ip</span>, 
      my_public, my_public, app_version, app_language, nginx_port, login_ip)
    pid_file_name = &quot;#{APPSCALE_HOME}/.appscale/#{app}-#{port}.pid&quot;
    <span class="ruby-constant">HelperFunctions</span>.write_file(pid_file_name, pid)
  }

  <span class="ruby-constant">Nginx</span>.reload
  <span class="ruby-constant">Collectd</span>.restart

  <span class="ruby-comment"># Register the application with the UserAppServer so that we can use the</span>
  <span class="ruby-comment"># AppLoadBalancer to route traffic to it, or let clients query the UAServer</span>
  <span class="ruby-comment"># to see where it's hosted.</span>
  uac = <span class="ruby-constant">UserAppClient</span>.new(<span class="ruby-ivar">@userappserver_private_ip</span>, @@secret)
  cloud_admin = uac.get_cloud_admin()
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;Registering Sisyphus with cloud admin #{cloud_admin}&quot;)
  uac.commit_new_app_name(cloud_admin, app, app_language)

  loop {
    <span class="ruby-constant">Kernel</span>.sleep(5)
    success = uac.add_instance(app, my_public, nginx_port)
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;Add instance returned #{success}&quot;)
    break if success
  }

  <span class="ruby-ivar">@apps_loaded</span> &lt;&lt; <span class="ruby-string">&quot;sisyphus&quot;</span>
  <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;Done starting Sisyphus!&quot;</span>)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="start_soap_server-method" class="method-detail ">
        <a name="method-i-start_soap_server"></a>

        
        <div class="method-heading">
          <span class="method-name">start_soap_server</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="start_soap_server-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 1954</span>
def start_soap_server
  db_master_ip = nil
  <span class="ruby-ivar">@nodes</span>.each { |node|
    db_master_ip = node.private_ip if node.is_db_master?
  }
  abort(<span class="ruby-string">&quot;db master ip was nil&quot;</span>) if db_master_ip.nil?

  db_local_ip = <span class="ruby-ivar">@userappserver_private_ip</span>
          
  table = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">'table'</span>]

  env_vars = {}

  env_vars[<span class="ruby-string">'APPSCALE_HOME'</span>] = <span class="ruby-constant">APPSCALE_HOME</span>
  env_vars[<span class="ruby-string">'MASTER_IP'</span>] = db_master_ip
  env_vars[<span class="ruby-string">'LOCAL_DB_IP'</span>] = db_local_ip

  if table == <span class="ruby-string">&quot;simpledb&quot;</span>
    env_vars[<span class="ruby-string">'SIMPLEDB_ACCESS_KEY'</span>] = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">'SIMPLEDB_ACCESS_KEY'</span>]
    env_vars[<span class="ruby-string">'SIMPLEDB_SECRET_KEY'</span>] = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">'SIMPLEDB_SECRET_KEY'</span>]
  end

  start_cmd = [&quot;/usr/bin/python2.6 #{APPSCALE_HOME}/AppDB/soap_server.py&quot;,
          &quot;-t #{table} -s #{HelperFunctions.get_secret}&quot;].join(<span class="ruby-string">' '</span>)
  stop_cmd = <span class="ruby-string">&quot;pkill -9 soap_server&quot;</span>
  port = [4343]

  <span class="ruby-constant">GodInterface</span>.start(:uaserver, start_cmd, stop_cmd, port, env_vars)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="start_xmpp_for_app-method" class="method-detail ">
        <a name="method-i-start_xmpp_for_app"></a>

        
        <div class="method-heading">
          <span class="method-name">start_xmpp_for_app</span><span
            class="method-args">(app, app_language)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="start_xmpp_for_app-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 2732</span>
def start_xmpp_for_app(app, app_language)
  <span class="ruby-comment"># create xmpp account for the app</span>
  <span class="ruby-comment"># for app named baz, this translates to baz@login_ip</span>

  login_ip = get_login.public_ip
  login_uac = <span class="ruby-constant">UserAppClient</span>.new(login_ip, @@secret)
  xmpp_user = &quot;#{app}@#{login_ip}&quot;
  xmpp_pass = <span class="ruby-constant">HelperFunctions</span>.encrypt_password(xmpp_user, @@secret)
  login_uac.commit_new_user(xmpp_user, xmpp_pass, <span class="ruby-string">&quot;app&quot;</span>)

  <span class="ruby-constant">Djinn</span>.log_debug(&quot;Created user [#{xmpp_user}] with password [#{@@secret}] and hashed password [#{xmpp_pass}]&quot;)

  if <span class="ruby-constant">Ejabberd</span>.does_app_need_receive?(app, app_language)
    start_cmd = &quot;python #{APPSCALE_HOME}/AppController/xmpp_receiver.py #{app} #{login_ip} #{@@secret}&quot;
    stop_cmd = &quot;ps ax | grep '#{start_cmd}' | grep -v grep | awk '{print $1}' | xargs -d '\n' kill -9&quot;
    <span class="ruby-constant">GodInterface</span>.start(app, start_cmd, stop_cmd, 9999)
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;App #{app} does need xmpp receive functionality&quot;)
  else
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;App #{app} does not need xmpp receive functionality&quot;)
  end
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="status-method" class="method-detail ">
        <a name="method-i-status"></a>

        
        <div class="method-heading">
          <span class="method-name">status</span><span
            class="method-args">(secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="status-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 486</span>
def status(secret)
  if !valid_secret?(secret)
    return <span class="ruby-constant">BAD_SECRET_MSG</span>
  end

  stats = get_stats(secret)

  stats_str = <span class="ruby-string">    Currently using #{stats['cpu']} Percent CPU and #{stats['mem']} Percent Memory    Hard disk is #{stats['disk']} Percent full    Is currently: #{stats['roles'].join(', ')}    Database is at #{stats['db_location']}    Is in cloud: #{stats['cloud']}    Current State: #{stats['state']}</span>

  if my_node.is_appengine?
    app_names = []
    stats[<span class="ruby-string">'apps'</span>].each { |k, v|
      app_names &lt;&lt; k
    }

    stats_str &lt;&lt; &quot;    Hosting the following apps: #{app_names.join(', ')}&quot;
  end
 
  return stats_str
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="stop_app-method" class="method-detail ">
        <a name="method-i-stop_app"></a>

        
        <div class="method-heading">
          <span class="method-name">stop_app</span><span
            class="method-args">(app_name, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="stop_app-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 543</span>
def stop_app(app_name, secret)
  if !valid_secret?(secret)
    return <span class="ruby-constant">BAD_SECRET_MSG</span>
  end

  app_name.gsub!(<span class="ruby-regexp">/[^\w\d\-]/</span>, <span class="ruby-string">&quot;&quot;</span>)
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;(stop_app): Shutting down app named [#{app_name}]&quot;)
  result = <span class="ruby-string">&quot;&quot;</span>
  <span class="ruby-constant">Djinn</span>.log_run(&quot;rm -rf /var/apps/#{app_name}&quot;)
 
  <span class="ruby-comment"># app shutdown process can take more than 30 seconds</span>
  <span class="ruby-comment"># so run it in a new thread to avoid 'execution expired'</span>
  <span class="ruby-comment"># error messages and have the tools poll it </span>
  <span class="ruby-constant">Thread</span>.new {
    <span class="ruby-comment"># Tell other nodes to shutdown this application</span>
    if <span class="ruby-ivar">@app_names</span>.include?(app_name) and !my_node.is_appengine?
      <span class="ruby-ivar">@nodes</span>.each { |node|
        next if node.private_ip == my_node.private_ip
        if node.is_appengine? or node.is_login?
          ip = node.private_ip
          acc = <span class="ruby-constant">AppControllerClient</span>.new(ip, @@secret)
          result = acc.stop_app(app_name)
          <span class="ruby-constant">Djinn</span>.log_debug(&quot;(stop_app): Removing application #{app_name} --- #{ip} returned #{result} (#{result.class})&quot;)
        end
      }
    end

    <span class="ruby-comment"># Contact the soap server and remove the application</span>
    if (<span class="ruby-ivar">@app_names</span>.include?(app_name) and !my_node.is_appengine?) or <span class="ruby-ivar">@nodes</span>.length == 1
      ip = <span class="ruby-constant">HelperFunctions</span>.read_file(&quot;#{APPSCALE_HOME}/.appscale/masters&quot;)
      uac = <span class="ruby-constant">UserAppClient</span>.new(ip, @@secret)
      result = uac.delete_app(app_name)
      <span class="ruby-constant">Djinn</span>.log_debug(&quot;(stop_app) Delete app: #{ip} returned #{result} (#{result.class})&quot;)
    end
   
    <span class="ruby-comment"># may need to stop XMPP listener</span>
    if my_node.is_login? 
      pid_files = `ls #{APPSCALE_HOME}/.appscale/xmpp-#{app_name}.pid`.split
      unless pid_files.nil? <span class="ruby-comment"># not an error here - XMPP is optional</span>
        pid_files.each { |pid_file|
          pid = <span class="ruby-constant">HelperFunctions</span>.read_file(pid_file)
          <span class="ruby-constant">Djinn</span>.log_run(&quot;kill -9 #{pid}&quot;)
        }

        result = <span class="ruby-string">&quot;true&quot;</span>
      end
    end    

    if my_node.is_appengine?
      <span class="ruby-constant">GodInterface</span>.stop(app_name)
      <span class="ruby-constant">GodInterface</span>.remove(app_name)
      <span class="ruby-constant">Nginx</span>.remove_app(app_name)
      <span class="ruby-constant">Collectd</span>.remove_app(app_name)
      <span class="ruby-constant">HAProxy</span>.remove_app(app_name)
      <span class="ruby-constant">Nginx</span>.reload
      <span class="ruby-constant">Collectd</span>.restart
      <span class="ruby-constant">ZKInterface</span>.remove_app_entry(app_name)
      <span class="ruby-comment"># TODO God does not shut down the application, so do it here for </span>
      <span class="ruby-comment"># A temp fix.</span>
      <span class="ruby-constant">Djinn</span>.log_run(&quot;ps -ef | grep dev_appserver | grep #{app_name} | grep -v grep | grep cookie_secret | awk '{print $2}' | xargs kill -9&quot;)
      result = <span class="ruby-string">&quot;true&quot;</span>
    end

    <span class="ruby-ivar">@apps_loaded</span> = <span class="ruby-ivar">@apps_loaded</span> - [app_name]    
    <span class="ruby-ivar">@app_names</span> = <span class="ruby-ivar">@app_names</span> - [app_name]

    if <span class="ruby-ivar">@apps_loaded</span>.empty?
      <span class="ruby-ivar">@apps_loaded</span> &lt;&lt; <span class="ruby-string">&quot;none&quot;</span>
    end

    if <span class="ruby-ivar">@app_names</span>.empty?
      <span class="ruby-ivar">@app_names</span> &lt;&lt; <span class="ruby-string">&quot;none&quot;</span>
    end
  }

  return <span class="ruby-string">&quot;true&quot;</span>
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="stop_appengine-method" class="method-detail ">
        <a name="method-i-stop_appengine"></a>

        
        <div class="method-heading">
          <span class="method-name">stop_appengine</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="stop_appengine-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 2650</span>
def stop_appengine()
  <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;Shutting down AppEngine&quot;</span>)

  uac = <span class="ruby-constant">UserAppClient</span>.new(<span class="ruby-ivar">@userappserver_private_ip</span>, @@secret)
  app_list = uac.get_all_apps()
  my_public = my_node.public_ip

  <span class="ruby-constant">Djinn</span>.log_debug(&quot;All apps are [#{app_list.join(', ')}]&quot;)
  app_list.each { |app|
    if uac.does_app_exist?(app)
      <span class="ruby-constant">Djinn</span>.log_debug(&quot;App #{app} is enabled, so stopping it.&quot;)
      hosts = uac.get_hosts_for_app(app)
      <span class="ruby-constant">Djinn</span>.log_debug(&quot;[Stop appengine] hosts for #{app} is [#{hosts.join(', ')}]&quot;)
      hosts.each { |host|
        <span class="ruby-constant">Djinn</span>.log_debug(&quot;[Stop appengine] deleting instance for app #{app} at #{host}&quot;)
        ip, port = host.split(<span class="ruby-string">&quot;:&quot;</span>)
        uac.delete_instance(app, ip, port)
      }

      <span class="ruby-constant">Djinn</span>.log_debug(&quot;Finished deleting instances for app #{app}&quot;)
      <span class="ruby-comment">#Djinn.log_run(&quot;rm -fv /etc/nginx/#{app}.conf&quot;)</span>
      <span class="ruby-constant">Nginx</span>.reload
    else
      <span class="ruby-constant">Djinn</span>.log_debug(&quot;App #{app} wasnt enabled, skipping it&quot;)
    end
  }

  <span class="ruby-ivar">@app_names</span> = []
  <span class="ruby-ivar">@apps_loaded</span> = []
  <span class="ruby-ivar">@restored</span> = false

  <span class="ruby-constant">Djinn</span>.log_run(<span class="ruby-string">&quot;pkill -f dev_appserver&quot;</span>)
  <span class="ruby-constant">Djinn</span>.log_run(<span class="ruby-string">&quot;pkill -f DevAppServerMain&quot;</span>)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="stop_blob_server-method" class="method-detail ">
        <a name="method-i-stop_blob_server"></a>

        
        <div class="method-heading">
          <span class="method-name">stop_blob_server</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="stop_blob_server-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 2003</span>
def stop_blob_server
  <span class="ruby-constant">BlobServer</span>.stop
  <span class="ruby-constant">Djinn</span>.log_run(<span class="ruby-string">&quot;pkill -f blobstore_server&quot;</span>)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="stop_ejabberd-method" class="method-detail ">
        <a name="method-i-stop_ejabberd"></a>

        
        <div class="method-heading">
          <span class="method-name">stop_ejabberd</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="stop_ejabberd-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 2408</span>
def stop_ejabberd()
  <span class="ruby-constant">Ejabberd</span>.stop
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="stop_load_balancer-method" class="method-detail ">
        <a name="method-i-stop_load_balancer"></a>

        
        <div class="method-heading">
          <span class="method-name">stop_load_balancer</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="stop_load_balancer-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 2480</span>
def stop_load_balancer()
  <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;Shutting down Load Balancer&quot;</span>)
  <span class="ruby-constant">LoadBalancer</span>.stop
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="stop_memcache-method" class="method-detail ">
        <a name="method-i-stop_memcache"></a>

        
        <div class="method-heading">
          <span class="method-name">stop_memcache</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="stop_memcache-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 2394</span>
def stop_memcache()
  <span class="ruby-constant">GodInterface</span>.stop(:memcached)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="stop_pbserver-method" class="method-detail ">
        <a name="method-i-stop_pbserver"></a>

        
        <div class="method-heading">
          <span class="method-name">stop_pbserver</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="stop_pbserver-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 2012</span>
def stop_pbserver
  <span class="ruby-constant">PbServer</span>.stop(<span class="ruby-ivar">@creds</span>[<span class="ruby-string">'table'</span>]) 
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="stop_shadow-method" class="method-detail ">
        <a name="method-i-stop_shadow"></a>

        
        <div class="method-heading">
          <span class="method-name">stop_shadow</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="stop_shadow-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 2489</span>
def stop_shadow()
  <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;Stopping Shadow role&quot;</span>)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="stop_sisyphus-method" class="method-detail ">
        <a name="method-i-stop_sisyphus"></a>

        
        <div class="method-heading">
          <span class="method-name">stop_sisyphus</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="stop_sisyphus-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 2830</span>
def stop_sisyphus
  <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;Stopping Sisyphus&quot;</span>)
  stop_app(<span class="ruby-string">&quot;sisyphus&quot;</span>, @@secret)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="stop_soap_server-method" class="method-detail ">
        <a name="method-i-stop_soap_server"></a>

        
        <div class="method-heading">
          <span class="method-name">stop_soap_server</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="stop_soap_server-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 2008</span>
def stop_soap_server
  <span class="ruby-constant">GodInterface</span>.stop(:uaserver)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="update-method" class="method-detail ">
        <a name="method-i-update"></a>

        
        <div class="method-heading">
          <span class="method-name">update</span><span
            class="method-args">(app_names, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="update-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 621</span>
def update(app_names, secret)
  if !valid_secret?(secret)
    return <span class="ruby-constant">BAD_SECRET_MSG</span>
  end
  
  apps = <span class="ruby-ivar">@app_names</span> - app_names + app_names
  
  <span class="ruby-ivar">@nodes</span>.each_index { |index|
    ip = <span class="ruby-ivar">@nodes</span>[index].private_ip
    acc = <span class="ruby-constant">AppControllerClient</span>.new(ip, @@secret)
    result = acc.set_apps(apps)
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;Update #{ip} returned #{result} (#{result.class})&quot;)
    <span class="ruby-ivar">@everyone_else_is_done</span> = false if !result
  }

  <span class="ruby-comment"># now that another app is running we can take out 'none' from the list</span>
  <span class="ruby-comment"># if it was there (e.g., run-instances with no app given)</span>
  <span class="ruby-ivar">@app_names</span> = <span class="ruby-ivar">@app_names</span> - [<span class="ruby-string">&quot;none&quot;</span>]
  
  return <span class="ruby-string">&quot;OK&quot;</span>
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="update_api_status-method" class="method-detail ">
        <a name="method-i-update_api_status"></a>

        
        <div class="method-heading">
          <span class="method-name">update_api_status</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="update_api_status-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 1306</span>
def update_api_status()
  if my_node.is_appengine?
    repo_host = my_node.private_ip
  else
    repo_host = get_shadow.private_ip
  end

  repo_url = &quot;http://#{repo_host}:#{Repo::SERVER_PORT}/health/all&quot;

  retries_left = 3
  begin
    response = <span class="ruby-constant">Net</span>::<span class="ruby-constant">HTTP</span>.get_response(<span class="ruby-constant">URI</span>.parse(repo_url))
    data = <span class="ruby-constant">JSON</span>.load(response.body)
    <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;Update API was successful&quot;</span>)
  rescue <span class="ruby-constant">Exception</span> =&gt; e
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;Update API status on host #{repo_host} saw exception #{e.class}&quot;)
    data = {}

    if retries_left &gt; 0
      <span class="ruby-constant">Kernel</span>.sleep(5)
      retries_left -= 1
      retry
    else
      <span class="ruby-constant">Djinn</span>.log_debug(&quot;Repo at #{repo_host} appears to be down - will &quot; +
        <span class="ruby-string">&quot;try again later.&quot;</span>)
    end
  end

  <span class="ruby-constant">Djinn</span>.log_debug(&quot;Data received is #{data.inspect}&quot;)

  majorities = {}

  data.each { |k, v|
    <span class="ruby-ivar">@api_status</span>[k] = [] if <span class="ruby-ivar">@api_status</span>[k].nil?
    <span class="ruby-ivar">@api_status</span>[k] &lt;&lt; v
    <span class="ruby-ivar">@api_status</span>[k] = <span class="ruby-constant">HelperFunctions</span>.shorten_to_n_items(10, <span class="ruby-ivar">@api_status</span>[k])
    majorities[k] = <span class="ruby-constant">HelperFunctions</span>.find_majority_item(<span class="ruby-ivar">@api_status</span>[k])
  }

  json_state = <span class="ruby-constant">JSON</span>.dump(majorities)
  <span class="ruby-constant">HelperFunctions</span>.write_file(<span class="ruby-constant">HEALTH_FILE</span>, json_state)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="update_local_nodes-method" class="method-detail ">
        <a name="method-i-update_local_nodes"></a>

        
        <div class="method-heading">
          <span class="method-name">update_local_nodes</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Queries ZooKeeper to see if our local copy of @nodes is out of date and
should be regenerated with up to date data from ZooKeeper. If data on our
node has changed, this starts or stops the necessary roles.</p>
          

          
          <div class="method-source-code"
            id="update_local_nodes-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 1488</span>
def update_local_nodes
  <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;Getting ZK lock to update @nodes&quot;</span>)

  <span class="ruby-constant">ZKInterface</span>.lock_and_run {
    zk_ips_info = <span class="ruby-constant">ZKInterface</span>.get_ip_info()

    <span class="ruby-comment"># See if the ZooKeeper data is newer than ours - if not, don't</span>
    <span class="ruby-comment"># update anything and return.</span>
    if zk_ips_info[<span class="ruby-string">&quot;last_updated&quot;</span>] &lt;= <span class="ruby-ivar">@last_updated</span>
      <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;Latest ZooKeeper data does not have newer data than&quot;</span> +
        &quot; us. ZK timestamp is #{zk_ips_info['last_updated']}, our&quot; +
        &quot; timestamp  is #{@last_updated}&quot;)
      return <span class="ruby-string">&quot;NOT UPDATED&quot;</span>
    end

    all_ips = zk_ips_info[<span class="ruby-string">&quot;ips&quot;</span>]
    new_nodes = []
    all_ips.each { |ip|
      new_nodes &lt;&lt; <span class="ruby-constant">DjinnJobData</span>.deserialize(
        <span class="ruby-constant">ZKInterface</span>.get_job_data_for_ip(ip))
    }

    old_roles = my_node.jobs
    <span class="ruby-ivar">@nodes</span> = new_nodes
    find_me_in_locations
    new_roles = my_node.jobs

    <span class="ruby-constant">Djinn</span>.log_debug(&quot;My new nodes are [#{@nodes.join(', ')}], and my new &quot; +
      &quot;node is #{my_node}&quot;)

    <span class="ruby-comment"># Since we're about to possibly load and unload roles, set done_loading</span>
    <span class="ruby-comment"># for our node to false, so that other nodes don't erroneously send us</span>
    <span class="ruby-comment"># additional roles to do while we're in this state where lots of side</span>
    <span class="ruby-comment"># effects are happening.</span>
    <span class="ruby-ivar">@done_loading</span> = false
    <span class="ruby-constant">ZKInterface</span>.set_done_loading(my_node.public_ip, false)
 
    roles_to_start = new_roles - old_roles
    if !roles_to_start.empty?
      <span class="ruby-constant">Djinn</span>.log_debug(&quot;Need to start [#{roles_to_start.join(', ')}] &quot; +
        <span class="ruby-string">&quot;roles on this node&quot;</span>)
      add_role(roles_to_start.join(<span class="ruby-string">':'</span>), @@secret)
    end

    roles_to_stop = old_roles - new_roles
    if !roles_to_stop.empty?
      <span class="ruby-constant">Djinn</span>.log_debug(&quot;Need to stop [#{roles_to_stop.join(', ')}] &quot; +
        <span class="ruby-string">&quot;roles on this node&quot;</span>)
      remove_role(roles_to_stop.join(<span class="ruby-string">':'</span>), @@secret)
    end

    <span class="ruby-comment"># And now that we're done loading/unloading roles, set done_loading for</span>
    <span class="ruby-comment"># our node back to true.</span>
    <span class="ruby-constant">ZKInterface</span>.set_done_loading(my_node.public_ip, true)
    <span class="ruby-ivar">@done_loading</span> = true

    <span class="ruby-ivar">@last_updated</span> = zk_ips_info[<span class="ruby-string">'last_updated'</span>]
    <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;Releasing ZK lock to update @nodes, and updated &quot;</span> +
      &quot;@last_updated to #{@last_updated}&quot;)
  }

  return <span class="ruby-string">&quot;UPDATED&quot;</span>
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="valid_format_for_credentials-method" class="method-detail ">
        <a name="method-i-valid_format_for_credentials"></a>

        
        <div class="method-heading">
          <span class="method-name">valid_format_for_credentials</span><span
            class="method-args">(possible_credentials)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Checks to see if the credentials given to us (a Hash) have all the keys
that other methods expect to see.</p>
          

          
          <div class="method-source-code"
            id="valid_format_for_credentials-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 1764</span>
def valid_format_for_credentials(possible_credentials)
  required_fields = [<span class="ruby-string">&quot;table&quot;</span>, <span class="ruby-string">&quot;hostname&quot;</span>, <span class="ruby-string">&quot;ips&quot;</span>, <span class="ruby-string">&quot;keyname&quot;</span>]
  required_fields.each { |field|
    if !possible_credentials[field]
      return false
    end
  }

  return true
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="valid_secret-3F-method" class="method-detail ">
        <a name="method-i-valid_secret-3F"></a>

        
        <div class="method-heading">
          <span class="method-name">valid_secret?</span><span
            class="method-args">(secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="valid_secret-3F-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 997</span>
def valid_secret?(secret)
  @@secret = <span class="ruby-constant">HelperFunctions</span>.get_secret
  if secret != @@secret
    failed_match_msg = &quot;Incoming secret [#{secret}] failed to match &quot; +          &quot; known secret [#{@@secret}]&quot;
    <span class="ruby-constant">Djinn</span>.log_debug(failed_match_msg)
  end
  return secret == @@secret
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="validate_image-method" class="method-detail ">
        <a name="method-i-validate_image"></a>

        
        <div class="method-heading">
          <span class="method-name">validate_image</span><span
            class="method-args">(node)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="validate_image-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 2115</span>
def validate_image(node)
  ip = node.public_ip
  key = node.ssh_key
  <span class="ruby-constant">HelperFunctions</span>.ensure_image_is_appscale(ip, key)
  <span class="ruby-constant">HelperFunctions</span>.ensure_db_is_supported(ip, <span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;table&quot;</span>], key)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="wait_for_data-method" class="method-detail ">
        <a name="method-i-wait_for_data"></a>

        
        <div class="method-heading">
          <span class="method-name">wait_for_data</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="wait_for_data-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 1642</span>
def wait_for_data()
  loop {
    break if got_all_data
    if <span class="ruby-ivar">@kill_sig_received</span>
      msg = <span class="ruby-string">&quot;Received kill signal, aborting startup&quot;</span>
      <span class="ruby-constant">Djinn</span>.log_debug(msg)
      abort(msg)
    else
      <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;Waiting for data from the load balancer or cmdline tools&quot;</span>)
      <span class="ruby-constant">Kernel</span>.sleep(5)
    end
  }

end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="write_database_info-method" class="method-detail ">
        <a name="method-i-write_database_info"></a>

        
        <div class="method-heading">
          <span class="method-name">write_database_info</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="write_database_info-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 1134</span>
def write_database_info()
  table = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;table&quot;</span>]
  replication = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;replication&quot;</span>]
  keyname = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;keyname&quot;</span>]
  
  tree = { :table =&gt; table, :replication =&gt; replication,
    :local_accesses =&gt; <span class="ruby-ivar">@global_local</span>, :remote_accesses =&gt; <span class="ruby-ivar">@global_remote</span> ,
    :keyname =&gt; keyname }
  db_info_path = &quot;#{APPSCALE_HOME}/.appscale/database_info.yaml&quot;
  <span class="ruby-constant">File</span>.open(db_info_path, <span class="ruby-string">&quot;w&quot;</span>) { |file| <span class="ruby-constant">YAML</span>.dump(tree, file) }
  
  num_of_nodes = <span class="ruby-ivar">@nodes</span>.length
  <span class="ruby-constant">HelperFunctions</span>.write_file(&quot;#{APPSCALE_HOME}/.appscale/num_of_nodes&quot;, &quot;#{num_of_nodes}\n&quot;)
  
  all_ips = []
  <span class="ruby-ivar">@nodes</span>.each { |node|
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;Letting #{node.private_ip} through the firewall&quot;)
    all_ips &lt;&lt; node.private_ip
  }
  all_ips &lt;&lt; <span class="ruby-string">&quot;\n&quot;</span>
  <span class="ruby-constant">HelperFunctions</span>.write_file(&quot;#{APPSCALE_HOME}/.appscale/all_ips&quot;, all_ips.join(<span class="ruby-string">&quot;\n&quot;</span>))

  <span class="ruby-comment"># Re-run the filewall script here since we just wrote the all_ips file</span>
  if <span class="ruby-constant">FIREWALL_IS_ON</span>
    <span class="ruby-constant">Djinn</span>.log_run(&quot;bash #{APPSCALE_HOME}/firewall.conf&quot;)
  end
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="write_hypersoap-method" class="method-detail ">
        <a name="method-i-write_hypersoap"></a>

        
        <div class="method-heading">
          <span class="method-name">write_hypersoap</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="write_hypersoap-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 2309</span>
def write_hypersoap()
  <span class="ruby-constant">HelperFunctions</span>.write_file(&quot;#{APPSCALE_HOME}/.appscale/hypersoap&quot;, <span class="ruby-ivar">@userappserver_private_ip</span>)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="write_neptune_info-method" class="method-detail ">
        <a name="method-i-write_neptune_info"></a>

        
        <div class="method-heading">
          <span class="method-name">write_neptune_info</span><span
            class="method-args">(file_to_write=NEPTUNE_INFO)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Dumps all the info about Neptune jobs that have executed into a file, that
can be recovered later via load_neptune_info.</p>
          

          
          <div class="method-source-code"
            id="write_neptune_info-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 1164</span>
def write_neptune_info(file_to_write=<span class="ruby-constant">NEPTUNE_INFO</span>)
  info = { <span class="ruby-string">&quot;num_jobs&quot;</span> =&gt; <span class="ruby-ivar">@neptune_jobs</span>.length }
  <span class="ruby-ivar">@neptune_jobs</span>.each_with_index { |job, index|
    info[&quot;job_#{index}&quot;] = job.to_hash
  }

  json_info = <span class="ruby-constant">JSON</span>.dump(info)
  <span class="ruby-constant">HelperFunctions</span>.write_file(file_to_write, json_info)
  return json_info
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="write_our_node_info-method" class="method-detail ">
        <a name="method-i-write_our_node_info"></a>

        
        <div class="method-heading">
          <span class="method-name">write_our_node_info</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Backs up information about what this node is doing (roles, apps it is
running) to ZooKeeper, for later recovery or updates by other nodes.</p>
          

          
          <div class="method-source-code"
            id="write_our_node_info-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 1471</span>
def write_our_node_info
  <span class="ruby-comment"># Since more than one AppController could write its data at the same </span>
  <span class="ruby-comment"># time, get a lock before we write to it.</span>
  <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;Getting ZK Lock&quot;</span>)

  <span class="ruby-constant">ZKInterface</span>.lock_and_run {
    <span class="ruby-constant">ZKInterface</span>.add_ip_to_ip_list(my_node.public_ip)
    <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;Saving our node's information to ZooKeeper&quot;</span>)
    <span class="ruby-constant">ZKInterface</span>.write_node_information(my_node, <span class="ruby-ivar">@done_loading</span>)
  }

  return
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="write_zookeeper_locations-method" class="method-detail ">
        <a name="method-i-write_zookeeper_locations"></a>

        
        <div class="method-heading">
          <span class="method-name">write_zookeeper_locations</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Updates the file that says where all the ZooKeeper nodes are located so
that this node has the most up-to-date info if it needs to restore the data
down the line.</p>
          

          
          <div class="method-source-code"
            id="write_zookeeper_locations-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 1290</span>
def write_zookeeper_locations
  zookeeper_data = { <span class="ruby-string">'last_updated_at'</span> =&gt; <span class="ruby-constant">Time</span>.now.to_i,
    <span class="ruby-string">'locations'</span> =&gt; []
  }

  <span class="ruby-ivar">@nodes</span>.each { |node|
    if node.is_zookeeper?
      zookeeper_data[<span class="ruby-string">'locations'</span>] &lt;&lt; node.public_ip
    end
  }

  <span class="ruby-constant">Djinn</span>.log_debug(&quot;Writing ZooKeeper backup data #{zookeeper_data.inspect}&quot;)
  <span class="ruby-constant">HelperFunctions</span>.write_json_file(<span class="ruby-constant">ZK_LOCATIONS_FILE</span>, zookeeper_data)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
    </div>
  
    <div id="public-class-method-details" class="method-section section">
      <h3 class="section-header">Public Class Methods</h3>

    
      <div id="cleanup-method" class="method-detail ">
        <a name="method-c-cleanup"></a>

        
        <div class="method-heading">
          <span class="method-name">cleanup</span><span
            class="method-args">(dir)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="cleanup-source">
<pre>
<span class="ruby-comment"># File ../Neptune/babel_helper.rb, line 485</span>
def self.cleanup(dir)
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;Cleaning up directory #{dir}&quot;)
  <span class="ruby-comment"># don't clean up if we want to debug the system</span>
  return if <span class="ruby-constant">DEBUG</span>
  <span class="ruby-constant">FileUtils</span>.rm_rf(dir)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="convert_location_array_to_class-method" class="method-detail ">
        <a name="method-c-convert_location_array_to_class"></a>

        
        <div class="method-heading">
          <span class="method-name">convert_location_array_to_class</span><span
            class="method-args">(nodes, keyname)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>This method converts an Array of Strings (where each String contains all
the information about a single node) to an Array of <a
href="DjinnJobData.html">DjinnJobData</a> objects, which provide
convenience methods that make them easier to operate on than just raw
String objects.</p>
          

          
          <div class="method-source-code"
            id="convert_location_array_to_class-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 910</span>
def self.convert_location_array_to_class(nodes, keyname)
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;Keyname is of class #{keyname.class}&quot;)
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;Keyname is #{keyname}&quot;)
  
  array_of_nodes = []
  nodes.each { |node|
    converted = <span class="ruby-constant">DjinnJobData</span>.new(node, keyname)
    array_of_nodes &lt;&lt; converted
    <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;Adding data &quot;</span> + converted.to_s)
  }
  
  return array_of_nodes
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="convert_location_class_to_array-method" class="method-detail ">
        <a name="method-c-convert_location_class_to_array"></a>

        
        <div class="method-heading">
          <span class="method-name">convert_location_class_to_array</span><span
            class="method-args">(djinn_locations)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>This method is the opposite of the previous method, and is needed when an
AppController wishes to pass node information to other AppControllers via
SOAP (as SOAP accepts Arrays and Strings but not <a
href="DjinnJobData.html">DjinnJobData</a> objects).</p>
          

          
          <div class="method-source-code"
            id="convert_location_class_to_array-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 928</span>
def self.convert_location_class_to_array(djinn_locations)
  if djinn_locations.class != <span class="ruby-constant">Array</span>
    raise <span class="ruby-constant">Exception</span>, <span class="ruby-string">&quot;Locations should be an array&quot;</span>
  end
  
  djinn_loc_array = []
  djinn_locations.each { |location|
    djinn_loc_array &lt;&lt; location.serialize
    <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;Serializing data &quot;</span> + location.serialize)
  }
  
  return djinn_loc_array
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="copy_code_and_inputs_to_dir-method" class="method-detail ">
        <a name="method-c-copy_code_and_inputs_to_dir"></a>

        
        <div class="method-heading">
          <span class="method-name">copy_code_and_inputs_to_dir</span><span
            class="method-args">(job_data, dir)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="copy_code_and_inputs_to_dir-source">
<pre>
<span class="ruby-comment"># File ../Neptune/babel_helper.rb, line 323</span>
def self.copy_code_and_inputs_to_dir(job_data, dir)
  input_storage_start_time = <span class="ruby-constant">Time</span>.now
  <span class="ruby-constant">Djinn</span>.copy_code_to_dir(job_data, dir)
  <span class="ruby-constant">Djinn</span>.copy_inputs_to_dir(job_data, dir)
  input_storage_end_time = <span class="ruby-constant">Time</span>.now
  job_data[<span class="ruby-string">'@metadata_info'</span>][<span class="ruby-string">'input_storage_time'</span>] = input_storage_end_time - input_storage_start_time
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="copy_code_to_dir-method" class="method-detail ">
        <a name="method-c-copy_code_to_dir"></a>

        
        <div class="method-heading">
          <span class="method-name">copy_code_to_dir</span><span
            class="method-args">(job_data, dir)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="copy_code_to_dir-source">
<pre>
<span class="ruby-comment"># File ../Neptune/babel_helper.rb, line 331</span>
def self.copy_code_to_dir(job_data, dir)
  if !is_storage_location?(job_data[<span class="ruby-string">'@code'</span>])
    abort(&quot;The given code, #{job_data['@code']}, is not something we can fetch&quot;)
  end

  <span class="ruby-constant">Djinn</span>.log_debug(&quot;old code is #{job_data['@code']}&quot;)
  local_folder = self.copy_file_to_dir(<span class="ruby-constant">File</span>.dirname(job_data[<span class="ruby-string">'@code'</span>]), dir, job_data)
  job_data[<span class="ruby-string">'@code'</span>] = local_folder + <span class="ruby-string">'/'</span> + <span class="ruby-constant">File</span>.basename(job_data[<span class="ruby-string">'@code'</span>])

  <span class="ruby-comment"># If the code isn't going to be executed by a different program (e.g., python)</span>
  <span class="ruby-comment"># then we need to make it executable</span>
  if job_data[<span class="ruby-string">&quot;@executable&quot;</span>].nil? or job_data[<span class="ruby-string">&quot;@executable&quot;</span>].empty?
    <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;making code executable&quot;</span>)
    <span class="ruby-constant">Djinn</span>.log_run(&quot;chmod +x #{job_data['@code']}&quot;)
  end

  <span class="ruby-constant">Djinn</span>.log_debug(&quot;new code is #{job_data['@code']}&quot;)
  return job_data[<span class="ruby-string">'@code'</span>]
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="copy_file_to_dir-method" class="method-detail ">
        <a name="method-c-copy_file_to_dir"></a>

        
        <div class="method-heading">
          <span class="method-name">copy_file_to_dir</span><span
            class="method-args">(remote, local, job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="copy_file_to_dir-source">
<pre>
<span class="ruby-comment"># File ../Neptune/babel_helper.rb, line 369</span>
def self.copy_file_to_dir(remote, local, job_data)
  bucket, file = <span class="ruby-constant">DatastoreS3</span>.parse_s3_key(remote)
  remote_dir = file
  local_file = <span class="ruby-constant">File</span>.expand_path(local + <span class="ruby-string">&quot;/&quot;</span> + remote_dir)
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;downloading remote file #{remote} to local location #{local_file}&quot;)
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;bucket is #{bucket}, file is #{file}&quot;)

  datastore = <span class="ruby-constant">DatastoreFactory</span>.get_datastore(job_data[<span class="ruby-string">'@storage'</span>], job_data)
  datastore.get_output_and_save_to_fs(remote, local)
  return local_file
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="copy_inputs_to_dir-method" class="method-detail ">
        <a name="method-c-copy_inputs_to_dir"></a>

        
        <div class="method-heading">
          <span class="method-name">copy_inputs_to_dir</span><span
            class="method-args">(job_data, dir)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="copy_inputs_to_dir-source">
<pre>
<span class="ruby-comment"># File ../Neptune/babel_helper.rb, line 352</span>
def self.copy_inputs_to_dir(job_data, dir)
  return if job_data[<span class="ruby-string">'@argv'</span>].class != <span class="ruby-constant">Array</span>

  <span class="ruby-constant">Djinn</span>.log_debug(&quot;old argv is #{job_data['@argv'].join(' ')}&quot;)
  job_data[<span class="ruby-string">'@argv'</span>].each_index { |i|
    arg = job_data[<span class="ruby-string">'@argv'</span>][i]
    if is_storage_location?(arg)
      location = self.copy_file_to_dir(arg, dir, job_data)
      job_data[<span class="ruby-string">'@argv'</span>][i] = location
    end
  }

  <span class="ruby-constant">Djinn</span>.log_debug(&quot;new argv is #{job_data['@argv'].join(' ')}&quot;)
  return
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="create_temp_dir-method" class="method-detail ">
        <a name="method-c-create_temp_dir"></a>

        
        <div class="method-heading">
          <span class="method-name">create_temp_dir</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="create_temp_dir-source">
<pre>
<span class="ruby-comment"># File ../Neptune/babel_helper.rb, line 316</span>
def self.create_temp_dir()
  dir = &quot;/tmp/babel-#{rand(10000)}/&quot;
  <span class="ruby-constant">FileUtils</span>.mkdir_p(dir)
  return dir
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="execute_task-method" class="method-detail ">
        <a name="method-c-execute_task"></a>

        
        <div class="method-heading">
          <span class="method-name">execute_task</span><span
            class="method-args">(host, function_name, inputs, output)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="execute_task-source">
<pre>
<span class="ruby-comment"># File ../Neptune/cicero_helper.rb, line 264</span>
def self.execute_task(host, function_name, inputs, output)
  <span class="ruby-comment"># do a put request on the url in question - don't forget the params!</span>
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;executing a task at [#{host}] with function name &quot; +
    &quot;#{function_name}, inputs [#{inputs.join(', ')}], and output [#{output}]&quot;)

  query_params = {:f =&gt; function_name, :num_inputs =&gt; inputs.length,
    :output =&gt; output}
  inputs.each_with_index { |input, i|
    query_string[&quot;input#{i+1}&quot;] = input
  }

  begin
    <span class="ruby-comment"># be sure to specify :body =&gt; '', so that HTTParty fills in Content-Length</span>
    <span class="ruby-comment"># of zero, as required for App Engine</span>
    response = <span class="ruby-constant">JSONClient</span>.put(&quot;#{host}/task&quot;, :body =&gt; <span class="ruby-string">''</span>, 
      :query =&gt; query_params)
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;PUT /task returned #{response.inspect}&quot;)
    if response[<span class="ruby-string">&quot;result&quot;</span>] == <span class="ruby-string">&quot;failure&quot;</span>
      <span class="ruby-constant">Djinn</span>.log_debug(&quot;Could not enqueue task: [#{response.inspect}]&quot; +
        &quot;, retrying in #{RETRY_TIME} sec&quot;)
      sleep(<span class="ruby-constant">RETRY_TIME</span>)
      raise <span class="ruby-constant">NoMethodError</span>  <span class="ruby-comment"># so that the put is retried</span>
    end
  rescue <span class="ruby-constant">NoMethodError</span>  <span class="ruby-comment"># if the host is down</span>
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;PUT task failed on #{host}, retrying&quot;)
    sleep(<span class="ruby-constant">RETRY_TIME</span>)
    retry
  end

  <span class="ruby-comment"># right now, we have tasks store data with the output as the</span>
  <span class="ruby-comment"># key name, so return that so that others can read the task's info</span>
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;done enqueuing task for output #{output}&quot;)
  return output
  <span class="ruby-comment">#Djinn.log_debug(&quot;done enqueuing task, got id #{response['id']}&quot;)</span>
  <span class="ruby-comment">#return response[&quot;id&quot;] #response</span>
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="get_db_master_ip-method" class="method-detail ">
        <a name="method-c-get_db_master_ip"></a>

        
        <div class="method-heading">
          <span class="method-name">get_db_master_ip</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="get_db_master_ip-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 966</span>
def self.get_db_master_ip
  masters_file = <span class="ruby-constant">File</span>.expand_path(&quot;#{APPSCALE_HOME}/.appscale/masters&quot;)
  master_ip = <span class="ruby-constant">HelperFunctions</span>.read_file(masters_file)
  return master_ip
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="get_db_slave_ips-method" class="method-detail ">
        <a name="method-c-get_db_slave_ips"></a>

        
        <div class="method-heading">
          <span class="method-name">get_db_slave_ips</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="get_db_slave_ips-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 972</span>
def self.get_db_slave_ips
  slaves_file = <span class="ruby-constant">File</span>.expand_path(&quot;#{APPSCALE_HOME}/.appscale/slaves&quot;)
  slave_ips = <span class="ruby-constant">File</span>.open(slaves_file).readlines.map { |f| f.chomp! }
  slave_ips = [] if slave_ips == [<span class="ruby-string">&quot;&quot;</span>]
  return slave_ips
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="get_nearest_db_ip-method" class="method-detail ">
        <a name="method-c-get_nearest_db_ip"></a>

        
        <div class="method-heading">
          <span class="method-name">get_nearest_db_ip</span><span
            class="method-args">(is_mysql=false)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="get_nearest_db_ip-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 979</span>
def self.get_nearest_db_ip(is_mysql=false)
  db_ips = self.get_db_slave_ips
  <span class="ruby-comment"># Unless this is mysql we include the master ip</span>
  <span class="ruby-comment"># Update, now mysql also has an API node</span>
  db_ips &lt;&lt; self.get_db_master_ip
  db_ips.compact!
  
  local_ip = <span class="ruby-constant">HelperFunctions</span>.local_ip
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;DB IPs are [#{db_ips.join(', ')}]&quot;)
  if db_ips.include?(local_ip)
    <span class="ruby-comment"># If there is a local database then use it</span>
    local_ip
  else
    <span class="ruby-comment"># Otherwise just select one randomly</span>
    db_ips.sort_by { rand }[0]
  end
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="get_output-method" class="method-detail ">
        <a name="method-c-get_output"></a>

        
        <div class="method-heading">
          <span class="method-name">get_output</span><span
            class="method-args">(host, output)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="get_output-source">
<pre>
<span class="ruby-comment"># File ../Neptune/cicero_helper.rb, line 337</span>
def self.get_output(host, output)
  begin
    query_params = {:location =&gt; output}
    response = <span class="ruby-constant">JSONClient</span>.get(&quot;#{host}/data&quot;, :body =&gt; <span class="ruby-string">''</span>, 
      :query =&gt; query_params)
  rescue <span class="ruby-constant">NoMethodError</span>  <span class="ruby-comment"># the host is down</span>
    <span class="ruby-constant">Djinn</span>.log_debug(&quot;Failed to retrieve output from #{host}, retrying&quot;)
    sleep(<span class="ruby-constant">RETRY_TIME</span>)
    retry
  end

  return response[<span class="ruby-string">&quot;output&quot;</span>]
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="log_debug-method" class="method-detail ">
        <a name="method-c-log_debug"></a>

        
        <div class="method-heading">
          <span class="method-name">log_debug</span><span
            class="method-args">(msg)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>This method is the nexus of all AppController logging - all messages get
sent to stdout immediately (which god will send to 
/var/log/appscale/controller-17443.log for tailing), and also buffered in
@@log_buffer, which eventually gets pushed to Sisyphus for viewing. See <a
href="Djinn.html#method-i-send_logs_to_sisyphus">send_logs_to_sisyphus</a>
for that code. Important: Definitely do not log within the following three
methods, as it would cause an infinite loop.</p>
          

          
          <div class="method-source-code"
            id="log_debug-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 870</span>
def self.log_debug(msg)
  time = <span class="ruby-constant">Time</span>.now
  self.log_to_stdout(time, msg)
  self.log_to_buffer(time, msg)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="log_run-method" class="method-detail ">
        <a name="method-c-log_run"></a>

        
        <div class="method-heading">
          <span class="method-name">log_run</span><span
            class="method-args">(command)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Logs and runs the given command, which is assumed to be trusted and thus
needs no filtering on our part. Obviously this should not be executed by
anything that the user could inject input into. Returns the return value of
the code we executed.</p>
          

          
          <div class="method-source-code"
            id="log_run-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 899</span>
def self.log_run(command)
  <span class="ruby-constant">Djinn</span>.log_debug(command)
  <span class="ruby-constant">Djinn</span>.log_debug(`#{command}`)
  return $?.to_i
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="log_to_buffer-method" class="method-detail ">
        <a name="method-c-log_to_buffer"></a>

        
        <div class="method-heading">
          <span class="method-name">log_to_buffer</span><span
            class="method-args">(time, msg)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Logs and timestamps the given message to a log queue, for later processing
via the Sisyphus web app.</p>
          

          
          <div class="method-source-code"
            id="log_to_buffer-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 888</span>
def self.log_to_buffer(time, msg)
  sec_since_epoch = time.strftime(<span class="ruby-string">&quot;%s&quot;</span>)
  this_event = {:text =&gt; msg, :timestamp =&gt; sec_since_epoch}
  @@log_buffer &lt;&lt; this_event
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="log_to_stdout-method" class="method-detail ">
        <a name="method-c-log_to_stdout"></a>

        
        <div class="method-heading">
          <span class="method-name">log_to_stdout</span><span
            class="method-args">(time, msg)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Logs and timestamps the given message to standard out. TODO(cgb): Examine
the performance impact of flushing stdout on every puts, which we do to
ensure that a message can be seen immediately.</p>
          

          
          <div class="method-source-code"
            id="log_to_stdout-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 880</span>
def self.log_to_stdout(time, msg)
  <span class="ruby-constant">Kernel</span>.puts &quot;[#{time}] #{msg}&quot;
  <span class="ruby-constant">STDOUT</span>.flush
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="neptune_parse_creds-method" class="method-detail ">
        <a name="method-c-neptune_parse_creds"></a>

        
        <div class="method-heading">
          <span class="method-name">neptune_parse_creds</span><span
            class="method-args">(storage, job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="neptune_parse_creds-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 2754</span>
def self.neptune_parse_creds(storage, job_data)
  creds = {}

  if storage == <span class="ruby-string">&quot;s3&quot;</span>
    [<span class="ruby-string">'EC2_ACCESS_KEY'</span>, <span class="ruby-string">'EC2_SECRET_KEY'</span>, <span class="ruby-string">'S3_URL'</span>].each { |item|
      creds[item] = job_data[&quot;@#{item}&quot;]
    }
  end

  return creds
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="new-method" class="method-detail ">
        <a name="method-c-new"></a>

        
        <div class="method-heading">
          <span class="method-name">new</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Creates a new <a href="Djinn.html">Djinn</a>, which holds all the
information needed to configure and deploy all the services on this node.</p>
          

          
          <div class="method-source-code"
            id="new-source">
<pre>
<span class="ruby-comment"># File djinn.rb, line 266</span>
def initialize()
  <span class="ruby-comment"># The password, or secret phrase, that is required for callers to access</span>
  <span class="ruby-comment"># methods exposed via SOAP.</span>
  @@secret = <span class="ruby-constant">HelperFunctions</span>.get_secret()

  <span class="ruby-comment"># AppController logs (see self.log_debug) are printed to stdout for</span>
  <span class="ruby-comment"># immediate reading, and are buffered for delayed sending to Sisyphus, for</span>
  <span class="ruby-comment"># later viewing via web. </span>
  @@log_buffer = <span class="ruby-constant">Queue</span>.new

  <span class="ruby-ivar">@nodes</span> = []
  <span class="ruby-ivar">@my_index</span> = nil
  <span class="ruby-ivar">@creds</span> = {}
  <span class="ruby-ivar">@app_names</span> = []
  <span class="ruby-ivar">@apps_loaded</span> = []
  <span class="ruby-ivar">@kill_sig_received</span> = false
  <span class="ruby-ivar">@done_initializing</span> = false
  <span class="ruby-ivar">@done_loading</span> = false
  <span class="ruby-ivar">@nginx_port</span> = 8080
  <span class="ruby-ivar">@haproxy_port</span> = 10000
  <span class="ruby-ivar">@userappserver_public_ip</span> = <span class="ruby-string">&quot;not-up-yet&quot;</span>
  <span class="ruby-ivar">@userappserver_private_ip</span> = <span class="ruby-string">&quot;not-up-yet&quot;</span>
  <span class="ruby-ivar">@state</span> = <span class="ruby-string">&quot;AppController just started&quot;</span>
  <span class="ruby-ivar">@total_boxes</span> = 0
  <span class="ruby-ivar">@num_appengines</span> = 3
  <span class="ruby-ivar">@restored</span> = false
  <span class="ruby-ivar">@neptune_jobs</span> = {}
  <span class="ruby-ivar">@neptune_nodes</span> = []
  <span class="ruby-ivar">@api_status</span> = {}
  <span class="ruby-ivar">@queues_to_read</span> = []
  <span class="ruby-ivar">@registered_with_sisyphus</span> = false
  <span class="ruby-ivar">@last_updated</span> = 0
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="run_code-method" class="method-detail ">
        <a name="method-c-run_code"></a>

        
        <div class="method-heading">
          <span class="method-name">run_code</span><span
            class="method-args">(job_data, dir)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="run_code-source">
<pre>
<span class="ruby-comment"># File ../Neptune/babel_helper.rb, line 382</span>
def self.run_code(job_data, dir)
  filename_to_exec = job_data[<span class="ruby-string">'@code'</span>]

  executable = job_data[<span class="ruby-string">'@executable'</span>] || <span class="ruby-string">&quot;&quot;</span>

  <span class="ruby-comment"># If the user specifies an argv to pass to the code to exec, be sure to</span>
  <span class="ruby-comment"># capture it and pass it along</span>
  if job_data[<span class="ruby-string">&quot;@argv&quot;</span>]
    argv = job_data[<span class="ruby-string">&quot;@argv&quot;</span>].join(<span class="ruby-string">' '</span>)
    <span class="ruby-comment"># TODO(cgb): filter out colons and other things that malicious users could</span>
    <span class="ruby-comment"># use to hijack the system</span>
  else
    argv = <span class="ruby-string">&quot;&quot;</span>
  end

  output_file = &quot;#{dir}/stdout-#{HelperFunctions.get_random_alphanumeric()}&quot;
  error_file = &quot;#{dir}/stderr-#{HelperFunctions.get_random_alphanumeric()}&quot;

  <span class="ruby-comment"># For most file types, we can use the full path when executing them. For</span>
  <span class="ruby-comment"># Java, we can't - we need to change into the directory where the file is</span>
  <span class="ruby-comment"># located and exec the file from there.</span>
  if executable == <span class="ruby-string">&quot;java&quot;</span>
    dir = <span class="ruby-constant">File</span>.dirname(filename_to_exec)
    file = <span class="ruby-constant">File</span>.basename(filename_to_exec)
    exec_command = &quot;cd #{dir}; #{executable} #{file} #{argv} 1&gt;#{output_file} 2&gt;#{error_file}&quot;
  else
    exec_command = &quot;#{executable} #{filename_to_exec} #{argv} 1&gt;#{output_file} 2&gt;#{error_file}&quot;
  end

  start_time = <span class="ruby-constant">Time</span>.now
  ret_val = <span class="ruby-constant">Djinn</span>.log_run(exec_command)
  end_time = <span class="ruby-constant">Time</span>.now

  total = end_time - start_time
  <span class="ruby-constant">Djinn</span>.log_debug(<span class="ruby-string">&quot;Babel: Done running job!&quot;</span>)
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;TIMING: Took #{total} seconds&quot;)

  <span class="ruby-comment"># Save some data about the task we just ran. At a high level, there are two</span>
  <span class="ruby-comment"># types of information we want to save: debugging information (in case the</span>
  <span class="ruby-comment"># task failed and the user needs to deduce why), and profiling information</span>
  <span class="ruby-comment"># (so the user can see how long their code took to run).</span>

  <span class="ruby-comment"># Add in debugging information.</span>
  job_data[<span class="ruby-string">'@metadata_info'</span>][<span class="ruby-string">'command'</span>] = exec_command
  job_data[<span class="ruby-string">'@metadata_info'</span>][<span class="ruby-string">'return_value'</span>] = ret_val
  job_data[<span class="ruby-string">'@metadata_info'</span>][<span class="ruby-string">'cpu_info'</span>] = <span class="ruby-constant">HelperFunctions</span>.shell(<span class="ruby-string">&quot;cat /proc/cpuinfo&quot;</span>)
  job_data[<span class="ruby-string">'@metadata_info'</span>][<span class="ruby-string">'mem_info'</span>] = <span class="ruby-constant">HelperFunctions</span>.shell(<span class="ruby-string">&quot;cat /proc/meminfo&quot;</span>)
  job_data[<span class="ruby-string">'@metadata_info'</span>][<span class="ruby-string">'df_h'</span>] = <span class="ruby-constant">HelperFunctions</span>.shell(<span class="ruby-string">&quot;df -h&quot;</span>)

  <span class="ruby-comment"># Add in profiling information, with all times converted to seconds since epoch.</span>
  job_data[<span class="ruby-string">'@metadata_info'</span>][<span class="ruby-string">'start_time'</span>] = start_time.to_i
  job_data[<span class="ruby-string">'@metadata_info'</span>][<span class="ruby-string">'end_time'</span>] = end_time.to_i
  job_data[<span class="ruby-string">'@metadata_info'</span>][<span class="ruby-string">'total_execution_time'</span>] = total

  return output_file, error_file
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="save_output-method" class="method-detail ">
        <a name="method-c-save_output"></a>

        
        <div class="method-heading">
          <span class="method-name">save_output</span><span
            class="method-args">(remote_output, local_output, job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="save_output-source">
<pre>
<span class="ruby-comment"># File ../Neptune/babel_helper.rb, line 478</span>
def self.save_output(remote_output, local_output, job_data)
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;Saving local output #{local_output} to remote location #{remote_output}&quot;)
  datastore = <span class="ruby-constant">DatastoreFactory</span>.get_datastore(job_data[<span class="ruby-string">'@storage'</span>], job_data)
  datastore.write_remote_file_from_local_file(remote_output, local_output)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="wait_for_task_to_complete-method" class="method-detail ">
        <a name="method-c-wait_for_task_to_complete"></a>

        
        <div class="method-heading">
          <span class="method-name">wait_for_task_to_complete</span><span
            class="method-args">(host, task_id)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="wait_for_task_to_complete-source">
<pre>
<span class="ruby-comment"># File ../Neptune/cicero_helper.rb, line 301</span>
def self.wait_for_task_to_complete(host, task_id)
  response = {}
  start_time = <span class="ruby-constant">Time</span>.now
  loop {
    query_params = {:id =&gt; task_id, :task_id =&gt; task_id}
    begin
      response = <span class="ruby-constant">JSONClient</span>.get(&quot;#{host}/task&quot;, :body =&gt; <span class="ruby-string">''</span>, 
        :query =&gt; query_params)
    rescue <span class="ruby-constant">NoMethodError</span>  <span class="ruby-comment"># if the host is down</span>
      <span class="ruby-constant">Djinn</span>.log_debug(&quot;Host [#{host}] is down, retrying in #{RETRY_TIME} sec&quot;)
      sleep(<span class="ruby-constant">RETRY_TIME</span>)
      retry
    end

    state = response[<span class="ruby-string">'state'</span>]
    <span class="ruby-comment">#start_time = response['start_time']</span>
    if state == <span class="ruby-string">&quot;finished&quot;</span>
      <span class="ruby-constant">Djinn</span>.log_debug(&quot;Task with id [#{task_id}] has finished&quot;)
      break
    end

    <span class="ruby-comment">#if Time.now - start_time &gt; 60</span>
    <span class="ruby-comment">#  Djinn.log_debug(&quot;Task with id [#{task_id}] took too long to run - skipping it.&quot;)</span>
    <span class="ruby-comment">#  break</span>
    <span class="ruby-comment">#end</span>

    <span class="ruby-constant">Djinn</span>.log_debug(&quot;Current state of job with task id [#{task_id}], &quot; +
      &quot;is #{state}, waiting for it to become 'finished'&quot;)
    <span class="ruby-comment">#Djinn.log_debug(&quot;Current state of job with task id [#{task_id}], started&quot; +</span>
    <span class="ruby-comment">#  &quot; at #{start_time}, is '#{state}', waiting for it to become 'finished'&quot;)</span>
    sleep(<span class="ruby-constant">RETRY_TIME</span>)
  }

  return response
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="write_babel_outputs-method" class="method-detail ">
        <a name="method-c-write_babel_outputs"></a>

        
        <div class="method-heading">
          <span class="method-name">write_babel_outputs</span><span
            class="method-args">(output, error, job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Writes the stdout and stderr that a Babel task produces to the remote
datastore that the user has specified to use. We also automatically collect
some metadata about the task, so we write that to the datastore as well.</p>
          

          
          <div class="method-source-code"
            id="write_babel_outputs-source">
<pre>
<span class="ruby-comment"># File ../Neptune/babel_helper.rb, line 443</span>
def self.write_babel_outputs(output, error, job_data)
  datastore = <span class="ruby-constant">DatastoreFactory</span>.get_datastore(job_data[<span class="ruby-string">'@storage'</span>], job_data)

  <span class="ruby-comment"># Write our stdout file</span>
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;Saving stdout at #{output} to remote location&quot; + 
    &quot; #{job_data['@output']}&quot;)
  output_storage_start_time = <span class="ruby-constant">Time</span>.now
  datastore.write_remote_file_from_local_file(job_data[<span class="ruby-string">'@output'</span>], output)

  <span class="ruby-comment"># Write our stderr file</span>
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;Saving stderr #{error} to remote location&quot; +
    &quot; #{job_data['@error']}&quot;)
  datastore.write_remote_file_from_local_file(job_data[<span class="ruby-string">'@error'</span>], error)
  output_storage_end_time = <span class="ruby-constant">Time</span>.now
  total_output_time = output_storage_end_time - output_storage_start_time
  job_data[<span class="ruby-string">'@metadata_info'</span>][<span class="ruby-string">'output_storage_time'</span>] = total_output_time

  local_input_storage_time = job_data[<span class="ruby-string">'@metadata_info'</span>][<span class="ruby-string">'time_to_store_inputs'</span>]
  total_input_time = job_data[<span class="ruby-string">'@metadata_info'</span>][<span class="ruby-string">'input_storage_time'</span>]
  job_data[<span class="ruby-string">'@metadata_info'</span>][<span class="ruby-string">'total_storage_time'</span>] = local_input_storage_time + 
    total_input_time + total_output_time

  <span class="ruby-comment"># Write our metadata info, which is not a file, but a hash we will turn to</span>
  <span class="ruby-comment"># a string via JSON</span>
  <span class="ruby-constant">Djinn</span>.log_debug(&quot;Saving metadata #{job_data['@metadata_info'].inspect} &quot; +
    &quot;to remote location #{job_data['@metadata']}&quot;)
  metadata_file = &quot;/tmp/metadata-#{HelperFunctions.get_random_alphanumeric()}&quot;
  <span class="ruby-constant">HelperFunctions</span>.write_file(metadata_file, 
    <span class="ruby-constant">JSON</span>.dump(job_data[<span class="ruby-string">'@metadata_info'</span>]))
  datastore.write_remote_file_from_local_file(job_data[<span class="ruby-string">'@metadata'</span>], 
    metadata_file)
  <span class="ruby-constant">FileUtils</span>.rm_f(metadata_file)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
    </div>
  

  </div>

  <div id="validator-badges">
    <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
    <p><small>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish
      Rdoc Generator</a> 2</small>.</p>
  </div>

</body>
</html>

