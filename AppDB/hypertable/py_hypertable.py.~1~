import sys
import os
import time

import helper_functions
from hypertable.thriftclient import * 
import hyperthrift.gen.ttypes as ttypes
#from hyperthrift.gen2 import *
import string
import cgi
from xml.sax import make_parser
import xml
from xml.sax import parseString
from xml.sax.handler import feature_namespaces
from xml.sax import ContentHandler
from xml.sax import saxutils
from xml.sax.handler import ContentHandler
#import sqlalchemy.pool as pool
from dbinterface import *
import appscale_logger
import threading 
THRIFT_PORT = 38080
ERROR_HT = "DB_ERROR:"
DB_LOCATION = "localhost"
NS = "/appscale"
#DB_LOCATION = ""
HYPERTABLE_XML_TAG = "Name"

PROFILING = False

class HTLogger:
  def __init__(self, log):
    self.ht_lock = threading.Lock()
    self.ht_logger = log
  def debug(self, string):
    if PROFILING == True:
      self.ht_lock.acquire()
      self.ht_logger.info(string)
      self.ht_lock.release()

#ht_logger = HTLogger(log_logger)

class XmlSchemaParser(ContentHandler):
  def __init__(self, tag_name):
    self.tag_name = tag_name
    self.isName = 0
    self.attributes = []

  def clear_attributes(self):
    self.attributes = []

  def startElement(self, name, attrs):
    if name == self.tag_name:
      self.isName = 1

  def endElement(self, name):
    if name == self.tag_name:
      self.isName = 0

  def characters(self, ch):
    if self.isName == 1:
      self.attributes.append(ch)

class DatastoreProxy(AppDBInterface):

  def __init__(self, logger = appscale_logger.getLogger("datastore-hypertable")):
    self.logger = logger
    #self.pool = pool.QueuePool(self.__createConnection)
    self.conn = ThriftClient(self.get_local_ip(), THRIFT_PORT)
    self.ns = self.conn.open_namespace(NS)
    self.tableCache = []
    self.lock = threading.Lock()

  def __initConnection(self):
    self.lock.acquire()
    if PROFILING:
      self.logger.debug("HT InitConnection: %s"%str(endtime - starttime))
    return self.conn

  def __closeConnection(self, conn):
    if conn:
      self.lock.release()

  # tag is the xml tag which holds the schema attributes
  def getListFromXMLSchema(self, table, tag):
    parser = make_parser()

    #parser = setFeature(feature_namespaces, 0)
    dh = XmlSchemaParser(tag)
    dh.clear_attributes()
    parser.setContentHandler(dh)

    elist = [ERROR_HT]
    client = None
    try:
      client = self.__initConnection()
      res = client.hql_query(self.ns, "describe table " + table) 
    except:
      elist[0] += "IO Error"
      #elist = elist + res.results
      self.__closeConnection(client)
      return elist

    res = res.results

    schema = res 
    #print schema
    xml.sax.parseString(schema[0], dh)

    # items are not strings, need to convert them
    for ii in range(0, len(dh.attributes)):
      dh.attributes[ii] = str(dh.attributes[ii])
    #print dh.attributes
    elist += dh.attributes
    self.__closeConnection(client)
    return elist

  def get_schema(self, table_name):
    # Hypertable returns the results in XML form, so a function is needed to
    # convert it to an array
    return self.getListFromXMLSchema(table_name, HYPERTABLE_XML_TAG)

  def get_entity(self, table_name, row_key, column_names):
    starttime = time.time()
    elist = [ERROR_HT]

    client = None
    try:
      client = self.__initConnection()
    # need to try this way for new interface (was having problems with deletes)
    #for ii in column_names:
    #   elist.append(client.get_cell(self.ns, table_name, row_key, ii))
      result = client.hql_query(self.ns, "select * from " + table_name + " where ROW = \"" + row_key + "\" REVS = 1")
      for name in column_names:
        for ii in range(0, len(result.cells)):
          if name == result.cells[ii].key.column_family:
            elist.append(result.cells[ii].value)
            break
    except:
      elist[0] += "Not Found"
    endtime = time.time() 
    if PROFILING:
      self.logger.debug("HT GET: %s"%str(endtime - starttime))
    self.__closeConnection(client)
    if len(elist) == 1:
      elist[0] += "Not Found"
    return elist

  def delete_table(self, table_name):
    starttime = time.time()
    elist = [ERROR_HT]
    client = self.__initConnection()
    if self.__table_exist(table_name, client):
#      query = "drop table " + table_name 
#      ret = client.hql_query(query)
      client.drop_table(self.ns, table_name, 1)
    else:
      elist[0] += "Table not found"
    endtime = time.time()
    if PROFILING:
      self.logger.debug("HT DELETE_TABLE: %s"%str(endtime - starttime))
    self.__closeConnection(client)
    if table_name in self.tableCache:
      self.tableCache.remove(table_name)
    return elist

  def put_entity(self, table_name, row_key, column_names, cell_values):
    starttime = time.time()
    elist = [ERROR_HT]

    if len(column_names) != len(cell_values):
      elist[0] += "Error in put call |column_names| != |cell_values|"
      return elist

    client = self.__initConnection()
    if not self.__table_exist(table_name, client):
      query = "create table " + table_name + "( " + ', '.join(column_names) + ")"
      print "create table query=%s" % query
      try:
        ret = client.hql_query(self.ns, query)
      except Exception, e:
        print e.message
# the xml schema is not working currectly.
#      schema = "<Schema><AccessGroup name=\"default\"><ColumnFamily>"
#      for column in column_names:
#        schema += "<Name>%s</Name>" % column
#      schema += "</ColumnFamily></AccessGroup></Schema>"
#      print "create table schema=%s" % schema
#      try:
#        client.create_table(table_name, schema)
#      except:
#        self.logger.warn("fail to create table: %s" % table_name)
    
    try: 
      mutator = client.open_mutator(self.ns, table_name, 0, 0) 
      cell_list = []
      for ii in range(0, len(column_names)):
        cell = ttypes.Cell() 
        keyflag = ttypes.KeyFlag()
        #255 is insert
        key = ttypes.Key(row=row_key, column_family=column_names[ii], 
                         flag=255)
        cell.key = key 
        cell.value =  cell_values[ii]
        cell_list.append(cell)
      client.set_cells(mutator, cell_list)
      client.close_mutator(mutator, 1) 
    except:
      elist[0] += "Error in put call"  
    elist.append("0")
    endtime = time.time()
    if PROFILING:
      self.logger.debug("HT PUT: %s"%str(endtime - starttime))
    self.__closeConnection(client)
    return elist 

  def __table_exist(self, table_name,client):
    starttime = time.time()
    if table_name in self.tableCache:
      return True

#    query = client.hql_query('show tables')
#    tables = query.results
    tables = client.get_tables(self.ns)
    self.tableCache = tables
    ret = False
    for ii in tables:
      if table_name == ii:
        ret = True
    return ret

  def delete_row(self, table_name, row_id):
    starttime = time.time()
    elist = [ERROR_HT]
    client = None
    try:
      client = self.__initConnection()
      query = "delete * from " + table_name + " where ROW=\""+ row_id + "\""
      client.hql_query(self.ns,query)
    except:
      elist[0] += "Not Found"
    endtime = time.time()
    if PROFILING: 
      self.logger.debug("HT DELETE: %s"%str(endtime - starttime))
    self.__closeConnection(client)
    return elist

  def get_row_count(self, table_name):
    starttime = time.time()
    elist = [ERROR_HT]
    value = 0
    try: 
      res = self.get_schema(table_name) 
      error = res[0]
      if error != ERROR_HT:
        elist[0] += error
        return elist

      column_names = res[1:]
      table = self.get_table(table_name, column_names)
      value = (len(table) - 1)/len(column_names)
      elist += [value]
    except:
      elist += [0]
    endtime = time.time()
    if PROFILING:
      self.logger.debug("HT GETROWCOUNT: %s"%str(endtime - starttime))

    return elist

  def get_table(self, table_name, column_names):
    starttime = time.time()
    elist = [ERROR_HT]
    client = None
    try:
      client = self.__initConnection()
      res = client.hql_query(self.ns, "select * from " + table_name + " REVS = 1" )
      res = res.cells
      for ii in range(0, len(res)):
        if res[ii].key.column_family in column_names:
          elist += [res[ii].value]
    except:
      # return an empty list for nonexistant tables
      pass
      #elist[0] += "Not Found"
    endtime = time.time()
    if PROFILING:
      self.logger.debug("HT GET_TABLE: %s"%str(endtime - starttime))
    self.__closeConnection(client)
    return elist

  def __query_table(self, table_name):
    client = self.__initConnection()
    ret = client.hql_query(self.ns, "select * from " + table_name + " REVS = 1")
    self.__closeConnection(client)
    return ret

  def run_query(self, table_name, column_names, limit, offset, startrow, endrow, getOnlyKeys, start_inclusive, end_inclusive):
    starttime = time.time() 
    elist = [ERROR_HT]
    client = None
    try:
      client = self.__initConnection()
      row_intervals = [ttypes.RowInterval(startrow, start_inclusive, endrow, end_inclusive)]
      cell_intervals =  None
      include_deletes = 0
      scan_spec = ttypes.ScanSpec(row_intervals, cell_intervals, include_deletes, 1, limit + offset, 0, None, column_names)
      count = 0
      cells = client.get_cells(self.ns, table_name, scan_spec)
      for cell in cells:
        count = count + 1
        if count > offset:
          if getOnlyKeys:
            elist += [cell.row_key] 
          else:
            elist += [cell.value]
    except:
      elist[0] += "Exception thrown while running a scanner"  
    endtime = time.time()
    if PROFILING:
      self.logger.debug("HT RUN_QUERY: %s"%str(endtime - starttime))
    self.__closeConnection(client)
    return elist
