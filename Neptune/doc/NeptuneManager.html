<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />

  <title>Class: NeptuneManager</title>

  <link rel="stylesheet" href="./rdoc.css" type="text/css" media="screen" />

  <script src="./js/jquery.js" type="text/javascript"
    charset="utf-8"></script>
  <script src="./js/thickbox-compressed.js" type="text/javascript"
    charset="utf-8"></script>
  <script src="./js/quicksearch.js" type="text/javascript"
    charset="utf-8"></script>
  <script src="./js/darkfish.js" type="text/javascript"
    charset="utf-8"></script>

</head>
<body class="class">

  <div id="metadata">
    <div id="home-metadata">
      <div id="home-section" class="section">
        <h3 class="section-header">
          <a href="./index.html">Home</a>
          <a href="./index.html#classes">Classes</a>
          <a href="./index.html#methods">Methods</a>
        </h3>
      </div>
    </div>

    <div id="file-metadata">
      <div id="file-list-section" class="section">
        <h3 class="section-header">In Files</h3>
        <div class="section-body">
          <ul>
          
            <li><a href="./neptune_manager_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="neptune_manager.rb">neptune_manager.rb</a></li>
          
            <li><a href="./lib/job_types/appscale_helper_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/job_types/appscale_helper.rb">lib/job_types/appscale_helper.rb</a></li>
          
            <li><a href="./lib/job_types/babel_helper_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/job_types/babel_helper.rb">lib/job_types/babel_helper.rb</a></li>
          
          </ul>
        </div>
      </div>

      
    </div>

    <div id="class-metadata">

      <!-- Parent Class -->
      
      <div id="parent-class-section" class="section">
        <h3 class="section-header">Parent</h3>
        
        <p class="link"><a href="Object.html">Object</a></p>
        
      </div>
      

      <!-- Namespace Contents -->
      
      <div id="namespace-list-section" class="section">
        <h3 class="section-header">Namespace</h3>
        <ul class="link-list">
          
          <li><span class="type">CLASS</span> <a href="NeptuneManager/Djinn.html">NeptuneManager::Djinn</a></li>
          
        </ul>
      </div>
      

      <!-- Method Quickref -->
      
      <div id="method-list-section" class="section">
        <h3 class="section-header">Methods</h3>
        <ul class="link-list">
          
          <li><a href="#method-c-log">::log</a></li>
          
          <li><a href="#method-c-neptune_parse_creds">::neptune_parse_creds</a></li>
          
          <li><a href="#method-c-new">::new</a></li>
          
          <li><a href="#method-i-acquire_nodes">#acquire_nodes</a></li>
          
          <li><a href="#method-i-acquire_nodes_for_cloud">#acquire_nodes_for_cloud</a></li>
          
          <li><a href="#method-i-add_nodes">#add_nodes</a></li>
          
          <li><a href="#method-i-add_roles_and_wait">#add_roles_and_wait</a></li>
          
          <li><a href="#method-i-add_timing_info">#add_timing_info</a></li>
          
          <li><a href="#method-i-appscale_run_job">#appscale_run_job</a></li>
          
          <li><a href="#method-i-babel_run_job">#babel_run_job</a></li>
          
          <li><a href="#method-i-can_run_job">#can_run_job</a></li>
          
          <li><a href="#method-i-cleanup_code">#cleanup_code</a></li>
          
          <li><a href="#method-i-compile_code">#compile_code</a></li>
          
          <li><a href="#method-i-copyFromShadow">#copyFromShadow</a></li>
          
          <li><a href="#method-i-does_file_exist">#does_file_exist</a></li>
          
          <li><a href="#method-i-execute_multiple_tasks">#execute_multiple_tasks</a></li>
          
          <li><a href="#method-i-find_neighbors">#find_neighbors</a></li>
          
          <li><a href="#method-i-find_open_nodes">#find_open_nodes</a></li>
          
          <li><a href="#method-i-get_acl">#get_acl</a></li>
          
          <li><a href="#method-i-get_engines_for_creds">#get_engines_for_creds</a></li>
          
          <li><a href="#method-i-get_job_data">#get_job_data</a></li>
          
          <li><a href="#method-i-get_job_name">#get_job_name</a></li>
          
          <li><a href="#method-i-get_length_of_all_queues">#get_length_of_all_queues</a></li>
          
          <li><a href="#method-i-get_lock_file_path">#get_lock_file_path</a></li>
          
          <li><a href="#method-i-get_n_items_of_work">#get_n_items_of_work</a></li>
          
          <li><a href="#method-i-get_node_roles">#get_node_roles</a></li>
          
          <li><a href="#method-i-get_output">#get_output</a></li>
          
          <li><a href="#method-i-get_queues_from_shadow">#get_queues_from_shadow</a></li>
          
          <li><a href="#method-i-get_queues_in_use">#get_queues_in_use</a></li>
          
          <li><a href="#method-i-get_seed_vals">#get_seed_vals</a></li>
          
          <li><a href="#method-i-get_supported_babel_engines">#get_supported_babel_engines</a></li>
          
          <li><a href="#method-i-has_all_required_params-3F">#has_all_required_params?</a></li>
          
          <li><a href="#method-i-is_job_running">#is_job_running</a></li>
          
          <li><a href="#method-i-is_storage_location-3F">#is_storage_location?</a></li>
          
          <li><a href="#method-i-lock_file_exists-3F">#lock_file_exists?</a></li>
          
          <li><a href="#method-i-optimal_nodes">#optimal_nodes</a></li>
          
          <li><a href="#method-i-optimal_nodes_hill_climbing">#optimal_nodes_hill_climbing</a></li>
          
          <li><a href="#method-i-put_input">#put_input</a></li>
          
          <li><a href="#method-i-release_nodes">#release_nodes</a></li>
          
          <li><a href="#method-i-remove_lock_file">#remove_lock_file</a></li>
          
          <li><a href="#method-i-remove_roles">#remove_roles</a></li>
          
          <li><a href="#method-i-run_job_on_master">#run_job_on_master</a></li>
          
          <li><a href="#method-i-run_or_delegate_tasks">#run_or_delegate_tasks</a></li>
          
          <li><a href="#method-i-run_task">#run_task</a></li>
          
          <li><a href="#method-i-run_via_engine">#run_via_engine</a></li>
          
          <li><a href="#method-i-run_via_executor">#run_via_executor</a></li>
          
          <li><a href="#method-i-set_acl">#set_acl</a></li>
          
          <li><a href="#method-i-spawn_babel_slaves">#spawn_babel_slaves</a></li>
          
          <li><a href="#method-i-spawn_nodes_for_neptune-3F">#spawn_nodes_for_neptune?</a></li>
          
          <li><a href="#method-i-start_babel_master">#start_babel_master</a></li>
          
          <li><a href="#method-i-start_babel_slave">#start_babel_slave</a></li>
          
          <li><a href="#method-i-start_job">#start_job</a></li>
          
          <li><a href="#method-i-stop_babel_master">#stop_babel_master</a></li>
          
          <li><a href="#method-i-stop_babel_slave">#stop_babel_slave</a></li>
          
          <li><a href="#method-i-stop_job">#stop_job</a></li>
          
          <li><a href="#method-i-touch_lock_file">#touch_lock_file</a></li>
          
          <li><a href="#method-i-uncompress_file">#uncompress_file</a></li>
          
          <li><a href="#method-i-validate_environment">#validate_environment</a></li>
          
          <li><a href="#method-i-wait_for_allotted_time">#wait_for_allotted_time</a></li>
          
          <li><a href="#method-i-write_job_output">#write_job_output</a></li>
          
          <li><a href="#method-i-write_job_output_handler">#write_job_output_handler</a></li>
          
          <li><a href="#method-i-write_job_output_str">#write_job_output_str</a></li>
          
        </ul>
      </div>
      

      <!-- Included Modules -->
      
    </div>

    <div id="project-metadata">
      
      

      <div id="classindex-section" class="section project-section">
        <h3 class="section-header">Class/Module Index
          <span class="search-toggle"><img src="./images/find.png"
            height="16" width="16" alt="[+]"
            title="show/hide quicksearch" /></span></h3>
        <form action="#" method="get" accept-charset="utf-8" class="initially-hidden">
        <fieldset>
          <legend>Quicksearch</legend>
          <input type="text" name="quicksearch" value=""
            class="quicksearch-field" />
        </fieldset>
        </form>

        <ul class="link-list">
        
          <li><a href="./NeptuneManager.html">NeptuneManager</a></li>
        
          <li><a href="./NeptuneManager/Djinn.html">NeptuneManager::Djinn</a></li>
        
          <li><a href="./BadConfigurationException.html">BadConfigurationException</a></li>
        
          <li><a href="./Datastore.html">Datastore</a></li>
        
          <li><a href="./DatastoreFactory.html">DatastoreFactory</a></li>
        
          <li><a href="./DatastoreRepo.html">DatastoreRepo</a></li>
        
          <li><a href="./DatastoreRepoOnAppEngine.html">DatastoreRepoOnAppEngine</a></li>
        
          <li><a href="./DatastoreRepoOnAppScale.html">DatastoreRepoOnAppScale</a></li>
        
          <li><a href="./DatastoreS3.html">DatastoreS3</a></li>
        
          <li><a href="./Djinn.html">Djinn</a></li>
        
          <li><a href="./EngineFactory.html">EngineFactory</a></li>
        
          <li><a href="./GoogleAppEnginePullQueue.html">GoogleAppEnginePullQueue</a></li>
        
          <li><a href="./GoogleAppEnginePushQueue.html">GoogleAppEnginePushQueue</a></li>
        
          <li><a href="./HelperFunctions.html">HelperFunctions</a></li>
        
          <li><a href="./NeptuneJobData.html">NeptuneJobData</a></li>
        
          <li><a href="./NeptuneManagerServer.html">NeptuneManagerServer</a></li>
        
          <li><a href="./Object.html">Object</a></li>
        
          <li><a href="./QueueFactory.html">QueueFactory</a></li>
        
          <li><a href="./TaskEngine.html">TaskEngine</a></li>
        
          <li><a href="./TaskEngineAppScale.html">TaskEngineAppScale</a></li>
        
          <li><a href="./TaskEngineGoogleAppEngine.html">TaskEngineGoogleAppEngine</a></li>
        
          <li><a href="./TaskQueue.html">TaskQueue</a></li>
        
          <li><a href="./TaskQueueAzureQueue.html">TaskQueueAzureQueue</a></li>
        
          <li><a href="./TaskQueueGoogleAppEngine.html">TaskQueueGoogleAppEngine</a></li>
        
          <li><a href="./TaskQueueRabbitMQ.html">TaskQueueRabbitMQ</a></li>
        
          <li><a href="./TaskQueueSQS.html">TaskQueueSQS</a></li>
        
          <li><a href="./UserAppClient.html">UserAppClient</a></li>
        
        </ul>
        <div id="no-class-search-results" style="display: none;">No matching classes.</div>
      </div>

      
    </div>
  </div>

  <div id="documentation">
    <h1 class="class">NeptuneManager</h1>

    <div id="description">
      
<p>things to fiximportsmove all _helper imports into <a
href="NeptuneManager.html">NeptuneManager</a> classmove @neptune_jobs and
@neptune_nodes into this filemove VM reuse (and per-hour killing of VMs)
into this fileperiodically dump and revive info to-from ZKremove all dead
code from AppController/helperfunctionsremove all dead code from
Neptune/helperfunctions</p>

    </div>

    <!-- Constants -->
    
    <div id="constants-list" class="section">
      <h3 class="section-header">Constants</h3>
      <dl>
      
        <dt><a name="SERVER_PORT">SERVER_PORT</a></dt>
        
        <dd class="description"><p>The port that the <a href="NeptuneManager.html">NeptuneManager</a> runs on,
by default.</p></dd>
        
      
        <dt><a name="BAD_SECRET_MSG">BAD_SECRET_MSG</a></dt>
        
        <dd class="description"><p>The string that should be returned to the caller if they call a publicly
exposed SOAP method but provide an incorrect secret.</p></dd>
        
      
        <dt><a name="ALLOWED_STORAGE_TYPES">ALLOWED_STORAGE_TYPES</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="NO_INPUT_NEEDED">NO_INPUT_NEEDED</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="NO_NODES_NEEDED">NO_NODES_NEEDED</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="JOB_IN_PROGRESS">JOB_IN_PROGRESS</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="BAD_TYPE_MSG">BAD_TYPE_MSG</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="MISSING_PARAM">MISSING_PARAM</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="STARTED_SUCCESSFULLY">STARTED_SUCCESSFULLY</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="NOT_QUITE_AN_HOUR">NOT_QUITE_AN_HOUR</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="INFINITY">INFINITY</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="URL_REGEX">URL_REGEX</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="INTERNAL_ENGINES">INTERNAL_ENGINES</a></dt>
        
        <dd class="description"><p>When executing over AppScale resources only, we can utilize RabbitMQ as a
queue and use Executor, our task engine, or we can make the app into an App
Engine app and exeucte it via the App Engine Task Queue API.</p></dd>
        
      
        <dt><a name="AMAZON_CREDENTIALS">AMAZON_CREDENTIALS</a></dt>
        
        <dd class="description"><p>When executing over AppScale with Amazon credentials, we can utilize 
Amazon SQS (Simple Queue Service) as a queue and use Executor to execute
tasks.</p></dd>
        
      
        <dt><a name="AMAZON_ENGINES">AMAZON_ENGINES</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="GOOGLE_CREDENTIALS">GOOGLE_CREDENTIALS</a></dt>
        
        <dd class="description"><p>When executing over AppScale with Google credentials, we can utilize Google
App Engine’s push queues as the queue and task engine or Google App
Engine’s pull queues as the queue and Executor to execute tasks. Since
our pull queue support is done via an App Engine app, the same credentials
will work for pull queues as for push queues (minus @function).</p></dd>
        
      
        <dt><a name="GOOGLE_ENGINES">GOOGLE_ENGINES</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="AZURE_CREDENTIALS">AZURE_CREDENTIALS</a></dt>
        
        <dd class="description"><p>When executing over AppScale with Azure credentials, we can utilize the
Windows Azure Queue Service as a queue and use Executor to execute tasks.</p></dd>
        
      
        <dt><a name="AZURE_ENGINES">AZURE_ENGINES</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="STORAGE_PARAM_REGEX">STORAGE_PARAM_REGEX</a></dt>
        
        <dd class="description"><p>Files stored in remote datastores are referenced in a POSIX-like fashion:
/bucket/file refers to a file stored in S3, with the named bucket and file.</p></dd>
        
      
        <dt><a name="RUN_LOCALLY">RUN_LOCALLY</a></dt>
        
        <dd class="description"><p>Constants that are used to indicate which engine runs a task.</p></dd>
        
      
        <dt><a name="RUN_VIA_EXECUTOR">RUN_VIA_EXECUTOR</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="RUN_VIA_REMOTE_ENGINE">RUN_VIA_REMOTE_ENGINE</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="TIME_TO_WAIT_FOR_NEW_TASKS">TIME_TO_WAIT_FOR_NEW_TASKS</a></dt>
        
        <dd class="description"><p>Constants that are used to indicate how long a babel_master node should
sleep for if there are no tasks to schedule, and how long to sleep for if
new babel_slaves have been spawned and need time to fetch tasks off of
queues.</p></dd>
        
      
        <dt><a name="TIME_FOR_NEW_NODES_TO_GET_TASKS">TIME_FOR_NEW_NODES_TO_GET_TASKS</a></dt>
        
        <dd class="description"></dd>
        
      
        <dt><a name="MAX_IDLE_TIME">MAX_IDLE_TIME</a></dt>
        
        <dd class="description"><p>The amount of time that we should hold the babel_slave role for, even if we
receive no tasks. Dynamically adding and removing this role frees it up to
take on other roles for fault tolerance purposes, and we keep the value 
non-trivially high because starting and stopping RabbitMQ (which we always
start for babel_slave since rabbitmq is one of the possible backends) can
take a while. TODO(cgb): Maybe only start rabbitmq if we get an item from
the queue that specifies it should be used?</p></dd>
        
      
        <dt><a name="INSTANCE_CPU_INFO">INSTANCE_CPU_INFO</a></dt>
        
        <dd class="description"><p>A mapping of Amazon EC2 instance types that maps instance types to the
number of cores they have. TODO(cgb): Should we eventually include memory /
disk info here?</p></dd>
        
      
        <dt><a name="DEBUG">DEBUG</a></dt>
        
        <dd class="description"><p>This debug flag is used to keep the user’s code on the local filesystem,
which can be useful to debug why code did not run successfully.</p></dd>
        
      
      </dl>
    </div>
    

    <!-- Attributes -->
    
    <div id="attribute-method-details" class="method-section section">
      <h3 class="section-header">Attributes</h3>

      
      <div id="secret-attribute-method" class="method-detail">
        <a name="secret"></a>
        
        <a name="secret="></a>
        
        <div class="method-heading attribute-method-heading">
          <span class="method-name">secret</span><span
            class="attribute-access-type">[RW]</span>
        </div>

        <div class="method-description">
        
        <p>The shared secret that is used to authenticate remote callers.</p>
        
        </div>
      </div>
      
    </div>
    

    <!-- Methods -->
    
    <div id="public-instance-method-details" class="method-section section">
      <h3 class="section-header">Public Instance Methods</h3>

    
      <div id="acquire_nodes-method" class="method-detail ">
        <a name="method-i-acquire_nodes"></a>

        
        <div class="method-heading">
          <span class="method-name">acquire_nodes</span><span
            class="method-args">(job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="acquire_nodes-source">
<pre>
<span class="ruby-comment"># File neptune_manager.rb, line 620</span>
def acquire_nodes(job_data)
  <span class="ruby-comment"># for jobs where no nodes need to be acquired (e.g., concurrent but not</span>
  <span class="ruby-comment"># distributed programs), run them on the shadow node</span>
  if <span class="ruby-constant">NO_NODES_NEEDED</span>.include?(job_data[<span class="ruby-string">&quot;@type&quot;</span>])
    self.log(&quot;No nodes needed for job type [#{job_data['@type']}],&quot; +
      <span class="ruby-string">&quot; not acquiring nodes&quot;</span>)
    return [my_node]
  end

  self.log(<span class="ruby-string">&quot;acquiring nodes&quot;</span>)

  <span class="ruby-comment">#num_of_vms_needed = optimal_nodes_hill_climbing(job_data, &quot;performance&quot;)</span>
  nodes_needed = optimal_nodes(job_data)

  self.log(<span class="ruby-string">&quot;acquiring nodes for hybrid cloud neptune job&quot;</span>)

  if nodes_needed.class == <span class="ruby-constant">Array</span>
    nodes_needed = <span class="ruby-constant">Hash</span>[*nodes_needed]
    self.log(&quot;request received to spawn hybrid nodes: #{nodes_needed.inspect}&quot;)
  elsif nodes_needed.class == <span class="ruby-constant">Fixnum</span>
    nodes_needed = {<span class="ruby-string">&quot;cloud1&quot;</span> =&gt; nodes_needed}
  else
    self.log(&quot;nodes_needed was not the right class - should have been Array or Fixnum but was #{nodes_needed.class}&quot;)
    <span class="ruby-comment"># TODO: find a way to reject the job here</span>
  end

  nodes_to_use = []

  nodes_needed.each { |cloud, nodes_to_acquire|
    <span class="ruby-comment"># nodes_to_acquire can either be an integer or a URL</span>
    <span class="ruby-comment"># if it's an integer, spawn up that many nodes</span>
    <span class="ruby-comment"># if it's a URL, it refers to a remote cloud resource we don't control</span>
    <span class="ruby-comment"># (e.g., Google App Engine), so skip it</span>

    <span class="ruby-comment"># in non-hybrid cloud runs, cloud1 will be the only cloud that specifies</span>
    <span class="ruby-comment"># an integer value</span>
    if nodes_to_acquire =~ <span class="ruby-constant">URL_REGEX</span>
      self.log(&quot;nodes to acquire for #{cloud} was a URL &quot; + 
        &quot;[#{nodes_to_acquire}], so not spawning nodes&quot;)
      next
    end

    self.log(&quot;acquiring #{nodes_to_acquire} nodes for #{cloud}&quot;)
    nodes_for_cloud = find_open_nodes(cloud, nodes_to_acquire, job_data)
    nodes_to_use = [nodes_to_use + nodes_for_cloud].flatten
    <span class="ruby-comment"># TODO: should check for failures acquiring nodes</span>
  }

  return nodes_to_use
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="acquire_nodes_for_cloud-method" class="method-detail ">
        <a name="method-i-acquire_nodes_for_cloud"></a>

        
        <div class="method-heading">
          <span class="method-name">acquire_nodes_for_cloud</span><span
            class="method-args">(cloud_num, new_vms_needed, job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="acquire_nodes_for_cloud-source">
<pre>
<span class="ruby-comment"># File neptune_manager.rb, line 717</span>
def acquire_nodes_for_cloud(cloud_num, new_vms_needed, job_data)
  return if new_vms_needed &lt; 1
  self.log(&quot;spawning up #{new_vms_needed} vms&quot;)

  job = <span class="ruby-string">&quot;open&quot;</span> <span class="ruby-comment"># *_helper will add the right role later</span>
  machine = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;machine&quot;</span>]
  <span class="ruby-constant">ENV</span>[<span class="ruby-string">'EC2_URL'</span>] = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;ec2_url&quot;</span>]
  instance_type = job_data[<span class="ruby-string">'@instance_type'</span>] or <span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;instance_type&quot;</span>]
  keyname = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;keyname&quot;</span>]
  infrastructure = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;infrastructure&quot;</span>]
  group = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;group&quot;</span>]

  <span class="ruby-constant">HelperFunctions</span>.set_creds_in_env(<span class="ruby-ivar">@creds</span>, cloud_num)
  new_node_info = <span class="ruby-constant">HelperFunctions</span>.spawn_vms(new_vms_needed, job, machine,
    instance_type, keyname, infrastructure, &quot;cloud#{cloud_num}&quot;, group)
  add_nodes(new_node_info)
 
  self.log(<span class="ruby-string">&quot;got all the vms i needed!&quot;</span>)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="add_nodes-method" class="method-detail ">
        <a name="method-i-add_nodes"></a>

        
        <div class="method-heading">
          <span class="method-name">add_nodes</span><span
            class="method-args">(node_info)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="add_nodes-source">
<pre>
<span class="ruby-comment"># File neptune_manager.rb, line 737</span>
def add_nodes(node_info)
  keyname = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">'keyname'</span>]
  new_nodes = <span class="ruby-constant">Djinn</span>.convert_location_array_to_class(node_info, keyname)

  node_start_time = <span class="ruby-constant">Time</span>.now
  node_end_time = <span class="ruby-constant">Time</span>.now + <span class="ruby-constant">NOT_QUITE_AN_HOUR</span>

  new_nodes.each { |node|
    node.set_time_info(node_start_time, node_end_time)
  }

  <span class="ruby-ivar">@nodes</span>.concat(new_nodes)
  <span class="ruby-ivar">@neptune_nodes</span>.concat(new_nodes)
  initialize_nodes_in_parallel(new_nodes)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="add_roles_and_wait-method" class="method-detail ">
        <a name="method-i-add_roles_and_wait"></a>

        
        <div class="method-heading">
          <span class="method-name">add_roles_and_wait</span><span
            class="method-args">(nodes, roles)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="add_roles_and_wait-source">
<pre>
<span class="ruby-comment"># File neptune_manager.rb, line 783</span>
def add_roles_and_wait(nodes, roles)
  return if nodes.nil?

  nodes.each { |node|
    node.add_roles(roles)
    acc = <span class="ruby-constant">AppControllerClient</span>.new(node.private_ip, <span class="ruby-constant">HelperFunctions</span>.get_secret)
    acc.add_role(roles)
    acc.wait_for_node_to_be(roles)
    self.log(&quot;[just added] node at #{node.private_ip} is now #{node.jobs.join(', ')}&quot;)
  }
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="add_timing_info-method" class="method-detail ">
        <a name="method-i-add_timing_info"></a>

        
        <div class="method-heading">
          <span class="method-name">add_timing_info</span><span
            class="method-args">(job_data, nodes_to_use, start_time, end_time)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="add_timing_info-source">
<pre>
<span class="ruby-comment"># File neptune_manager.rb, line 997</span>
def add_timing_info(job_data, nodes_to_use, start_time, end_time)
  name = get_job_name(job_data)
  num_nodes = nodes_to_use.length
  this_job = <span class="ruby-constant">NeptuneJobData</span>.new(name, num_nodes, start_time, end_time)
  if <span class="ruby-ivar">@neptune_jobs</span>[name].nil?
    <span class="ruby-ivar">@neptune_jobs</span>[name] = [this_job]
  else
    <span class="ruby-ivar">@neptune_jobs</span>[name] &lt;&lt; this_job
  end
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="appscale_run_job-method" class="method-detail ">
        <a name="method-i-appscale_run_job"></a>

        
        <div class="method-heading">
          <span class="method-name">appscale_run_job</span><span
            class="method-args">(nodes, job_data, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="appscale_run_job-source">
<pre>
<span class="ruby-comment"># File lib/job_types/appscale_helper.rb, line 12</span>
def appscale_run_job(nodes, job_data, secret)
  if !valid_secret?(secret)
    return <span class="ruby-constant">BAD_SECRET_MSG</span>
  end

  <span class="ruby-constant">NeptuneManager</span>.log(<span class="ruby-string">&quot;appscale - run&quot;</span>)

  required_params = %{@time_needed_for @add_component}
  if !has_all_required_params?(job_data, required_params)
    return <span class="ruby-constant">MISSING_PARAM</span>
  end

  <span class="ruby-constant">Thread</span>.new {
    wait_for_allotted_time(job_data)
  }

  return <span class="ruby-constant">STARTED_SUCCESSFULLY</span>
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="babel_run_job-method" class="method-detail ">
        <a name="method-i-babel_run_job"></a>

        
        <div class="method-heading">
          <span class="method-name">babel_run_job</span><span
            class="method-args">(nodes, jobs, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>This method is the spawning service for Babel - that is, it decides where 
tasks should be spawned. For now, we don’t intelligently decide where to
run tasks - we just run tasks where the user tells us to run them. Since
this method is accessible via SOAP, it has a time limit on its execution,
so as soon as we can, we spawn off a new thread to do the real work and
return.</p>
          

          
          <div class="method-source-code"
            id="babel_run_job-source">
<pre>
<span class="ruby-comment"># File lib/job_types/babel_helper.rb, line 184</span>
def babel_run_job(nodes, jobs, secret)
  return <span class="ruby-constant">BAD_SECRET_MSG</span> if !valid_secret?(secret)

  if jobs.class == <span class="ruby-constant">Hash</span>
    jobs = [jobs]
  end

  <span class="ruby-constant">Thread</span>.new {
    run_or_delegate_tasks(jobs)
  }

  return <span class="ruby-string">&quot;OK&quot;</span>
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="can_run_job-method" class="method-detail ">
        <a name="method-i-can_run_job"></a>

        
        <div class="method-heading">
          <span class="method-name">can_run_job</span><span
            class="method-args">(job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="can_run_job-source">
<pre>
<span class="ruby-comment"># File neptune_manager.rb, line 358</span>
def can_run_job(job_data)
  <span class="ruby-comment"># no input / output for appscale jobs</span>
  return :ok if job_data[<span class="ruby-string">&quot;@type&quot;</span>] == <span class="ruby-string">&quot;appscale&quot;</span>

  storage = job_data[<span class="ruby-string">&quot;@storage&quot;</span>]

  if !<span class="ruby-constant">ALLOWED_STORAGE_TYPES</span>.include?(storage)
    return &quot;error: bad storage type - supported types are #{ALLOWED_STORAGE_TYPES.join(', ')}&quot;
  end

  datastore = <span class="ruby-constant">DatastoreFactory</span>.get_datastore(storage, job_data)

  input_location = job_data[<span class="ruby-string">&quot;@input&quot;</span>]
  if input_location and !<span class="ruby-constant">NO_INPUT_NEEDED</span>.include?(job_data[<span class="ruby-string">'@type'</span>])
    input_exists = datastore.does_file_exist?(input_location)
    self.log(&quot;input specified - did #{input_location} exist? #{input_exists}&quot;)
    unless input_exists
      return <span class="ruby-string">&quot;error: input specified but did not exist&quot;</span>
    end
  else
    self.log(<span class="ruby-string">&quot;input not specified - moving on&quot;</span>)
  end

  output_location = job_data[<span class="ruby-string">&quot;@output&quot;</span>]
  output_exists = datastore.does_file_exist?(output_location)
  self.log(&quot;output specified - did #{output_location} exist? #{output_exists}&quot;)
  if output_exists
    return <span class="ruby-string">&quot;error: output already exists&quot;</span>
  end

  self.log(&quot;job type is [#{job_data[&quot;@type&quot;]}]&quot;)

  if <span class="ruby-constant">NO_NODES_NEEDED</span>.include?(job_data[<span class="ruby-string">&quot;@type&quot;</span>])
    return :ok
  else
    unless job_data[<span class="ruby-string">&quot;@nodes_to_use&quot;</span>]
      return <span class="ruby-string">&quot;error: failed to specify nodes_to_use, a required parameter&quot;</span>
    end
  end

  if !(is_cloud? or is_hybrid_cloud?)
    self.log(<span class="ruby-string">&quot;not in cloud&quot;</span>)
    <span class="ruby-comment"># make sure we have enough open nodes</span>
    <span class="ruby-comment"># a bit race-y, see the TODO on set for more info</span>

    <span class="ruby-comment"># In non-hybrid clouds, if the user specifies that they want to run over</span>
    <span class="ruby-comment"># multiple clouds, then either all clouds must be using remote resources</span>
    <span class="ruby-comment"># (e.g., only URLs are specified), or the first cloud has an integer value</span>
    <span class="ruby-comment"># (which we interpret as our cloud) and the others are remote clouds</span>
    if job_data[<span class="ruby-string">&quot;@nodes_to_use&quot;</span>].class == <span class="ruby-constant">Array</span>
      hash_job_data = <span class="ruby-constant">Hash</span>[*job_data[<span class="ruby-string">&quot;@nodes_to_use&quot;</span>]]
      hash_job_data.each { |cloud, nodes_needed|
        if nodes_needed =~ <span class="ruby-constant">URL_REGEX</span>
          self.log(&quot;Saw URL [#{nodes_needed}] for cloud [#{cloud}] - &quot; +
            <span class="ruby-string">&quot;moving on to next cloud&quot;</span>)
          next
        end

        if cloud == <span class="ruby-string">&quot;cloud1&quot;</span> and nodes_needed.class == <span class="ruby-constant">Fixnum</span>
          self.log(&quot;Saw [#{nodes_needed}] nodes needed for cloud &quot; +
            &quot;[#{cloud}] - moving on to next cloud&quot;)
          next
        end

        self.log(&quot;Saw cloud [#{cloud}] and nodes needed &quot; + 
          &quot;[#{nodes_needed}], which was not acceptable in non-hybrid &quot; + 
          <span class="ruby-string">&quot;cloud deployments&quot;</span>)

        return <span class="ruby-string">&quot;error: cannot specify hybrid deployment in non-hybrid cloud runs&quot;</span>
      }

      if hash_job_data[<span class="ruby-string">&quot;cloud1&quot;</span>].class == <span class="ruby-constant">Fixnum</span>
        num_of_vms_needed = <span class="ruby-constant">Integer</span>(hash_job_data[<span class="ruby-string">&quot;cloud1&quot;</span>])
      else
        return :ok
      end
    elsif job_data[<span class="ruby-string">&quot;@nodes_to_use&quot;</span>].class == <span class="ruby-constant">Fixnum</span>
      num_of_vms_needed = <span class="ruby-constant">Integer</span>(job_data[<span class="ruby-string">&quot;@nodes_to_use&quot;</span>])
    else
      return <span class="ruby-string">&quot;error: nodes_to_use specified was not an Array or Fixnum&quot;</span> +
        &quot; but was a #{job_data['@nodes_to_use'].class}&quot;
    end

    nodes_to_use = []
      <span class="ruby-ivar">@nodes</span>.each { |node|
        if node.is_open?
          nodes_to_use &lt;&lt; node
          break if nodes_to_use.length == num_of_vms_needed
        end
      } 

    if nodes_to_use.length &lt; num_of_vms_needed   
      return &quot;error: not enough free nodes (requested = #{num_of_vms_needed}, available = #{nodes_to_use.length})&quot;
    end
  end

  return :ok
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="cleanup_code-method" class="method-detail ">
        <a name="method-i-cleanup_code"></a>

        
        <div class="method-heading">
          <span class="method-name">cleanup_code</span><span
            class="method-args">(code)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="cleanup_code-source">
<pre>
<span class="ruby-comment"># File neptune_manager.rb, line 1009</span>
def cleanup_code(code)
  if code.nil?
    self.log(<span class="ruby-string">&quot;no code to remove&quot;</span>)
  else
    dirs = code.split(<span class="ruby-regexp">/\//</span>)
    code_dir = dirs[0, dirs.length-1].join(<span class="ruby-string">&quot;/&quot;</span>)

    if code_dir == <span class="ruby-string">&quot;/tmp&quot;</span>
      self.log(&quot;can't remove code located at #{code_dir}&quot;)
    else
      self.log(&quot;code is located at #{code_dir}&quot;)
      <span class="ruby-constant">HelperFunctions</span>.shell(&quot;rm -rf #{code_dir}&quot;)
    end
  end
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="compile_code-method" class="method-detail ">
        <a name="method-i-compile_code"></a>

        
        <div class="method-heading">
          <span class="method-name">compile_code</span><span
            class="method-args">(job_data, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="compile_code-source">
<pre>
<span class="ruby-comment"># File neptune_manager.rb, line 326</span>
def compile_code(job_data, secret)
  message = validate_environment(job_data, secret)
  return message unless message == <span class="ruby-string">&quot;no error&quot;</span>

  self.log(<span class="ruby-string">&quot;compiling code&quot;</span>)

  main_file = job_data[<span class="ruby-string">&quot;@main&quot;</span>]
  input_loc = job_data[<span class="ruby-string">&quot;@code&quot;</span>]
  target = job_data[<span class="ruby-string">&quot;@target&quot;</span>]

  compiled_dir = &quot;/tmp/compiled-#{HelperFunctions.get_random_alphanumeric}&quot;

  <span class="ruby-constant">Thread</span>.new {
    makefile = input_loc + <span class="ruby-string">&quot;/Makefile&quot;</span>
    makefile2 = input_loc + <span class="ruby-string">&quot;/makefile&quot;</span>
    if !(<span class="ruby-constant">File</span>.exists?(makefile) or <span class="ruby-constant">File</span>.exists?(makefile2))
      <span class="ruby-constant">HelperFunctions</span>.generate_makefile(main_file, input_loc)
    end

    compile_cmd = &quot;cd #{input_loc}; make #{target} 2&gt;compile_err 1&gt;compile_out&quot;

    self.log(&quot;compiling code by running [#{compile_cmd}]&quot;)

    result = `#{compile_cmd}`
    <span class="ruby-constant">HelperFunctions</span>.shell(&quot;cp -r #{input_loc} #{compiled_dir}&quot;)

  }

  return compiled_dir  
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="copyFromShadow-method" class="method-detail ">
        <a name="method-i-copyFromShadow"></a>

        
        <div class="method-heading">
          <span class="method-name">copyFromShadow</span><span
            class="method-args">(location_on_shadow)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="copyFromShadow-source">
<pre>
<span class="ruby-comment"># File neptune_manager.rb, line 808</span>
def copyFromShadow(location_on_shadow)
  shadow = get_shadow
  shadow_ip = shadow.private_ip
  shadow_key = shadow.ssh_key

  copy_from_shadow = &quot;scp -r -i #{my_node.ssh_key} #{location_on_shadow} root@#{my_node.public_ip}:#{location_on_shadow}&quot;
  <span class="ruby-constant">HelperFunctions</span>.run_remote_command(shadow_ip, copy_from_shadow, shadow_key, <span class="ruby-constant">NO_OUTPUT</span>)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="does_file_exist-method" class="method-detail ">
        <a name="method-i-does_file_exist"></a>

        
        <div class="method-heading">
          <span class="method-name">does_file_exist</span><span
            class="method-args">(file, job_data, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="does_file_exist-source">
<pre>
<span class="ruby-comment"># File neptune_manager.rb, line 246</span>
def does_file_exist(file, job_data, secret)
  datastore = <span class="ruby-constant">DatastoreFactory</span>.get_datastore(job_data[<span class="ruby-string">'@storage'</span>], job_data)
  return datastore.does_file_exist?(file)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="execute_multiple_tasks-method" class="method-detail ">
        <a name="method-i-execute_multiple_tasks"></a>

        
        <div class="method-heading">
          <span class="method-name">execute_multiple_tasks</span><span
            class="method-args">(tasks)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>This method spawns a thread for each task given to execute them in
parallel. It then waits for all tasks to complete before returning.</p>
          

          
          <div class="method-source-code"
            id="execute_multiple_tasks-source">
<pre>
<span class="ruby-comment"># File lib/job_types/babel_helper.rb, line 719</span>
def execute_multiple_tasks(tasks)
  threads = []
  tasks.each { |task|
    threads &lt;&lt; <span class="ruby-constant">Thread</span>.new {
      run_task(task)
    }
  }

  threads.each { |t| t.join }
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="find_neighbors-method" class="method-detail ">
        <a name="method-i-find_neighbors"></a>

        
        <div class="method-heading">
          <span class="method-name">find_neighbors</span><span
            class="method-args">(val, search_space)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="find_neighbors-source">
<pre>
<span class="ruby-comment"># File neptune_manager.rb, line 887</span>
def find_neighbors(val, search_space)
  abort(<span class="ruby-string">&quot;no empty arrays&quot;</span>) if search_space.nil? or search_space.empty?

  left, right = nil, nil
  length = search_space.length
  search_space.each_with_index { |item, index|
    <span class="ruby-comment"># set left</span>
    if index &lt;= 0
      left = val
    else
      left = search_space[index-1]
    end

    <span class="ruby-comment"># set right</span>
    if index &lt; length - 1
      right = search_space[index+1]
    else
      right = val
    end

    break if item == val
  }

  return left, right
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="find_open_nodes-method" class="method-detail ">
        <a name="method-i-find_open_nodes"></a>

        
        <div class="method-heading">
          <span class="method-name">find_open_nodes</span><span
            class="method-args">(cloud, nodes_needed, job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="find_open_nodes-source">
<pre>
<span class="ruby-comment"># File neptune_manager.rb, line 672</span>
def find_open_nodes(cloud, nodes_needed, job_data)
  <span class="ruby-comment"># TODO: assigning nodes -&gt; nodes_to_use should be atomic?</span>
  <span class="ruby-comment"># or should going through this list be atomic?</span>

  cloud_num = cloud.scan(<span class="ruby-regexp">/cloud(.*)/</span>).flatten.to_s

  nodes_to_use = []
  <span class="ruby-ivar">@nodes</span>.each { |node|
    break if nodes_to_use.length == nodes_needed
    if node.is_open? and node.cloud == cloud
      nodes_to_use &lt;&lt; node
    end
  }

  <span class="ruby-ivar">@neptune_nodes</span> = nodes_to_use

  nodes_available = nodes_to_use.length
  new_nodes_needed = nodes_needed - nodes_available
  self.log(&quot;need #{nodes_needed} total, currently have #{nodes_available} to spare&quot;)

  if is_cloud?
    if new_nodes_needed &gt; 0
      self.log(&quot;spawning up #{new_nodes_needed} for neptune job in cloud 1&quot;)
      acquire_nodes_for_cloud(cloud_num, new_nodes_needed, job_data)
    end
  else
    if new_nodes_needed &gt; 0
      self.log(<span class="ruby-string">&quot;non-cloud deployment and the neptune user has asked for too many nodes&quot;</span>)
      <span class="ruby-comment"># TODO: find a way to reject the job here</span>
    end
  end

  nodes_to_use = []
  <span class="ruby-ivar">@neptune_nodes</span>.each { |node|
    break if nodes_to_use.length == nodes_needed
    if node.is_open? and node.cloud == cloud
      self.log(&quot;will use node [#{node}] for computation&quot;)
      nodes_to_use &lt;&lt; node
    end
  }

  return nodes_to_use
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="get_acl-method" class="method-detail ">
        <a name="method-i-get_acl"></a>

        
        <div class="method-heading">
          <span class="method-name">get_acl</span><span
            class="method-args">(job_data, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="get_acl-source">
<pre>
<span class="ruby-comment"># File neptune_manager.rb, line 276</span>
def get_acl(job_data, secret)
  message = validate_environment(job_data, secret)
  return message unless message == <span class="ruby-string">&quot;no error&quot;</span>

  self.log(<span class="ruby-string">&quot;requesting acl&quot;</span>)

  type = job_data[<span class="ruby-string">&quot;@type&quot;</span>]

  output_location = job_data[<span class="ruby-string">&quot;@output&quot;</span>]
  if output_location.nil?
    return <span class="ruby-string">&quot;error: output not specified&quot;</span>
  else
    datastore = <span class="ruby-constant">DatastoreFactory</span>.get_datastore(job_data[<span class="ruby-string">'@storage'</span>], job_data)
    if datastore.does_file_exist?(output_location)
      return datastore.get_acl(output_location)
    else
      return <span class="ruby-string">&quot;error: output does not exist&quot;</span>
    end
  end
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="get_engines_for_creds-method" class="method-detail ">
        <a name="method-i-get_engines_for_creds"></a>

        
        <div class="method-heading">
          <span class="method-name">get_engines_for_creds</span><span
            class="method-args">(job_data, credentials, engines_to_add)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Checks the credentials that the user has given us (job_data) to see if they
match up to the credentials needed for the given engine. If so, we return
the list of engines that can be safely added.</p>
          

          
          <div class="method-source-code"
            id="get_engines_for_creds-source">
<pre>
<span class="ruby-comment"># File lib/job_types/babel_helper.rb, line 163</span>
def get_engines_for_creds(job_data, credentials, engines_to_add)

  credentials.each { |cred|
    if !job_data.include?(cred)
      <span class="ruby-constant">NeptuneManager</span>.log(&quot;credentials did not have #{cred}, so not &quot; +
        &quot;#{engines_to_add.join(', ')}&quot;)
      return []
    end
  }

  <span class="ruby-constant">NeptuneManager</span>.log(&quot;adding engines #{engines_to_add.join(', ')}&quot;)
  return engines_to_add
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="get_job_data-method" class="method-detail ">
        <a name="method-i-get_job_data"></a>

        
        <div class="method-heading">
          <span class="method-name">get_job_data</span><span
            class="method-args">(job_name, time)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="get_job_data-source">
<pre>
<span class="ruby-comment"># File neptune_manager.rb, line 914</span>
def get_job_data(job_name, time)
  relevant_jobs = <span class="ruby-ivar">@neptune_jobs</span>[job_name]
  relevant_jobs.each { |job|
    return job if job.total_time == time
  }

  return nil
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="get_job_name-method" class="method-detail ">
        <a name="method-i-get_job_name"></a>

        
        <div class="method-heading">
          <span class="method-name">get_job_name</span><span
            class="method-args">(job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="get_job_name-source">
<pre>
<span class="ruby-comment"># File neptune_manager.rb, line 770</span>
def get_job_name(job_data)
  job_name = job_data[<span class="ruby-string">&quot;@type&quot;</span>]

  [<span class="ruby-string">&quot;@code&quot;</span>, <span class="ruby-string">&quot;@main&quot;</span>, <span class="ruby-string">&quot;@map&quot;</span>, <span class="ruby-string">&quot;@reduce&quot;</span>, <span class="ruby-string">&quot;@simulations&quot;</span>, <span class="ruby-string">&quot;@add_component&quot;</span>].each { |item|
    if job_data[item]
      job_name += <span class="ruby-string">&quot; - &quot;</span> + &quot;#{job_data[item]}&quot;
    end
  }

  return job_name
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="get_length_of_all_queues-method" class="method-detail ">
        <a name="method-i-get_length_of_all_queues"></a>

        
        <div class="method-heading">
          <span class="method-name">get_length_of_all_queues</span><span
            class="method-args">(queues)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="get_length_of_all_queues-source">
<pre>
<span class="ruby-comment"># File lib/job_types/babel_helper.rb, line 605</span>
def get_length_of_all_queues(queues)
  <span class="ruby-comment"># something to consider: do leased tasks count in the size?</span>
  length = 0
  queues.each { |q|
    length += q.size
  }
  return length
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="get_lock_file_path-method" class="method-detail ">
        <a name="method-i-get_lock_file_path"></a>

        
        <div class="method-heading">
          <span class="method-name">get_lock_file_path</span><span
            class="method-args">(job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="get_lock_file_path-source">
<pre>
<span class="ruby-comment"># File neptune_manager.rb, line 609</span>
def get_lock_file_path(job_data)
  &quot;/tmp/#{job_data['@type']}-#{job_data['@job_id']}-started&quot;
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="get_n_items_of_work-method" class="method-detail ">
        <a name="method-i-get_n_items_of_work"></a>

        
        <div class="method-heading">
          <span class="method-name">get_n_items_of_work</span><span
            class="method-args">(n, queues)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="get_n_items_of_work-source">
<pre>
<span class="ruby-comment"># File lib/job_types/babel_helper.rb, line 615</span>
def get_n_items_of_work(n, queues)
  items = []

  queues.each { |q|
    loop {
      <span class="ruby-constant">NeptuneManager</span>.log(&quot;popping an item of work off of queue #{q}&quot;)
      start_time = <span class="ruby-constant">Time</span>.now
      new_item = q.pop
      end_time = <span class="ruby-constant">Time</span>.now
      if new_item.nil?
        <span class="ruby-constant">NeptuneManager</span>.log(&quot;#{q} is empty - moving on to next queue&quot;)
        break  <span class="ruby-comment"># the queue is empty</span>
      end
  
      <span class="ruby-comment"># add how long it took to grab the item from the queue to our metadata</span>
      if !new_item[<span class="ruby-string">&quot;@metadata_info&quot;</span>]
        new_item = {}
      end
      queue_pop_time = end_time - start_time
      new_item[<span class="ruby-string">'@metadata_info'</span>][<span class="ruby-string">'queue_pop_time'</span>] = queue_pop_time

      <span class="ruby-constant">NeptuneManager</span>.log(&quot;adding [#{new_item}][#{new_item.class}] to items&quot; +
        &quot; - took #{queue_pop_time} seconds to pop it off the queue&quot;)
      items &lt;&lt; new_item

      break if items.length &gt;= n
    }

    break if items.length &gt;= n
  }

  <span class="ruby-constant">NeptuneManager</span>.log(&quot;returning [#{items.join(', ')}] items of work&quot;)
  return items
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="get_node_roles-method" class="method-detail ">
        <a name="method-i-get_node_roles"></a>

        
        <div class="method-heading">
          <span class="method-name">get_node_roles</span><span
            class="method-args">(job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="get_node_roles-source">
<pre>
<span class="ruby-comment"># File neptune_manager.rb, line 489</span>
def get_node_roles(job_data)
  self.log(<span class="ruby-string">&quot;getting node roles&quot;</span>)
  job_type = job_data[<span class="ruby-string">&quot;@type&quot;</span>]

  if job_type == <span class="ruby-string">&quot;appscale&quot;</span>
    component_to_add = job_data[<span class="ruby-string">&quot;@add_component&quot;</span>]
    master_role = component_to_add
    slave_roles = component_to_add
  elsif job_type == <span class="ruby-string">&quot;mapreduce&quot;</span>
    master_role = <span class="ruby-string">&quot;db_slave:mapreduce_master&quot;</span>
    slave_roles = <span class="ruby-string">&quot;db_slave:mapreduce_slave&quot;</span>
  else
    master_role = &quot;#{job_type}_master&quot;
    slave_roles = &quot;#{job_type}_slave&quot;
  end

  self.log(&quot;master role is [#{master_role}], slave roles are &quot; +
    &quot;[#{slave_roles}]&quot;)
  return master_role, slave_roles
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="get_output-method" class="method-detail ">
        <a name="method-i-get_output"></a>

        
        <div class="method-heading">
          <span class="method-name">get_output</span><span
            class="method-args">(job_data, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="get_output-source">
<pre>
<span class="ruby-comment"># File neptune_manager.rb, line 252</span>
def get_output(job_data, secret)
  message = validate_environment(job_data, secret)
  return message unless message == <span class="ruby-string">&quot;no error&quot;</span>

  self.log(<span class="ruby-string">&quot;requesting output&quot;</span>)

  type = job_data[<span class="ruby-string">&quot;@type&quot;</span>]

  output_location = job_data[<span class="ruby-string">&quot;@output&quot;</span>]
  if output_location.nil?
    return <span class="ruby-string">&quot;error: output not specified&quot;</span>
  else
    datastore = <span class="ruby-constant">DatastoreFactory</span>.get_datastore(job_data[<span class="ruby-string">'@storage'</span>], job_data)
    if datastore.does_file_exist?(output_location)
      <span class="ruby-comment"># TODO: maybe write to file or have</span>
      <span class="ruby-comment"># special flag for this?</span>
      return datastore.get_output_and_return_contents(output_location)
    else
      return <span class="ruby-string">&quot;error: output does not exist&quot;</span>
    end
  end
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="get_queues_from_shadow-method" class="method-detail ">
        <a name="method-i-get_queues_from_shadow"></a>

        
        <div class="method-heading">
          <span class="method-name">get_queues_from_shadow</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="get_queues_from_shadow-source">
<pre>
<span class="ruby-comment"># File lib/job_types/babel_helper.rb, line 578</span>
def get_queues_from_shadow()
  secret = <span class="ruby-constant">HelperFunctions</span>.get_secret()
  acc = <span class="ruby-constant">AppControllerClient</span>.new(get_shadow.public_ip, secret)
  json_queue_and_cred_info = acc.get_queues_in_use()
  <span class="ruby-constant">NeptuneManager</span>.log(&quot;raw json received is '#{json_queue_and_cred_info}'&quot;)
  queue_and_cred_info = <span class="ruby-constant">JSON</span>.load(json_queue_and_cred_info)
  <span class="ruby-constant">NeptuneManager</span>.log(&quot;json formatted data is [#{queue_and_cred_info}]&quot;)

  queues = []
  if queue_and_cred_info.nil?
    <span class="ruby-constant">NeptuneManager</span>.log(<span class="ruby-string">&quot;queues from shadow are nil&quot;</span>)
    return queues
  end

  queue_and_cred_info.each { |info|
    <span class="ruby-constant">NeptuneManager</span>.log(&quot;this queue's info is #{info.inspect}&quot;)
    engine = info.keys[0]
    credentials = info.values[0]
    <span class="ruby-constant">NeptuneManager</span>.log(&quot;engine is [#{engine}], credentials are [#{credentials.inspect}]&quot;)
    queues &lt;&lt; <span class="ruby-constant">QueueFactory</span>.get_queue(engine, credentials)
  }

  <span class="ruby-constant">NeptuneManager</span>.log(&quot;queues from shadow are [#{queues.join(', ')}]&quot;)
  return queues
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="get_queues_in_use-method" class="method-detail ">
        <a name="method-i-get_queues_in_use"></a>

        
        <div class="method-heading">
          <span class="method-name">get_queues_in_use</span><span
            class="method-args">(secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Tasks can be stored in multiple queues concurrently, so this method
provides workers (babel_slaves) with the way to learn what queues are
currently in use and the credentials needed to access them.</p>
          

          
          <div class="method-source-code"
            id="get_queues_in_use-source">
<pre>
<span class="ruby-comment"># File lib/job_types/babel_helper.rb, line 296</span>
def get_queues_in_use(secret)
  return <span class="ruby-constant">BAD_SECRET_MSG</span> if !valid_secret?(secret)
  <span class="ruby-constant">NeptuneManager</span>.log(&quot;@queues_to_read is #{@queues_to_read.join(', ')}, class #{@queues_to_read.class}&quot;)
  return <span class="ruby-constant">JSON</span>.dump(<span class="ruby-ivar">@queues_to_read</span>)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="get_seed_vals-method" class="method-detail ">
        <a name="method-i-get_seed_vals"></a>

        
        <div class="method-heading">
          <span class="method-name">get_seed_vals</span><span
            class="method-args">(num_vals)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="get_seed_vals-source">
<pre>
<span class="ruby-comment"># File neptune_manager.rb, line 948</span>
def get_seed_vals(num_vals)
  random_numbers = []
  num_vals.times {
    loop {
      possible_rand = rand(10000)
      unless random_numbers.include?(possible_rand)
        random_numbers &lt;&lt; possible_rand
        break
      end
    }
  }

  return random_numbers
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="get_supported_babel_engines-method" class="method-detail ">
        <a name="method-i-get_supported_babel_engines"></a>

        
        <div class="method-heading">
          <span class="method-name">get_supported_babel_engines</span><span
            class="method-args">(job_data, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Tasks can execute over a number of different engines (a queue and an
executor). From the credentials the user has given us (job_data), determine
which engines can be used.</p>
          

          
          <div class="method-source-code"
            id="get_supported_babel_engines-source">
<pre>
<span class="ruby-comment"># File lib/job_types/babel_helper.rb, line 138</span>
def get_supported_babel_engines(job_data, secret)
  return <span class="ruby-constant">BAD_SECRET_MSG</span> if !valid_secret?(secret)

  <span class="ruby-constant">NeptuneManager</span>.log(&quot;checking supported engines for job data #{job_data.inspect}&quot;)

  <span class="ruby-comment"># all jobs can use the internal engines</span>
  engines = <span class="ruby-constant">INTERNAL_ENGINES</span>

  <span class="ruby-comment"># but not necessarily the others, so check them one by one</span>
  engines &lt;&lt; get_engines_for_creds(job_data, <span class="ruby-constant">AMAZON_CREDENTIALS</span>, <span class="ruby-constant">AMAZON_ENGINES</span>)
  engines &lt;&lt; get_engines_for_creds(job_data, <span class="ruby-constant">AZURE_CREDENTIALS</span>, <span class="ruby-constant">AZURE_ENGINES</span>)
  engines &lt;&lt; get_engines_for_creds(job_data, <span class="ruby-constant">GOOGLE_CREDENTIALS</span>, <span class="ruby-constant">GOOGLE_ENGINES</span>)
 
  <span class="ruby-comment"># since we're appending arrays to arrays but want it to be a 1D array</span>
  engines.flatten!.uniq!

  <span class="ruby-constant">NeptuneManager</span>.log(&quot;supported engines for job data #{job_data.inspect} are [#{engines.join(', ')}]&quot;)

  return engines
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="has_all_required_params-3F-method" class="method-detail ">
        <a name="method-i-has_all_required_params-3F"></a>

        
        <div class="method-heading">
          <span class="method-name">has_all_required_params?</span><span
            class="method-args">(job_data, required_params)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Verifies that the given job_data has all of the parameters specified by
required_params.</p>
          

          
          <div class="method-source-code"
            id="has_all_required_params-3F-source">
<pre>
<span class="ruby-comment"># File neptune_manager.rb, line 986</span>
def has_all_required_params?(job_data, required_params)
  required_params.each { |param|
    if job_data[param].nil?
      return false
    end
  }

  return true
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="is_job_running-method" class="method-detail ">
        <a name="method-i-is_job_running"></a>

        
        <div class="method-heading">
          <span class="method-name">is_job_running</span><span
            class="method-args">(job_data, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="is_job_running-source">
<pre>
<span class="ruby-comment"># File neptune_manager.rb, line 186</span>
def is_job_running(job_data, secret)
  return <span class="ruby-constant">BAD_SECRET_MSG</span> unless valid_secret?(secret)
  return lock_file_exists?(job_data)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="is_storage_location-3F-method" class="method-detail ">
        <a name="method-i-is_storage_location-3F"></a>

        
        <div class="method-heading">
          <span class="method-name">is_storage_location?</span><span
            class="method-args">(file)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="is_storage_location-3F-source">
<pre>
<span class="ruby-comment"># File lib/job_types/babel_helper.rb, line 573</span>
def is_storage_location?(file)
  return <span class="ruby-constant">STORAGE_PARAM_REGEX</span>.match(file)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="lock_file_exists-3F-method" class="method-detail ">
        <a name="method-i-lock_file_exists-3F"></a>

        
        <div class="method-heading">
          <span class="method-name">lock_file_exists?</span><span
            class="method-args">(job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="lock_file_exists-3F-source">
<pre>
<span class="ruby-comment"># File neptune_manager.rb, line 587</span>
def lock_file_exists?(job_data)
  return <span class="ruby-constant">File</span>.exists?(get_lock_file_path(job_data))
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="optimal_nodes-method" class="method-detail ">
        <a name="method-i-optimal_nodes"></a>

        
        <div class="method-heading">
          <span class="method-name">optimal_nodes</span><span
            class="method-args">(job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="optimal_nodes-source">
<pre>
<span class="ruby-comment"># File neptune_manager.rb, line 818</span>
def optimal_nodes(job_data)
  return job_data[<span class="ruby-string">&quot;@nodes_to_use&quot;</span>]
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="optimal_nodes_hill_climbing-method" class="method-detail ">
        <a name="method-i-optimal_nodes_hill_climbing"></a>

        
        <div class="method-heading">
          <span class="method-name">optimal_nodes_hill_climbing</span><span
            class="method-args">(job_data, thing_to_optimize)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Hill Climbing Algorithm    # find minimum execution time t1    # find
neighbors t0 and t2    # if t0 is too low set it to t1    # if t2 is too
high set it to t1    # if no data for either, choose t2    # if no data for
t0, choose t0    # if data for both, choose t1</p>
          

          
          <div class="method-source-code"
            id="optimal_nodes_hill_climbing-source">
<pre>
<span class="ruby-comment"># File neptune_manager.rb, line 835</span>
def optimal_nodes_hill_climbing(job_data, thing_to_optimize)
  job_name = get_job_name(job_data)

  if thing_to_optimize != <span class="ruby-string">&quot;cost&quot;</span> and thing_to_optimize != <span class="ruby-string">&quot;performance&quot;</span>
    abort(&quot;bad thing to optimize - can be cost or performance but was #{thing_to_optimize}&quot;)
  end

  current_data = <span class="ruby-ivar">@neptune_jobs</span>[job_name]
  if current_data.nil? or current_data.empty?
    self.log(&quot;neptune - no job data yet for [#{job_name}]&quot;)
    return job_data[<span class="ruby-string">&quot;@nodes_to_use&quot;</span>]
  end

  self.log(&quot;found job data for [#{job_name}]&quot;)

  min_val = <span class="ruby-constant">INFINITY</span>
  optimal_job = nil
  current_data.each { |job|
    self.log(&quot;current job data is [#{job}]&quot;)

    if thing_to_optimize == <span class="ruby-string">&quot;performance&quot;</span>
      my_val = job.total_time
    elsif thing_to_optimize == <span class="ruby-string">&quot;cost&quot;</span>
      my_val = job.cost
    else
      abort(<span class="ruby-string">&quot;bad thing to optimize again&quot;</span>)
    end

    if my_val &lt; min_val
      self.log(&quot;found a new minimum - [#{job}]&quot;)
      optimal_job = job
    end
  }

  self.log(&quot;minimum is - [#{optimal_job}]&quot;)

  search_space = job_data[<span class="ruby-string">&quot;@can_run_on&quot;</span>]
  t1 = optimal_job.num_nodes

  self.log(&quot;optimal right now is t1 = #{t1}&quot;)
  t0, t2 = find_neighbors(t1, search_space)
  self.log(&quot;t1's neighbors are #{t0} and t2 = #{t2}&quot;)

  d0 = get_job_data(job_name, t0)
  d2 = get_job_data(job_name, t2)

  return t2 if d0.nil? and d2.nil?
  return t0 if d0.nil?
  return t1
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="put_input-method" class="method-detail ">
        <a name="method-i-put_input"></a>

        
        <div class="method-heading">
          <span class="method-name">put_input</span><span
            class="method-args">(job_data, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="put_input-source">
<pre>
<span class="ruby-comment"># File neptune_manager.rb, line 192</span>
def put_input(job_data, secret)
  message = validate_environment(job_data, secret)
  return message unless message == <span class="ruby-string">&quot;no error&quot;</span>

  self.log(<span class="ruby-string">&quot;requesting input&quot;</span>)

  type = job_data[<span class="ruby-string">&quot;@type&quot;</span>]

  [<span class="ruby-string">&quot;type&quot;</span>, <span class="ruby-string">&quot;storage&quot;</span>, <span class="ruby-string">&quot;local&quot;</span>, <span class="ruby-string">&quot;remote&quot;</span>].each { |item|
    if job_data[&quot;@#{item}&quot;].nil?
      return &quot;error: #{item} not specified&quot;
    end
  }

  input_location = job_data[<span class="ruby-string">&quot;@remote&quot;</span>]

  local_fs_location = <span class="ruby-constant">File</span>.expand_path(job_data[<span class="ruby-string">&quot;@local&quot;</span>])

  loop {
    self.log(&quot;waiting for file #{local_fs_location} to exist&quot;)
    break if <span class="ruby-constant">File</span>.exists?(local_fs_location)
    sleep(1)
  }

  msg = &quot;storing local file #{local_fs_location} with size &quot; + 
    &quot;#{File.size(local_fs_location)}, storing to #{input_location}&quot;

  self.log(msg)

  datastore = <span class="ruby-constant">DatastoreFactory</span>.get_datastore(job_data[<span class="ruby-string">'@storage'</span>], job_data)
  ret_val = datastore.write_remote_file_from_local_file(input_location, local_fs_location)

  <span class="ruby-comment"># also, if we're running on hbase or hypertable, put a copy of the data</span>
  <span class="ruby-comment"># into HDFS for later processing via mapreduce</span>

  table = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;table&quot;</span>]

  if [<span class="ruby-string">&quot;hbase&quot;</span>, <span class="ruby-string">&quot;hypertable&quot;</span>].include?(table)
    unless my_node.is_db_master?
      db_master = get_db_master
      ip = db_master.private_ip
      ssh_key = db_master.ssh_key
      <span class="ruby-constant">HelperFunctions</span>.scp_file(local_fs_location, local_fs_location, ip, ssh_key)
    end

    cmd = &quot;#{HADOOP} fs -put #{local_fs_location} #{input_location}&quot;
    self.log(&quot;putting input in hadoop with command [#{cmd}]&quot;)
    run_on_db_master(cmd)
  end

  return ret_val
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="release_nodes-method" class="method-detail ">
        <a name="method-i-release_nodes"></a>

        
        <div class="method-heading">
          <span class="method-name">release_nodes</span><span
            class="method-args">(nodes_to_use, job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="release_nodes-source">
<pre>
<span class="ruby-comment"># File neptune_manager.rb, line 754</span>
def release_nodes(nodes_to_use, job_data)
  if is_hybrid_cloud?
    abort(<span class="ruby-string">&quot;hybrid cloud mode is definitely not supported&quot;</span>)
  elsif is_cloud?
    nodes_to_use.each { |node|
      node.set_roles(<span class="ruby-string">&quot;open&quot;</span>)
    }

    <span class="ruby-comment"># don't worry about terminating the vms - the appcontroller</span>
    <span class="ruby-comment"># will take care of this in its heartbeat loop</span>
  else
    return
  end
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="remove_lock_file-method" class="method-detail ">
        <a name="method-i-remove_lock_file"></a>

        
        <div class="method-heading">
          <span class="method-name">remove_lock_file</span><span
            class="method-args">(job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="remove_lock_file-source">
<pre>
<span class="ruby-comment"># File neptune_manager.rb, line 599</span>
def remove_lock_file(job_data)
  shadow = get_shadow
  shadow_ip = shadow.private_ip
  shadow_key = shadow.ssh_key
  done_running = &quot;rm #{get_lock_file_path(job_data)}&quot;

  <span class="ruby-constant">HelperFunctions</span>.run_remote_command(shadow_ip, done_running, shadow_key, <span class="ruby-constant">NO_OUTPUT</span>)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="remove_roles-method" class="method-detail ">
        <a name="method-i-remove_roles"></a>

        
        <div class="method-heading">
          <span class="method-name">remove_roles</span><span
            class="method-args">(nodes, roles)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="remove_roles-source">
<pre>
<span class="ruby-comment"># File neptune_manager.rb, line 796</span>
def remove_roles(nodes, roles)
  return if nodes.nil?

  nodes.each { |node|
    node.remove_roles(roles)
    acc = <span class="ruby-constant">AppControllerClient</span>.new(node.private_ip, <span class="ruby-constant">HelperFunctions</span>.get_secret)
    acc.remove_role(roles)
    self.log(&quot;[just removed] node at #{node.private_ip} is now #{node.jobs.join(', ')}&quot;)
  }
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="run_job_on_master-method" class="method-detail ">
        <a name="method-i-run_job_on_master"></a>

        
        <div class="method-heading">
          <span class="method-name">run_job_on_master</span><span
            class="method-args">(master_node, nodes_to_use, job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="run_job_on_master-source">
<pre>
<span class="ruby-comment"># File neptune_manager.rb, line 511</span>
def run_job_on_master(master_node, nodes_to_use, job_data)
  self.log(<span class="ruby-string">&quot;run job on master&quot;</span>)
  converted_nodes = <span class="ruby-constant">Djinn</span>.convert_location_class_to_array(nodes_to_use)

  <span class="ruby-comment"># in cases where only remote resources are used, we don't acquire a master</span>
  <span class="ruby-comment"># node. therefore, let this node be the master node for this job</span>
  if master_node.nil?
    self.log(<span class="ruby-string">&quot;No master node found - using my node as the master node&quot;</span>)
    master_node = my_node
  end

  master_node_ip = master_node.private_ip
  master_acc = <span class="ruby-constant">AppControllerClient</span>.new(master_node_ip, <span class="ruby-constant">HelperFunctions</span>.get_secret)

  result = master_acc.run_neptune_job(converted_nodes, job_data)
  self.log(&quot;run job result was #{result}&quot;)

  loop {
    shadow = get_shadow
    lock_file = get_lock_file_path(job_data)
    command = &quot;ls #{lock_file}; echo $?&quot;
    self.log(&quot;shadow's ssh key is #{shadow.ssh_key}&quot;)
    job_is_running = `ssh -i #{shadow.ssh_key} -o StrictHostkeyChecking=no root@#{shadow.private_ip} '#{command}'`
    self.log(&quot;is job running? [#{job_is_running}]&quot;)
    if job_is_running.length &gt; 1
      return_val = job_is_running[-2].chr
      self.log(&quot;return val for file #{lock_file} is #{return_val}&quot;)
      break if return_val != <span class="ruby-string">&quot;0&quot;</span>
    end
    sleep(30)
  }
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="run_or_delegate_tasks-method" class="method-detail ">
        <a name="method-i-run_or_delegate_tasks"></a>

        
        <div class="method-heading">
          <span class="method-name">run_or_delegate_tasks</span><span
            class="method-args">(jobs)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="run_or_delegate_tasks-source">
<pre>
<span class="ruby-comment"># File lib/job_types/babel_helper.rb, line 199</span>
def run_or_delegate_tasks(jobs)
  where_tasks_were_run = []

  jobs.each { |job|
    <span class="ruby-constant">NeptuneManager</span>.log(&quot;prejob - this job's data is #{job.inspect}&quot;)
  }

  jobs.each { |job|
    job_data = job.dup
    <span class="ruby-constant">NeptuneManager</span>.log(&quot;This job's data is #{job_data.inspect}&quot;)

    <span class="ruby-comment"># Add in a metadata hash so that any method can add in profiling info,</span>
    <span class="ruby-comment"># with an initial piece of data - when we received the task to run.</span>
    if !job_data[<span class="ruby-string">'@metadata_info'</span>]
      job_data[<span class="ruby-string">'@metadata_info'</span>] = {}
    end

    job_data[<span class="ruby-string">'@metadata_info'</span>][<span class="ruby-string">'received_task_at'</span>] = <span class="ruby-constant">Time</span>.now.to_f
    job_data[<span class="ruby-string">'@metadata_info'</span>][<span class="ruby-string">'queue_pop_time'</span>] = 0.0

    if job_data[<span class="ruby-string">'@run_local'</span>]
      <span class="ruby-constant">NeptuneManager</span>.log(&quot;running job with data #{job_data.inspect} locally&quot;)
      run_task(job_data)
      where_tasks_were_run &lt;&lt; <span class="ruby-constant">RUN_LOCALLY</span>
      next
    end

    engine = job_data[<span class="ruby-string">'@engine'</span>]
    if engine.include?(<span class="ruby-string">&quot;executor&quot;</span>)
      run_via_executor(engine, job_data)
      where_tasks_were_run &lt;&lt; <span class="ruby-constant">RUN_VIA_EXECUTOR</span>
      next
    else
      run_via_engine(engine, job_data)
      where_tasks_were_run &lt;&lt; <span class="ruby-constant">RUN_VIA_REMOTE_ENGINE</span>
      next
    end
  }

  return where_tasks_were_run
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="run_task-method" class="method-detail ">
        <a name="method-i-run_task"></a>

        
        <div class="method-heading">
          <span class="method-name">run_task</span><span
            class="method-args">(job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="run_task-source">
<pre>
<span class="ruby-comment"># File lib/job_types/babel_helper.rb, line 373</span>
def run_task(job_data)
  dir = <span class="ruby-constant">Djinn</span>.create_temp_dir()
  <span class="ruby-constant">Djinn</span>.copy_code_and_inputs_to_dir(job_data, dir)
  output, error = <span class="ruby-constant">Djinn</span>.run_code(job_data, dir)
  <span class="ruby-constant">Djinn</span>.write_babel_outputs(output, error, job_data)
  <span class="ruby-constant">Djinn</span>.cleanup(dir)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="run_via_engine-method" class="method-detail ">
        <a name="method-i-run_via_engine"></a>

        
        <div class="method-heading">
          <span class="method-name">run_via_engine</span><span
            class="method-args">(engine, job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Tasks may also be run via remote engines - that is, they may have an
internal queue but definitely have a remote executor that we can blindly
push the task to and let it take care of.</p>
          

          
          <div class="method-source-code"
            id="run_via_engine-source">
<pre>
<span class="ruby-comment"># File lib/job_types/babel_helper.rb, line 274</span>
def run_via_engine(engine, job_data)
  <span class="ruby-constant">NeptuneManager</span>.log(&quot;running job with data #{job_data.inspect} via a remote engine&quot;)

  <span class="ruby-comment"># When pushing jobs to AppScale's push queues, we need to know where the</span>
  <span class="ruby-comment"># app is located (via the login node's IP address) and the UserAppServer's</span>
  <span class="ruby-comment"># IP address, so pass that info along.</span>
  if engine == <span class="ruby-string">&quot;appscale-push-q&quot;</span>
    job_data[<span class="ruby-string">'@login_ip'</span>] = get_login.public_ip
    job_data[<span class="ruby-string">'@uaserver_ip'</span>] = <span class="ruby-ivar">@userappserver_public_ip</span>
    job_data[<span class="ruby-string">'@secret'</span>] = <span class="ruby-constant">HelperFunctions</span>.get_secret()
    <span class="ruby-constant">NeptuneManager</span>.log(<span class="ruby-string">&quot;Adding info for AppScale push queues - &quot;</span> +
      &quot;job data is now #{job_data.inspect}&quot;)
  end

  e = <span class="ruby-constant">EngineFactory</span>.get_engine(engine, job_data)
  e.push(job_data)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="run_via_executor-method" class="method-detail ">
        <a name="method-i-run_via_executor"></a>

        
        <div class="method-heading">
          <span class="method-name">run_via_executor</span><span
            class="method-args">(engine, job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Tasks can be run via our task executor, which will run tasks within
AppScale and store task data in a queue service, which may not be local to
AppScale.</p>
          

          
          <div class="method-source-code"
            id="run_via_executor-source">
<pre>
<span class="ruby-comment"># File lib/job_types/babel_helper.rb, line 244</span>
def run_via_executor(engine, job_data)
  <span class="ruby-constant">NeptuneManager</span>.log(&quot;running job with data #{job_data.inspect} via executor&quot;)
  q = <span class="ruby-constant">QueueFactory</span>.get_queue(engine, job_data)
  credentials = q.get_creds()
  queue_and_creds = {engine =&gt; credentials}

  <span class="ruby-comment"># the user has to tell us the maximum number of machines that can be used</span>
  <span class="ruby-comment"># for babel slaves, so update that info in ZooKeeper</span>
  <span class="ruby-constant">ZKInterface</span>.set_max_machines_for_babel_slaves(job_data[<span class="ruby-string">'@global_max_nodes'</span>])

  <span class="ruby-comment"># since the same queue / credentials can be used repeatedly, don't keep</span>
  <span class="ruby-comment"># adding the same queue info over and over again</span>
  if <span class="ruby-ivar">@queues_to_read</span>.include?(queue_and_creds)
    <span class="ruby-constant">NeptuneManager</span>.log(&quot;not adding queue and creds #{queue_and_creds.inspect} &quot; +
      <span class="ruby-string">&quot;to @queues_to_read - it's already in the list&quot;</span>)
  else
    <span class="ruby-constant">NeptuneManager</span>.log(&quot;adding queue and creds #{queue_and_creds.inspect} to &quot; +
      <span class="ruby-string">&quot;@queues_to_read&quot;</span>)
    <span class="ruby-ivar">@queues_to_read</span> &lt;&lt; queue_and_creds
  end

  <span class="ruby-constant">NeptuneManager</span>.log(<span class="ruby-string">&quot;@queues_to_read now contains &quot;</span> +
    &quot;[#{@queues_to_read.join(', ')}]&quot;)
  q.push(job_data)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="set_acl-method" class="method-detail ">
        <a name="method-i-set_acl"></a>

        
        <div class="method-heading">
          <span class="method-name">set_acl</span><span
            class="method-args">(job_data, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="set_acl-source">
<pre>
<span class="ruby-comment"># File neptune_manager.rb, line 298</span>
def set_acl(job_data, secret)
  message = validate_environment(job_data, secret)
  return message unless message == <span class="ruby-string">&quot;no error&quot;</span>

  self.log(<span class="ruby-string">&quot;setting acl&quot;</span>)

  type = job_data[<span class="ruby-string">&quot;@type&quot;</span>]

  new_acl = job_data[<span class="ruby-string">&quot;@acl&quot;</span>]

  if new_acl != <span class="ruby-string">&quot;public&quot;</span> and new_acl != <span class="ruby-string">&quot;private&quot;</span>
    return <span class="ruby-string">&quot;error: new acl is neither public nor private&quot;</span>
  end

  output_location = job_data[<span class="ruby-string">&quot;@output&quot;</span>]
  if output_location.nil?
    return <span class="ruby-string">&quot;error: output not specified&quot;</span>
  else
    datastore = <span class="ruby-constant">DatastoreFactory</span>.get_datastore(job_data[<span class="ruby-string">'@storage'</span>], job_data)
    if datastore.does_file_exist?(output_location)
      return datastore.set_acl(output_location, new_acl)
    else
      return <span class="ruby-string">&quot;error: output does not exist&quot;</span>
    end
  end
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="spawn_babel_slaves-method" class="method-detail ">
        <a name="method-i-spawn_babel_slaves"></a>

        
        <div class="method-heading">
          <span class="method-name">spawn_babel_slaves</span><span
            class="method-args">(num_of_waiting_tasks)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>A Babel master can call this method to add more workers (Babel slaves) to
the system as needed.</p>
          

          
          <div class="method-source-code"
            id="spawn_babel_slaves-source">
<pre>
<span class="ruby-comment"># File lib/job_types/babel_helper.rb, line 653</span>
def spawn_babel_slaves(num_of_waiting_tasks)
  <span class="ruby-constant">NeptuneManager</span>.log(&quot;spawning workers to handle #{num_of_waiting_tasks} tasks&quot;)

  if is_cloud?
    instance_type = <span class="ruby-string">&quot;m1.large&quot;</span>
    <span class="ruby-comment">#instance_type = &quot;m2.4xlarge&quot;</span>
    cores_per_machine = <span class="ruby-constant">INSTANCE_CPU_INFO</span>[instance_type]
  else
    instance_type = <span class="ruby-string">&quot;m1.large&quot;</span>
    cores_per_machine = 2
  end
  <span class="ruby-constant">NeptuneManager</span>.log(&quot;Using #{cores_per_machine} cores/machine&quot;)

  <span class="ruby-comment"># First, calculate how many machines we would need to run all the tasks</span>
  <span class="ruby-comment"># as fast as possible, by running one task per core.</span>
  optimal_num_of_vms = (num_of_waiting_tasks / <span class="ruby-constant">Float</span>(cores_per_machine)).ceil
  <span class="ruby-constant">NeptuneManager</span>.log(&quot;Will run #{num_of_waiting_tasks} on &quot; +
    &quot;#{optimal_num_of_vms} VMs&quot;)

  <span class="ruby-comment"># The optimal number of VMs is optimal with respect to performance, but</span>
  <span class="ruby-comment"># is not optimal with respect to cost. As the user has told us what the</span>
  <span class="ruby-comment"># maximum number of machines they want to run are, grab that number and</span>
  <span class="ruby-comment"># compare the two to see how many machines we should actually acquire.</span>
  user_num_of_vms = <span class="ruby-constant">ZKInterface</span>.get_max_machines_for_babel_slaves()

  total_num_of_vms_needed = [optimal_num_of_vms, user_num_of_vms].min
  <span class="ruby-constant">NeptuneManager</span>.log(&quot;For #{num_of_waiting_tasks} tasks, the optimal number of &quot; +
    &quot;VMs to use is #{optimal_num_of_vms} VMs, while the user specified that &quot; +
    &quot;no more than #{user_num_of_vms} VMs - using #{total_num_of_vms_needed} &quot; +
    <span class="ruby-string">&quot;total VMs&quot;</span>)

  <span class="ruby-comment"># A previous invocation of this function may have already spawned up</span>
  <span class="ruby-comment"># babel slaves, so to obey the maximum that the user has given us, we have to</span>
  <span class="ruby-comment"># subtract any already running babel slaves out of the value calculated above.</span>
  babel_slaves_already_running = 0
  <span class="ruby-ivar">@nodes</span>.each { |node|
    babel_slaves_already_running += 1 if node.is_babel_slave?
  }

  num_of_vms_needed = total_num_of_vms_needed - babel_slaves_already_running

  if num_of_vms_needed &gt; 0
    <span class="ruby-constant">NeptuneManager</span>.log(&quot;#{babel_slaves_already_running} VMs are already running &quot; +
      &quot;as babel slaves, so we still need to spawn #{num_of_vms_needed} VMs&quot;)

    <span class="ruby-comment"># Include rabbitmq_slave in here since we want to always be able to point</span>
    <span class="ruby-comment"># our RabbitMQ client to localhost to get tasks</span>
    nodes_needed = []
    num_of_vms_needed.times { |i|
      nodes_needed &lt;&lt; [<span class="ruby-string">&quot;rabbitmq_slave&quot;</span>, <span class="ruby-string">&quot;babel_slave&quot;</span>]
    }

    start_new_roles_on_nodes(nodes_needed, instance_type,
      <span class="ruby-constant">HelperFunctions</span>.get_secret())
  else
    <span class="ruby-constant">NeptuneManager</span>.log(&quot;#{babel_slaves_already_running} VMs are already &quot; +
      &quot;running, and as can only have a maximum of #{num_of_vms_needed}, we &quot; +
      <span class="ruby-string">&quot;don't need to acquire more babel slaves right now&quot;</span>)
  end

  return
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="spawn_nodes_for_neptune-3F-method" class="method-detail ">
        <a name="method-i-spawn_nodes_for_neptune-3F"></a>

        
        <div class="method-heading">
          <span class="method-name">spawn_nodes_for_neptune?</span><span
            class="method-args">(job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="spawn_nodes_for_neptune-3F-source">
<pre>
<span class="ruby-comment"># File neptune_manager.rb, line 614</span>
def spawn_nodes_for_neptune?(job_data)
  self.log(&quot;neptune_info = #{job_data}&quot;)
  return !job_data[<span class="ruby-string">&quot;@nodes_to_use&quot;</span>].nil?
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="start_babel_master-method" class="method-detail ">
        <a name="method-i-start_babel_master"></a>

        
        <div class="method-heading">
          <span class="method-name">start_babel_master</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>The nodes that runs as a babel_master is a master in the system. It decides
when to spawn new workers, and how many to spawn, based on the number of
tasks waiting to be executed in all queues.</p>
          

          
          <div class="method-source-code"
            id="start_babel_master-source">
<pre>
<span class="ruby-comment"># File lib/job_types/babel_helper.rb, line 306</span>
def start_babel_master()
  <span class="ruby-constant">NeptuneManager</span>.log(&quot;#{my_node.private_ip} is starting babel master&quot;)

  while !<span class="ruby-ivar">@kill_sig_received</span> do
    queues = get_queues_from_shadow()
    num_of_waiting_tasks = get_length_of_all_queues(queues)
    if num_of_waiting_tasks.zero?
      <span class="ruby-constant">NeptuneManager</span>.log(<span class="ruby-string">&quot;all queues are empty - waiting for tasks to arrive&quot;</span>)
      <span class="ruby-constant">Kernel</span>.sleep(<span class="ruby-constant">TIME_TO_WAIT_FOR_NEW_TASKS</span>)
    else
      spawn_babel_slaves(num_of_waiting_tasks)
      <span class="ruby-constant">NeptuneManager</span>.log(<span class="ruby-string">&quot;workers spawned - waiting for them to run tasks&quot;</span>)
      <span class="ruby-constant">Kernel</span>.sleep(<span class="ruby-constant">TIME_FOR_NEW_NODES_TO_GET_TASKS</span>)
    end
  end
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="start_babel_slave-method" class="method-detail ">
        <a name="method-i-start_babel_slave"></a>

        
        <div class="method-heading">
          <span class="method-name">start_babel_slave</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Nodes that run as babel_slaves are workers in the system. They ask the
master what queues tasks are stored on, and try to execute a configurable
number of tasks at a time.</p>
          

          
          <div class="method-source-code"
            id="start_babel_slave-source">
<pre>
<span class="ruby-comment"># File lib/job_types/babel_helper.rb, line 327</span>
def start_babel_slave()
  <span class="ruby-constant">Thread</span>.new {
  <span class="ruby-constant">NeptuneManager</span>.log(&quot;#{my_node.private_ip} is starting babel slave&quot;)

  time_spent_idle = 0.0
  loop {
    queues = get_queues_from_shadow()
    cores_per_machine = <span class="ruby-constant">HelperFunctions</span>.get_num_cpus()
    tasks = get_n_items_of_work(cores_per_machine, queues)
    if tasks.length.zero?
      if time_spent_idle &gt; <span class="ruby-constant">MAX_IDLE_TIME</span>
        <span class="ruby-constant">NeptuneManager</span>.log(<span class="ruby-string">&quot;Spent too much time idle - reverting to open for now&quot;</span>)
        break
      else
        <span class="ruby-constant">NeptuneManager</span>.log(<span class="ruby-string">&quot;no tasks found, waiting for more to arrive&quot;</span>)
        <span class="ruby-constant">Kernel</span>.sleep(<span class="ruby-constant">TIME_TO_WAIT_FOR_NEW_TASKS</span>)
        time_spent_idle += <span class="ruby-constant">TIME_TO_WAIT_FOR_NEW_TASKS</span>
      end
    else
      <span class="ruby-constant">NeptuneManager</span>.log(&quot;#{tasks.length} tasks found, executing&quot;)
      execute_multiple_tasks(tasks)
      time_spent_idle = 0.0
    end
  }

  <span class="ruby-constant">NeptuneManager</span>.log(<span class="ruby-string">&quot;Removing babel slave roles from this node&quot;</span>)
  <span class="ruby-constant">ZKInterface</span>.lock_and_run {
    <span class="ruby-constant">ZKInterface</span>.remove_roles_from_node([<span class="ruby-string">&quot;rabbitmq_slave, &quot;</span><span class="ruby-string">&quot;babel_slave&quot;</span>], 
      my_node)
    <span class="ruby-constant">ZKInterface</span>.add_roles_to_node([<span class="ruby-string">&quot;open&quot;</span>], my_node)
  }
  <span class="ruby-constant">NeptuneManager</span>.log(<span class="ruby-string">&quot;Finished removing roles via ZooKeeper&quot;</span>)
  }
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="start_job-method" class="method-detail ">
        <a name="method-i-start_job"></a>

        
        <div class="method-heading">
          <span class="method-name">start_job</span><span
            class="method-args">(jobs, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="start_job-source">
<pre>
<span class="ruby-comment"># File neptune_manager.rb, line 106</span>
def start_job(jobs, secret)
  if jobs.class == <span class="ruby-constant">Hash</span>
    jobs = [jobs]
  end

  <span class="ruby-constant">Thread</span>.new {
    can_run_at_once = true
    jobs.each { |job_data|
      if !job_data[<span class="ruby-string">'@type'</span>] == <span class="ruby-string">&quot;babel&quot;</span>
        self.log(&quot;job data #{job_data.inspect} is not a babel job - &quot; +
          <span class="ruby-string">&quot; not running in parallel&quot;</span>)
        can_run_at_once = false
        break
      end
    }

    if can_run_at_once
        self.log(<span class="ruby-string">&quot;running jobs with optimized path&quot;</span>)
        <span class="ruby-comment"># TODO(cgb): be a bit more intelligent about batch_info</span>
        <span class="ruby-comment"># e.g., it's global_nodes should be the max of all in jobs</span>
        batch_info = jobs[0]
        touch_lock_file(batch_info)

        nodes_to_use = acquire_nodes(batch_info)

        self.log(&quot;nodes to use are [#{nodes_to_use.join(', ')}]&quot;)
        start_job(nodes_to_use, batch_info)

        start_time = <span class="ruby-constant">Time</span>.now()
        master_node = nodes_to_use.first 
        run_job_on_master(master_node, nodes_to_use, jobs)
        end_time = <span class="ruby-constant">Time</span>.now()

        stop_job(nodes_to_use, job_data)

        release_nodes(nodes_to_use, batch_info)
        add_timing_info(batch_info, nodes_to_use, start_time, end_time)

        cleanup_code(batch_info[<span class="ruby-string">'@code'</span>])
    else
      self.log(<span class="ruby-string">&quot;running jobs with non-optimized path&quot;</span>)
      jobs.each_with_index { |job_data, i|
          self.log(&quot;on job data number #{i}&quot;)
          <span class="ruby-comment">#message = validate_environment(job_data, secret)</span>
          <span class="ruby-comment">#return message if message != &quot;no error&quot;</span>

          touch_lock_file(job_data)
          self.log(&quot;got run request - #{job_data.inspect}&quot;)

          <span class="ruby-comment">#prejob_status = can_run_job(job_data)</span>
          <span class="ruby-comment">#self.log(&quot;Pre-job status for job_data [#{job_data}] is &quot; +</span>
          <span class="ruby-comment">#  &quot;[#{prejob_status}]&quot;)</span>
          <span class="ruby-comment">#if prejob_status != :ok</span>
          <span class="ruby-comment">#  return prejob_status</span>
          <span class="ruby-comment">#end</span>

          nodes_to_use = acquire_nodes(job_data)

          self.log(&quot;nodes to use are [#{nodes_to_use.join(', ')}]&quot;)
          start_job(nodes_to_use, job_data)

          start_time = <span class="ruby-constant">Time</span>.now()
          master_node = nodes_to_use.first 
          run_job_on_master(master_node, nodes_to_use, job_data)
          end_time = <span class="ruby-constant">Time</span>.now()

          stop_job(nodes_to_use, job_data)

          release_nodes(nodes_to_use, job_data)
          add_timing_info(job_data, nodes_to_use, start_time, end_time)

          cleanup_code(job_data[<span class="ruby-string">'@code'</span>])
      }
    end
  }

  return <span class="ruby-string">&quot;job is now running&quot;</span>
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="stop_babel_master-method" class="method-detail ">
        <a name="method-i-stop_babel_master"></a>

        
        <div class="method-heading">
          <span class="method-name">stop_babel_master</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="stop_babel_master-source">
<pre>
<span class="ruby-comment"># File lib/job_types/babel_helper.rb, line 363</span>
def stop_babel_master()
  <span class="ruby-constant">NeptuneManager</span>.log(&quot;#{my_node.private_ip} is stopping babel master&quot;)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="stop_babel_slave-method" class="method-detail ">
        <a name="method-i-stop_babel_slave"></a>

        
        <div class="method-heading">
          <span class="method-name">stop_babel_slave</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="stop_babel_slave-source">
<pre>
<span class="ruby-comment"># File lib/job_types/babel_helper.rb, line 368</span>
def stop_babel_slave()
  <span class="ruby-constant">NeptuneManager</span>.log(&quot;#{my_node.private_ip} is stopping babel slave&quot;)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="stop_job-method" class="method-detail ">
        <a name="method-i-stop_job"></a>

        
        <div class="method-heading">
          <span class="method-name">stop_job</span><span
            class="method-args">(nodes, job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="stop_job-source">
<pre>
<span class="ruby-comment"># File neptune_manager.rb, line 545</span>
def stop_job(nodes, job_data)
  self.log(<span class="ruby-string">&quot;job - stop&quot;</span>)

  <span class="ruby-comment"># if all the resources are remotely owned, we can't add roles to</span>
  <span class="ruby-comment"># them, so don't</span>
  if nodes.empty?
    self.log(<span class="ruby-string">&quot;no nodes to add roles to, returning...&quot;</span>)
    return
  end

  master_role, slave_role = get_node_roles(job_data)

  master_node = nodes.first
  master_node_ip = master_node.private_ip
  master_node.remove_roles(master_role)

  master_acc = <span class="ruby-constant">AppControllerClient</span>.new(master_node_ip, <span class="ruby-constant">HelperFunctions</span>.get_secret)
  master_acc.remove_role(master_role)

  other_nodes = nodes - [nodes.first]
  remove_roles(other_nodes, slave_role)
  if !other_nodes.nil? and !other_nodes.empty? <span class="ruby-comment"># TODO: prettify me</span>
    other_nodes.each { |node|
      node.remove_roles(slave_role)
    }
  end
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="touch_lock_file-method" class="method-detail ">
        <a name="method-i-touch_lock_file"></a>

        
        <div class="method-heading">
          <span class="method-name">touch_lock_file</span><span
            class="method-args">(job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="touch_lock_file-source">
<pre>
<span class="ruby-comment"># File neptune_manager.rb, line 592</span>
def touch_lock_file(job_data)
  job_data[<span class="ruby-string">&quot;@job_id&quot;</span>] = rand(1000000)
  touch_lock_file = &quot;touch #{get_lock_file_path(job_data)}&quot;
  <span class="ruby-constant">HelperFunctions</span>.shell(touch_lock_file)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="uncompress_file-method" class="method-detail ">
        <a name="method-i-uncompress_file"></a>

        
        <div class="method-heading">
          <span class="method-name">uncompress_file</span><span
            class="method-args">(tar)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="uncompress_file-source">
<pre>
<span class="ruby-comment"># File neptune_manager.rb, line 964</span>
def uncompress_file(tar)
  unless <span class="ruby-constant">File</span>.exists?(tar)
    abort(&quot;The file #{tar} didn't exist, so we couldn't uncompress it.&quot;)
  end

  if tar.scan(<span class="ruby-regexp">/.tar.gz\Z/</span>)
    dir = <span class="ruby-constant">File</span>.dirname(tar)
    <span class="ruby-constant">HelperFunctions</span>.shell(&quot;cd #{dir}; tar zxvf #{tar}&quot;)
    return
  end

  <span class="ruby-comment"># TODO: add other extension types: zip, bzip2, tar, gz</span>
  <span class="ruby-comment">#ext = File.extname(tar)</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment">#case ext</span>
  <span class="ruby-comment">#when &quot;.&quot;</span>
  <span class="ruby-comment">#end</span>
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="validate_environment-method" class="method-detail ">
        <a name="method-i-validate_environment"></a>

        
        <div class="method-heading">
          <span class="method-name">validate_environment</span><span
            class="method-args">(job_data, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="validate_environment-source">
<pre>
<span class="ruby-comment"># File neptune_manager.rb, line 574</span>
def validate_environment(job_data, secret)
  return <span class="ruby-constant">BAD_SECRET_MSG</span> unless valid_secret?(secret)
  <span class="ruby-comment">#return JOB_IN_PROGRESS if lock_file_exists?(job_data)</span>
  return <span class="ruby-constant">BAD_TYPE_MSG</span> unless <span class="ruby-constant">NEPTUNE_JOBS</span>.include?(job_data[<span class="ruby-string">&quot;@type&quot;</span>])

  if job_data[<span class="ruby-string">&quot;@type&quot;</span>] == <span class="ruby-string">&quot;mapreduce&quot;</span>
    return <span class="ruby-constant">BAD_TABLE_MSG</span> unless <span class="ruby-constant">DBS_W_HADOOP</span>.include?(<span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;table&quot;</span>])
  end

  return <span class="ruby-string">&quot;no error&quot;</span>
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="wait_for_allotted_time-method" class="method-detail ">
        <a name="method-i-wait_for_allotted_time"></a>

        
        <div class="method-heading">
          <span class="method-name">wait_for_allotted_time</span><span
            class="method-args">(job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>When spawning up nodes to use for AppScale, we force the user to specify
how long the nodes should live for. This method simply waits that long.
TODO(cgb): What about cases when the nodes should last forever?</p>
          

          
          <div class="method-source-code"
            id="wait_for_allotted_time-source">
<pre>
<span class="ruby-comment"># File lib/job_types/appscale_helper.rb, line 35</span>
def wait_for_allotted_time(job_data)
  start_time = <span class="ruby-constant">Time</span>.now
  time_allotted = <span class="ruby-constant">Integer</span>(job_data[<span class="ruby-string">&quot;@time_needed_for&quot;</span>])
  item_spawned = job_data[<span class="ruby-string">&quot;@add_component&quot;</span>]

  loop {
    now = <span class="ruby-constant">Time</span>.now
    time_elapsed = now - start_time
    <span class="ruby-constant">NeptuneManager</span>.log(&quot;time elapsed for #{item_spawned} so far is&quot; +
      &quot; #{time_elapsed}, time allotted is #{time_allotted}&quot;)
    break if time_elapsed &gt; time_allotted
    <span class="ruby-constant">Kernel</span>.sleep(60)
  }

  remove_lock_file(job_data)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="write_job_output-method" class="method-detail ">
        <a name="method-i-write_job_output"></a>

        
        <div class="method-heading">
          <span class="method-name">write_job_output</span><span
            class="method-args">(job_data, output_location)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="write_job_output-source">
<pre>
<span class="ruby-comment"># File neptune_manager.rb, line 924</span>
def write_job_output(job_data, output_location)
  neptune_write_job_output_handler(job_data, output_location, is_file=true)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="write_job_output_handler-method" class="method-detail ">
        <a name="method-i-write_job_output_handler"></a>

        
        <div class="method-heading">
          <span class="method-name">write_job_output_handler</span><span
            class="method-args">(job_data, output, is_file)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="write_job_output_handler-source">
<pre>
<span class="ruby-comment"># File neptune_manager.rb, line 934</span>
def write_job_output_handler(job_data, output, is_file)
  db_location = job_data[<span class="ruby-string">&quot;@output&quot;</span>]
  job_type = job_data[<span class="ruby-string">&quot;@type&quot;</span>]
  self.log(&quot;[#{job_type}] job done - writing output to #{db_location}&quot;)

  datastore = <span class="ruby-constant">DatastoreFactory</span>.get_datastore(job_data[<span class="ruby-string">'@storage'</span>], job_data)
  if is_file
    datastore.write_remote_file_from_local_file(db_location, output)
  else
    datastore.write_remote_file_from_string(db_location, output)
  end
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="write_job_output_str-method" class="method-detail ">
        <a name="method-i-write_job_output_str"></a>

        
        <div class="method-heading">
          <span class="method-name">write_job_output_str</span><span
            class="method-args">(job_data, string)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="write_job_output_str-source">
<pre>
<span class="ruby-comment"># File neptune_manager.rb, line 929</span>
def write_job_output_str(job_data, string)
  neptune_write_job_output_handler(job_data, string, is_file=false)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
    </div>
  
    <div id="public-class-method-details" class="method-section section">
      <h3 class="section-header">Public Class Methods</h3>

    
      <div id="log-method" class="method-detail ">
        <a name="method-c-log"></a>

        
        <div class="method-heading">
          <span class="method-name">log</span><span
            class="method-args">(msg)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="log-source">
<pre>
<span class="ruby-comment"># File neptune_manager.rb, line 100</span>
def self.log(msg)
  <span class="ruby-constant">Kernel</span>.puts(msg)
  <span class="ruby-constant">STDOUT</span>.flush()
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="neptune_parse_creds-method" class="method-detail ">
        <a name="method-c-neptune_parse_creds"></a>

        
        <div class="method-heading">
          <span class="method-name">neptune_parse_creds</span><span
            class="method-args">(storage, job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="neptune_parse_creds-source">
<pre>
<span class="ruby-comment"># File neptune_manager.rb, line 1026</span>
def self.neptune_parse_creds(storage, job_data)
  creds = {}

  if storage == <span class="ruby-string">&quot;s3&quot;</span>
    [<span class="ruby-string">'EC2_ACCESS_KEY'</span>, <span class="ruby-string">'EC2_SECRET_KEY'</span>, <span class="ruby-string">'S3_URL'</span>].each { |item|
      creds[item] = job_data[&quot;@#{item}&quot;]
    }
  end

  return creds
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="new-method" class="method-detail ">
        <a name="method-c-new"></a>

        
        <div class="method-heading">
          <span class="method-name">new</span><span
            class="method-args">(secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code"
            id="new-source">
<pre>
<span class="ruby-comment"># File neptune_manager.rb, line 95</span>
def initialize(secret)
  <span class="ruby-ivar">@secret</span> = secret
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
    </div>
  

  </div>

  <div id="validator-badges">
    <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
    <p><small>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish
      Rdoc Generator</a> 2</small>.</p>
  </div>

</body>
</html>

