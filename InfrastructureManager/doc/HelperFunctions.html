<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />

  <title>Module: HelperFunctions</title>

  <link rel="stylesheet" href="./rdoc.css" type="text/css" media="screen" />

  <script src="./js/jquery.js" type="text/javascript"
    charset="utf-8"></script>
  <script src="./js/thickbox-compressed.js" type="text/javascript"
    charset="utf-8"></script>
  <script src="./js/quicksearch.js" type="text/javascript"
    charset="utf-8"></script>
  <script src="./js/darkfish.js" type="text/javascript"
    charset="utf-8"></script>

</head>
<body class="module">

  <div id="metadata">
    <div id="home-metadata">
      <div id="home-section" class="section">
        <h3 class="section-header">
          <a href="./index.html">Home</a>
          <a href="./index.html#classes">Classes</a>
          <a href="./index.html#methods">Methods</a>
        </h3>
      </div>
    </div>

    <div id="file-metadata">
      <div id="file-list-section" class="section">
        <h3 class="section-header">In Files</h3>
        <div class="section-body">
          <ul>
          
            <li><a href="./lib/helperfunctions_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/helperfunctions.rb">lib/helperfunctions.rb</a></li>
          
          </ul>
        </div>
      </div>

      
    </div>

    <div id="class-metadata">

      <!-- Parent Class -->
      

      <!-- Namespace Contents -->
      

      <!-- Method Quickref -->
      
      <div id="method-list-section" class="section">
        <h3 class="section-header">Methods</h3>
        <ul class="link-list">
          
          <li><a href="#method-c-convert_fqdn_to_ip">::convert_fqdn_to_ip</a></li>
          
          <li><a href="#method-c-create_appscale_security_group">::create_appscale_security_group</a></li>
          
          <li><a href="#method-c-generate_ssh_key">::generate_ssh_key</a></li>
          
          <li><a href="#method-c-get_cert">::get_cert</a></li>
          
          <li><a href="#method-c-get_ips">::get_ips</a></li>
          
          <li><a href="#method-c-get_key">::get_key</a></li>
          
          <li><a href="#method-c-get_optimal_spot_price">::get_optimal_spot_price</a></li>
          
          <li><a href="#method-c-get_public_ips">::get_public_ips</a></li>
          
          <li><a href="#method-c-get_random_alphanumeric">::get_random_alphanumeric</a></li>
          
          <li><a href="#method-c-get_secret">::get_secret</a></li>
          
          <li><a href="#method-c-log_obscured_env">::log_obscured_env</a></li>
          
          <li><a href="#method-c-obscure_string">::obscure_string</a></li>
          
          <li><a href="#method-c-read_file">::read_file</a></li>
          
          <li><a href="#method-c-set_creds_in_env">::set_creds_in_env</a></li>
          
          <li><a href="#method-c-shell">::shell</a></li>
          
          <li><a href="#method-c-spawn_vms">::spawn_vms</a></li>
          
          <li><a href="#method-c-terminate_vms">::terminate_vms</a></li>
          
          <li><a href="#method-c-write_file">::write_file</a></li>
          
        </ul>
      </div>
      

      <!-- Included Modules -->
      
    </div>

    <div id="project-metadata">
      
      

      <div id="classindex-section" class="section project-section">
        <h3 class="section-header">Class/Module Index
          <span class="search-toggle"><img src="./images/find.png"
            height="16" width="16" alt="[+]"
            title="show/hide quicksearch" /></span></h3>
        <form action="#" method="get" accept-charset="utf-8" class="initially-hidden">
        <fieldset>
          <legend>Quicksearch</legend>
          <input type="text" name="quicksearch" value=""
            class="quicksearch-field" />
        </fieldset>
        </form>

        <ul class="link-list">
        
          <li><a href="./BadConfigurationException.html">BadConfigurationException</a></li>
        
          <li><a href="./HelperFunctions.html">HelperFunctions</a></li>
        
          <li><a href="./InfrastructureManager.html">InfrastructureManager</a></li>
        
          <li><a href="./InfrastructureManagerServer.html">InfrastructureManagerServer</a></li>
        
        </ul>
        <div id="no-class-search-results" style="display: none;">No matching classes.</div>
      </div>

      
    </div>
  </div>

  <div id="documentation">
    <h1 class="module">HelperFunctions</h1>

    <div id="description">
      
<p><a href="HelperFunctions.html">HelperFunctions</a> holds miscellaneous
functions - functions that really aren’t bound to a particular service,
but are reused across multiple functions.</p>

    </div>

    <!-- Constants -->
    
    <div id="constants-list" class="section">
      <h3 class="section-header">Constants</h3>
      <dl>
      
        <dt><a name="MAX_VM_CREATION_TIME">MAX_VM_CREATION_TIME</a></dt>
        
        <dd class="description"><p>The maximum amount of time, in seconds, that we are willing to wait for a
virtual machine to start up, from the initial run-instances request.
Setting this value is a bit of an art, but we choose the value below
because our image is roughly 10GB in size, and if Eucalyptus doesn’t have
the image cached, it could take half an hour to get our image started.</p></dd>
        
      
        <dt><a name="SLEEP_TIME">SLEEP_TIME</a></dt>
        
        <dd class="description"><p>The amount of time that <a
href="HelperFunctions.html#method-c-spawn_vms">spawn_vms</a> waits between
each describe-instances request. Setting this value too low can cause
Eucalyptus to interpret requests as replay attacks.</p></dd>
        
      
        <dt><a name="IP_REGEX">IP_REGEX</a></dt>
        
        <dd class="description"><p>A regular expression that matches IP addresses, used to parse output from
describe-instances to see the IPs for machines currently running.</p></dd>
        
      
        <dt><a name="FQDN_REGEX">FQDN_REGEX</a></dt>
        
        <dd class="description"><p>A regular expression that matches fully qualified domain names, used to 
parse output from describe-instances to see the FQDNs for machines 
currently running.</p></dd>
        
      
        <dt><a name="IP_OR_FQDN">IP_OR_FQDN</a></dt>
        
        <dd class="description"><p>A regular expression that matches IPs or FQDNs. TODO(cgb): The <a
href="HelperFunctions.html#FQDN_REGEX">FQDN_REGEX</a> seems general enough
to match all of these - replace this and <a
href="HelperFunctions.html#IP_REGEX">IP_REGEX</a> with <a
href="HelperFunctions.html#FQDN_REGEX">FQDN_REGEX</a>?</p></dd>
        
      
        <dt><a name="USE_SSL">USE_SSL</a></dt>
        
        <dd class="description"><p>A constant that indicates that SSL should be used when checking if a given
port is open.</p></dd>
        
      
        <dt><a name="DONT_USE_SSL">DONT_USE_SSL</a></dt>
        
        <dd class="description"><p>A constant that indicates that SSL should not be used when checking if a
given port is open.</p></dd>
        
      
      </dl>
    </div>
    

    <!-- Attributes -->
    

    <!-- Methods -->
    
    <div id="public-class-method-details" class="method-section section">
      <h3 class="section-header">Public Class Methods</h3>

    
      <div id="convert_fqdn_to_ip-method" class="method-detail ">
        <a name="method-c-convert_fqdn_to_ip"></a>

        
        <div class="method-heading">
          <span class="method-name">convert_fqdn_to_ip</span><span
            class="method-args">(host)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>In cloudy deployments, the recommended way to determine a machine’s true
private IP address from its private FQDN is to use dig. This method
attempts to resolve IPs in that method, deferring to other methods if that
fails.</p>
          

          
          <div class="method-source-code"
            id="convert_fqdn_to_ip-source">
<pre>
<span class="ruby-comment"># File lib/helperfunctions.rb, line 138</span>
def self.convert_fqdn_to_ip(host)
  return host if host =~ /#{IP_REGEX}/

  ip = self.shell(&quot;dig #{host} +short&quot;).chomp
  if ip.empty?
    <span class="ruby-constant">Kernel</span>.puts(&quot;couldn't use dig to resolve [#{host}]&quot;)
    abort(&quot;Couldn't convert #{host} to an IP address. Result of dig was \n#{ip}&quot;)
  end

  return ip
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="create_appscale_security_group-method" class="method-detail ">
        <a name="method-c-create_appscale_security_group"></a>

        
        <div class="method-heading">
          <span class="method-name">create_appscale_security_group</span><span
            class="method-args">(infrastructure, group)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Creates a new security group in the given cloud infrastructure and opens
all the TCP, UDP, and ICMP ports within it. We open the ports under the
presumption that the AppScale firewall rules will be applied to iptables to
lock back down any ports that need not be open to the world.</p>
          

          
          <div class="method-source-code"
            id="create_appscale_security_group-source">
<pre>
<span class="ruby-comment"># File lib/helperfunctions.rb, line 458</span>
def self.create_appscale_security_group(infrastructure, group)
  self.shell(&quot;#{infrastructure}-add-group #{group} -d appscale 2&gt;&amp;1&quot;)
  self.shell(&quot;#{infrastructure}-authorize #{group} -p 1-65535 -P udp 2&gt;&amp;1&quot;)
  self.shell(&quot;#{infrastructure}-authorize #{group} -p 1-65535 -P tcp 2&gt;&amp;1&quot;)
  self.shell(&quot;#{infrastructure}-authorize #{group} -s 0.0.0.0/0 -P icmp -t -1:-1 2&gt;&amp;1&quot;)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="generate_ssh_key-method" class="method-detail ">
        <a name="method-c-generate_ssh_key"></a>

        
        <div class="method-heading">
          <span class="method-name">generate_ssh_key</span><span
            class="method-args">(outputLocation, name, infrastructure)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Generates a new SSH key for use with the given cloud infrastructure. If the
keyname was already in the system, this method removes it and adds a new
one.</p>
          

          
          <div class="method-source-code"
            id="generate_ssh_key-source">
<pre>
<span class="ruby-comment"># File lib/helperfunctions.rb, line 426</span>
def self.generate_ssh_key(outputLocation, name, infrastructure)
  ec2_output = <span class="ruby-string">&quot;&quot;</span>
  loop {
    ec2_output = self.shell(&quot;#{infrastructure}-add-keypair #{name} 2&gt;&amp;1&quot;)
    break if ec2_output.include?(<span class="ruby-string">&quot;BEGIN RSA PRIVATE KEY&quot;</span>)
    <span class="ruby-constant">Kernel</span>.puts(&quot;Trying again. Saw this from #{infrastructure}-add-keypair: #{ec2_output}&quot;)
    self.shell(&quot;#{infrastructure}-delete-keypair #{name} 2&gt;&amp;1&quot;)
  }

  <span class="ruby-comment"># output is the ssh private key prepended with info we don't need</span>
  <span class="ruby-comment"># delimited by the first \n, so rip it off first to get just the key</span>

  if outputLocation.class == <span class="ruby-constant">String</span>
    outputLocation = [outputLocation]
  end

  outputLocation.each { |path|
    fullPath = <span class="ruby-constant">File</span>.expand_path(path)
    <span class="ruby-constant">File</span>.open(fullPath, <span class="ruby-string">&quot;w&quot;</span>) { |file|
      file.puts(ec2_output)
    }
    <span class="ruby-constant">FileUtils</span>.chmod(0600, fullPath) <span class="ruby-comment"># else ssh won't use the key</span>
  }

  return
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="get_cert-method" class="method-detail ">
        <a name="method-c-get_cert"></a>

        
        <div class="method-heading">
          <span class="method-name">get_cert</span><span
            class="method-args">(filename)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Reads the given file and parses the X509 certificate data it contains.</p>
          

          
          <div class="method-source-code"
            id="get_cert-source">
<pre>
<span class="ruby-comment"># File lib/helperfunctions.rb, line 109</span>
def self.get_cert(filename)
  return nil unless <span class="ruby-constant">File</span>.exists?(filename)
  <span class="ruby-constant">OpenSSL</span>::<span class="ruby-constant">X509</span>::<span class="ruby-constant">Certificate</span>.new(<span class="ruby-constant">File</span>.open(filename) { |f|
    f.read
  })
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="get_ips-method" class="method-detail ">
        <a name="method-c-get_ips"></a>

        
        <div class="method-heading">
          <span class="method-name">get_ips</span><span
            class="method-args">(ips)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Given an array containing public and private IPs, separates them into one
public IP array and a private IP array. Any private IPs are then checked to
see if they resolve properly (which may fail in hybrid cloud deployments),
and any private IPs that do not resolve are replaced with their public IP
equivalents.</p>
          

          
          <div class="method-source-code"
            id="get_ips-source">
<pre>
<span class="ruby-comment"># File lib/helperfunctions.rb, line 156</span>
def self.get_ips(ips)
  abort(<span class="ruby-string">&quot;ips not even length array&quot;</span>) if ips.length % 2 != 0
  reported_public = []
  reported_private = []
  ips.each_index { |index|
    if index % 2 == 0
      reported_public &lt;&lt; ips[index]
    else
      reported_private &lt;&lt; ips[index]
    end
  }
  
  <span class="ruby-constant">Kernel</span>.puts(&quot;Reported Public IPs: [#{reported_public.join(', ')}]&quot;)
  <span class="ruby-constant">Kernel</span>.puts(&quot;Reported Private IPs: [#{reported_private.join(', ')}]&quot;)

  actual_public = []
  actual_private = []
  
  reported_public.each_index { |index|
    pub = reported_public[index]
    pri = reported_private[index]
    if pub != <span class="ruby-string">&quot;0.0.0.0&quot;</span> and pri != <span class="ruby-string">&quot;0.0.0.0&quot;</span>
      actual_public &lt;&lt; pub
      actual_private &lt;&lt; pri
    end
  }
      
  actual_private.each_index { |index|
    begin
      actual_private[index] = <span class="ruby-constant">HelperFunctions</span>.convert_fqdn_to_ip(actual_private[index])
    rescue <span class="ruby-constant">Exception</span>
      <span class="ruby-comment"># this can happen if the private ip doesn't resolve</span>
      <span class="ruby-comment"># which can happen in hybrid environments: euca boxes wont be </span>
      <span class="ruby-comment"># able to resolve ec2 private ips, and vice-versa in euca-managed-mode</span>
      <span class="ruby-constant">Kernel</span>.puts(&quot;rescued! failed to convert #{actual_private[index]} to public&quot;)
      actual_private[index] = actual_public[index]
    end
  }
  
  return actual_public, actual_private
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="get_key-method" class="method-detail ">
        <a name="method-c-get_key"></a>

        
        <div class="method-heading">
          <span class="method-name">get_key</span><span
            class="method-args">(filename)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Reads the given file and parses the SSL private key data that it contains.</p>
          

          
          <div class="method-source-code"
            id="get_key-source">
<pre>
<span class="ruby-comment"># File lib/helperfunctions.rb, line 118</span>
def self.get_key(filename)
  return nil unless <span class="ruby-constant">File</span>.exists?(filename)
  <span class="ruby-constant">OpenSSL</span>::<span class="ruby-constant">PKey</span>::<span class="ruby-constant">RSA</span>.new(<span class="ruby-constant">File</span>.open(filename) { |f|
    f.read
  })
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="get_optimal_spot_price-method" class="method-detail ">
        <a name="method-c-get_optimal_spot_price"></a>

        
        <div class="method-heading">
          <span class="method-name">get_optimal_spot_price</span><span
            class="method-args">(instance_type)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Queries Amazon EC2’s Spot Instance pricing history to see how much other
users have paid for the given instance type (assumed to be a Linux box), so
that we can place a bid that is similar to the average price. How similar
to the average price to pay is a bit of an open problem - for now, we pay
20% more so that in case the market price goes up a little bit, we still
get to keep our instances.</p>
          

          
          <div class="method-source-code"
            id="get_optimal_spot_price-source">
<pre>
<span class="ruby-comment"># File lib/helperfunctions.rb, line 236</span>
def self.get_optimal_spot_price(instance_type)
  command = &quot;ec2-describe-spot-price-history -t #{instance_type} | &quot; +
    <span class="ruby-string">&quot;grep 'Linux/UNIX' | awk '{print $2}'&quot;</span>.split(<span class="ruby-string">&quot;\n&quot;</span>)
  prices = self.shell(&quot;#{command}&quot;)

  average = prices.reduce(0.0) { |sum, price|
    sum += <span class="ruby-constant">Float</span>(price)
  }
  
  average /= prices.length
  plus_twenty = average * 1.20
  
  <span class="ruby-constant">Kernel</span>.puts(&quot;The average spot instance price for a #{instance_type} &quot; +
    &quot;machine is $#{average}, and 20% more is $#{plus_twenty}&quot;)
  return plus_twenty
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="get_public_ips-method" class="method-detail ">
        <a name="method-c-get_public_ips"></a>

        
        <div class="method-heading">
          <span class="method-name">get_public_ips</span><span
            class="method-args">(ips)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Similar to <a href="HelperFunctions.html#method-c-get_ips">get_ips</a>, but
does not attempt to resolve the private IPs seen. Returns a single array
with the public IPs from the original array (which contains both public and
private IPs).</p>
          

          
          <div class="method-source-code"
            id="get_public_ips-source">
<pre>
<span class="ruby-comment"># File lib/helperfunctions.rb, line 202</span>
def self.get_public_ips(ips)
  abort(<span class="ruby-string">&quot;ips not even length array&quot;</span>) if ips.length % 2 != 0
  reported_public = []
  reported_private = []
  ips.each_index { |index|
    if index % 2 == 0
      reported_public &lt;&lt; ips[index]
    else
      reported_private &lt;&lt; ips[index]
    end
  }
  
  <span class="ruby-constant">Kernel</span>.puts(&quot;Reported Public IPs: [#{reported_public.join(', ')}]&quot;)
  <span class="ruby-constant">Kernel</span>.puts(&quot;Reported Private IPs: [#{reported_private.join(', ')}]&quot;)
  
  public_ips = []
  reported_public.each_index { |index|
    if reported_public[index] != <span class="ruby-string">&quot;0.0.0.0&quot;</span>
      public_ips &lt;&lt; reported_public[index]
    elsif reported_private[index] != <span class="ruby-string">&quot;0.0.0.0&quot;</span>
      public_ips &lt;&lt; reported_private[index]
    end
  }
  
  return public_ips.flatten
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="get_random_alphanumeric-method" class="method-detail ">
        <a name="method-c-get_random_alphanumeric"></a>

        
        <div class="method-heading">
          <span class="method-name">get_random_alphanumeric</span><span
            class="method-args">(length=10)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Returns a random string composed of alphanumeric characters, as long as the
user requests.</p>
          

          
          <div class="method-source-code"
            id="get_random_alphanumeric-source">
<pre>
<span class="ruby-comment"># File lib/helperfunctions.rb, line 95</span>
def self.get_random_alphanumeric(length=10)
  random = <span class="ruby-string">&quot;&quot;</span>
  possible = <span class="ruby-string">&quot;0123456789abcdefghijklmnopqrstuvxwyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>
  possible_length = possible.length
   
  length.times { |index|
    random &lt;&lt; possible[<span class="ruby-constant">Kernel</span>.rand(possible_length)]
  }
   
  return random
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="get_secret-method" class="method-detail ">
        <a name="method-c-get_secret"></a>

        
        <div class="method-heading">
          <span class="method-name">get_secret</span><span
            class="method-args">(filename="/etc/appscale/secret.key")</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Reads a file that contains the AppScale shared secret (a password that is
used to authenticate remote calls/callers), returning the secret that file
contains.</p>
          

          
          <div class="method-source-code"
            id="get_secret-source">
<pre>
<span class="ruby-comment"># File lib/helperfunctions.rb, line 129</span>
def self.get_secret(filename=<span class="ruby-string">&quot;/etc/appscale/secret.key&quot;</span>)
  return self.read_file(<span class="ruby-constant">File</span>.expand_path(filename), chomp=true)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="log_obscured_env-method" class="method-detail ">
        <a name="method-c-log_obscured_env"></a>

        
        <div class="method-heading">
          <span class="method-name">log_obscured_env</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Prints out a list of environment variables currently set in this process’
runtime and their values. For any EC2 user credentials, we obscure out any
sensitive information.</p>
          

          
          <div class="method-source-code"
            id="log_obscured_env-source">
<pre>
<span class="ruby-comment"># File lib/helperfunctions.rb, line 488</span>
def self.log_obscured_env()
  env = self.shell(<span class="ruby-string">&quot;env&quot;</span>)

  [<span class="ruby-string">&quot;EC2_ACCESS_KEY&quot;</span>, <span class="ruby-string">&quot;EC2_SECRET_KEY&quot;</span>].each { |cred|
    if env =~ /#{cred}=(.*)/
      env.gsub!(/#{cred}=(.*)/, &quot;#{cred}=#{self.obscure_string($1)}&quot;)
    end
  }
 
  <span class="ruby-constant">Kernel</span>.puts(env)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="obscure_string-method" class="method-detail ">
        <a name="method-c-obscure_string"></a>

        
        <div class="method-heading">
          <span class="method-name">obscure_string</span><span
            class="method-args">(string)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Obscures out sensitive strings by replacing most of the characters with a
dummy character. Callers can use this method to print out credentials that
may be logged and thus sent over e-mail (and thus should not be completely
exposed in cleartext).</p>
          

          
          <div class="method-source-code"
            id="obscure_string-source">
<pre>
<span class="ruby-comment"># File lib/helperfunctions.rb, line 477</span>
def self.obscure_string(string)
  return string if string.nil? or string.length &lt; 4
  last_four = string[string.length-4, string.length]
  obscured = <span class="ruby-string">&quot;*&quot;</span> * (string.length-4)
  return obscured + last_four
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="read_file-method" class="method-detail ">
        <a name="method-c-read_file"></a>

        
        <div class="method-heading">
          <span class="method-name">read_file</span><span
            class="method-args">(location, chomp=true)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>A convenience method that can be used to read a file and return its
contents as a String.</p>
          

          
          <div class="method-source-code"
            id="read_file-source">
<pre>
<span class="ruby-comment"># File lib/helperfunctions.rb, line 83</span>
def self.read_file(location, chomp=true)
  file = <span class="ruby-constant">File</span>.open(location) { |f| f.read }
  if chomp
    return file.chomp
  else
    return file
  end
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="set_creds_in_env-method" class="method-detail ">
        <a name="method-c-set_creds_in_env"></a>

        
        <div class="method-heading">
          <span class="method-name">set_creds_in_env</span><span
            class="method-args">(creds, cloud_num)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Given a Hash of EC2 credentials, sets them as environment variables in the
current environment. This avoids having to specify them as command-line
arguments once we attempt to run any EC2 command-line tools.</p>
          

          
          <div class="method-source-code"
            id="set_creds_in_env-source">
<pre>
<span class="ruby-comment"># File lib/helperfunctions.rb, line 257</span>
def self.set_creds_in_env(creds, cloud_num)
  <span class="ruby-constant">ENV</span>[<span class="ruby-string">'EC2_JVM_ARGS'</span>] = nil

  creds.each_pair { |k, v|
    next unless k =~ /\ACLOUD#{cloud_num}/
    env_key = k.scan(/\ACLOUD#{cloud_num}_(.*)\Z/).flatten.to_s
    <span class="ruby-constant">ENV</span>[env_key] = v
  }

  <span class="ruby-comment"># note that key and cert vars are set wrong - they refer to</span>
  <span class="ruby-comment"># the location on the user's machine where the key is</span>
  <span class="ruby-comment"># thus, let's fix that</span>

  cloud_keys_dir = <span class="ruby-constant">File</span>.expand_path(&quot;/etc/appscale/keys/cloud#{cloud_num}&quot;)
  <span class="ruby-constant">ENV</span>[<span class="ruby-string">'EC2_PRIVATE_KEY'</span>] = &quot;#{cloud_keys_dir}/mykey.pem&quot;
  <span class="ruby-constant">ENV</span>[<span class="ruby-string">'EC2_CERT'</span>] = &quot;#{cloud_keys_dir}/mycert.pem&quot;

  <span class="ruby-constant">Kernel</span>.puts(&quot;Setting private key to #{cloud_keys_dir}/mykey.pem, cert to #{cloud_keys_dir}/mycert.pem&quot;)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="shell-method" class="method-detail ">
        <a name="method-c-shell"></a>

        
        <div class="method-heading">
          <span class="method-name">shell</span><span
            class="method-args">(cmd)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Logs and executes a shell command - useful for mocking since flexmock
can’t mock out the backticks method (Kernel:`), but it can mock out this
method.</p>
          

          
          <div class="method-source-code"
            id="shell-source">
<pre>
<span class="ruby-comment"># File lib/helperfunctions.rb, line 69</span>
def self.shell(cmd)
  <span class="ruby-constant">Kernel</span>.puts(cmd)
  return `#{cmd}`
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="spawn_vms-method" class="method-detail ">
        <a name="method-c-spawn_vms"></a>

        
        <div class="method-heading">
          <span class="method-name">spawn_vms</span><span
            class="method-args">(parameters)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>This method spawns virtual machines in a supported cloud infrastructure. It
dispatches the initial request for machines, waits for them to start, and
returns the public IPs, private IPs, and instance IDs of the machines that
were started.</p>
          

          
          <div class="method-source-code"
            id="spawn_vms-source">
<pre>
<span class="ruby-comment"># File lib/helperfunctions.rb, line 282</span>
def self.spawn_vms(parameters)
  num_of_vms_to_spawn = <span class="ruby-constant">Integer</span>(parameters[<span class="ruby-string">'num_vms'</span>])
  image_id = parameters[<span class="ruby-string">'image_id'</span>]
  instance_type = parameters[<span class="ruby-string">'instance_type'</span>]
  keyname = parameters[<span class="ruby-string">'keyname'</span>]
  infrastructure = parameters[<span class="ruby-string">'infrastructure'</span>]
  cloud = parameters[<span class="ruby-string">'cloud'</span>]
  group = parameters[<span class="ruby-string">'group'</span>]
  spot = false
  <span class="ruby-constant">Kernel</span>.puts(&quot;[#{num_of_vms_to_spawn}] [#{image_id}]  [#{instance_type}] [#{keyname}] [#{infrastructure}] [#{cloud}] [#{group}] [#{spot}]&quot;)

  start_time = <span class="ruby-constant">Time</span>.now

  public_ips = []
  private_ips = []
  instance_ids = []

  if num_of_vms_to_spawn &lt; 1
    return public_ips, private_ips, instance_ids
  end

  ssh_key = <span class="ruby-constant">File</span>.expand_path(&quot;/etc/appscale/keys/#{cloud}/#{keyname}.key&quot;)
  <span class="ruby-constant">Kernel</span>.puts(&quot;About to spawn VMs, expecting to find a key at #{ssh_key}&quot;)

  self.log_obscured_env

  new_cloud = !<span class="ruby-constant">File</span>.exists?(ssh_key)
  if new_cloud <span class="ruby-comment"># need to create security group and key</span>
    <span class="ruby-constant">Kernel</span>.puts(&quot;Creating keys/security group for #{cloud}&quot;)
    self.generate_ssh_key(ssh_key, keyname, infrastructure)
    self.create_appscale_security_group(infrastructure, group)
  else
    <span class="ruby-constant">Kernel</span>.puts(&quot;Not creating keys/security group for #{cloud}&quot;)
  end

  instance_ids_up = []
  public_up_already = []
  private_up_already = []
  <span class="ruby-constant">Kernel</span>.puts(&quot;EC2_URL = [#{ENV['EC2_URL']}]&quot;)
  loop { <span class="ruby-comment"># need to make sure ec2 doesn't return an error message here</span>
    describe_instances = self.shell(&quot;#{infrastructure}-describe-instances 2&gt;&amp;1&quot;)
    <span class="ruby-constant">Kernel</span>.puts(&quot;describe-instances says [#{describe_instances}]&quot;)
    all_ip_addrs = describe_instances.scan(/\s+(#{IP_OR_FQDN})\s+(#{IP_OR_FQDN})\s+running\s+#{keyname}\s/).flatten
    instance_ids_up = describe_instances.scan(<span class="ruby-regexp">/INSTANCE\s+(i-\w+)/</span>).flatten
    public_up_already, private_up_already = <span class="ruby-constant">HelperFunctions</span>.get_ips(all_ip_addrs)
    vms_up_already = describe_instances.scan(/(#{IP_OR_FQDN})\s+running\s+#{keyname}\s+/).length
    break if vms_up_already &gt; 0 or new_cloud <span class="ruby-comment"># crucial for hybrid cloud, where one box may not be running yet</span>
  }
 
  args = &quot;-k #{keyname} -n #{num_of_vms_to_spawn} --instance-type #{instance_type} --group #{group} #{image_id}&quot;
  if spot
    price = <span class="ruby-constant">HelperFunctions</span>.get_optimal_spot_price(instance_type)
    command_to_run = &quot;ec2-request-spot-instances -p #{price} #{args}&quot;
  else
    command_to_run = &quot;#{infrastructure}-run-instances #{args}&quot;
  end

  loop {
    <span class="ruby-constant">Kernel</span>.puts(command_to_run)
    run_instances = self.shell(&quot;#{command_to_run} 2&gt;&amp;1&quot;)
    <span class="ruby-constant">Kernel</span>.puts(&quot;run_instances says [#{run_instances}]&quot;)
    if run_instances =~ <span class="ruby-regexp">/Please try again later./</span>
      <span class="ruby-constant">Kernel</span>.puts(&quot;Error with run_instances: #{run_instances}. Will try again in a moment.&quot;)
    elsif run_instances =~ <span class="ruby-regexp">/try --addressing private/</span>
      <span class="ruby-constant">Kernel</span>.puts(<span class="ruby-string">&quot;Need to retry with addressing private. Will try again in a moment.&quot;</span>)
      command_to_run &lt;&lt; <span class="ruby-string">&quot; --addressing private&quot;</span>
    elsif run_instances =~ <span class="ruby-regexp">/PROBLEM/</span>
      <span class="ruby-constant">Kernel</span>.puts(&quot;Error: #{run_instances}&quot;)
      abort(&quot;Saw the following error message from EC2 tools. Please resolve the issue and try again:\n#{run_instances}&quot;)
    else
      <span class="ruby-constant">Kernel</span>.puts(<span class="ruby-string">&quot;Run instances message sent successfully. Waiting for the image to start up.&quot;</span>)
      break
    end
    <span class="ruby-constant">Kernel</span>.puts(<span class="ruby-string">&quot;sleepy time&quot;</span>)
    <span class="ruby-constant">Kernel</span>.sleep(5)
  }
  
  instance_ids = []
  public_ips = []
  private_ips = []

  <span class="ruby-constant">Kernel</span>.sleep(10) <span class="ruby-comment"># euca 2.0.3 can throw forbidden errors if we hit it too fast</span>
  <span class="ruby-comment"># TODO: refactor me to use rightaws gem, check for forbidden, and retry accordingly</span>

  end_time = <span class="ruby-constant">Time</span>.now + <span class="ruby-constant">MAX_VM_CREATION_TIME</span>
  while (now = <span class="ruby-constant">Time</span>.now) &lt; end_time
    describe_instances = self.shell(&quot;#{infrastructure}-describe-instances 2&gt;&amp;1&quot;)
    <span class="ruby-constant">Kernel</span>.puts(&quot;[#{Time.now}] #{end_time - now} seconds left...&quot;)
    <span class="ruby-constant">Kernel</span>.puts(describe_instances)
 
    <span class="ruby-comment"># TODO: match on instance id</span>
    <span class="ruby-comment">#if describe_instances =~ /terminated\s+#{keyname}\s+/</span>
    <span class="ruby-comment">#  terminated_message = &quot;An instance was unexpectedly terminated. &quot; +</span>
    <span class="ruby-comment">#    &quot;Please contact your cloud administrator to determine why &quot; +</span>
    <span class="ruby-comment">#    &quot;and try again. \n#{describe_instances}&quot;</span>
    <span class="ruby-comment">#  Kernel.puts(terminated_message)</span>
    <span class="ruby-comment">#  abort(terminated_message)</span>
    <span class="ruby-comment">#end</span>
    
    <span class="ruby-comment"># changed regexes so ensure we are only checking for instances created</span>
    <span class="ruby-comment"># for appscale only (don't worry about other instances created)</span>
    
    all_ip_addrs = describe_instances.scan(/\s+(#{IP_OR_FQDN})\s+(#{IP_OR_FQDN})\s+running\s+#{keyname}\s+/).flatten
    public_ips, private_ips = <span class="ruby-constant">HelperFunctions</span>.get_ips(all_ip_addrs)
    public_ips = public_ips - public_up_already
    private_ips = private_ips - private_up_already
    instance_ids = describe_instances.scan(/INSTANCE\s+(i-\w+)\s+[\w\-\s\.]+#{keyname}/).flatten - instance_ids_up
    break if public_ips.length == num_of_vms_to_spawn
    <span class="ruby-constant">Kernel</span>.sleep(<span class="ruby-constant">SLEEP_TIME</span>)
  end
  
  if public_ips.length.zero?
    abort(<span class="ruby-string">&quot;No public IPs were able to be procured within the time limit.&quot;</span>)
  end
  
  if public_ips.length != num_of_vms_to_spawn
    potential_dead_ips = <span class="ruby-constant">HelperFunctions</span>.get_ips(all_ip_addrs) - public_up_already
    potential_dead_ips.each_index { |index|
      if potential_dead_ips[index] == <span class="ruby-string">&quot;0.0.0.0&quot;</span>
        instance_to_term = instance_ids[index]
        <span class="ruby-constant">Kernel</span>.puts(&quot;Instance #{instance_to_term} failed to get a public IP address and is being terminated.&quot;)
        self.shell(&quot;#{infrastructure}-terminate-instances #{instance_to_term}&quot;)
      end
    }
  end         
  
  end_time = <span class="ruby-constant">Time</span>.now
  total_time = end_time - start_time

  if spot
    <span class="ruby-constant">Kernel</span>.puts(&quot;TIMING: It took #{total_time} seconds to spawn &quot; +
      &quot;#{num_of_vms_to_spawn} spot instances&quot;)
  else
    <span class="ruby-constant">Kernel</span>.puts(&quot;TIMING: It took #{total_time} seconds to spawn &quot; +
      &quot;#{num_of_vms_to_spawn} regular instances&quot;)
  end

  return public_ips, private_ips, instance_ids
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="terminate_vms-method" class="method-detail ">
        <a name="method-c-terminate_vms"></a>

        
        <div class="method-heading">
          <span class="method-name">terminate_vms</span><span
            class="method-args">(ids, infrastructure)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Given a list of instance ids, terminates them in the given cloud
infrastructure.</p>
          

          
          <div class="method-source-code"
            id="terminate_vms-source">
<pre>
<span class="ruby-comment"># File lib/helperfunctions.rb, line 468</span>
def self.terminate_vms(ids, infrastructure)
  self.shell(&quot;#{infrastructure}-terminate-instances #{ids.join(' ')} 2&gt;&amp;1&quot;)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="write_file-method" class="method-detail ">
        <a name="method-c-write_file"></a>

        
        <div class="method-heading">
          <span class="method-name">write_file</span><span
            class="method-args">(location, contents)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>A convenience method that can be used to write a String to a file, creating
that file if it does not exist.</p>
          

          
          <div class="method-source-code"
            id="write_file-source">
<pre>
<span class="ruby-comment"># File lib/helperfunctions.rb, line 76</span>
def self.write_file(location, contents)
  <span class="ruby-constant">File</span>.open(location, <span class="ruby-string">&quot;w+&quot;</span>) { |file| file.write(contents) }
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
    </div>
  

  </div>

  <div id="validator-badges">
    <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
    <p><small>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish
      Rdoc Generator</a> 2</small>.</p>
  </div>

</body>
</html>

